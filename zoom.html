<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Dots Carpet — GPU Ripple (Mobile)</title>
<style>
  :root{
    --bg:#0b0c0f; --fg:#e6e6e6; --muted:#a9b2bf; --panel:#0e1219; --border:#1e2531;
    --safe-bottom: env(safe-area-inset-bottom, 0px);
    --safe-top: env(safe-area-inset-top, 0px);
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial;}
  #app{position:fixed;inset:0;display:grid;grid-template-rows:1fr auto;}
  canvas{display:block;width:100%;height:100%;touch-action:none;background:var(--bg);}
  /* Control bar (text labels only) */
  #bar{
    position:fixed;left:0;right:0;bottom:0;
    padding:10px 12px calc(10px + var(--safe-bottom));
    display:flex;gap:10px;justify-content:center;align-items:center;
    background:linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.45) 40%, rgba(0,0,0,0.65) 100%);
  }
  .btn{
    min-width:72px;min-height:44px;
    padding:10px 14px;border:1px solid var(--border);
    background:var(--panel); color:var(--fg); border-radius:14px; font-weight:650;
  }
  .btn:active{transform:translateY(1px);}
  /* Drawer */
  #drawer{
    position:fixed; left:0; right:0; bottom:calc(78px + var(--safe-bottom));
    margin:0 auto; max-width:900px;
    transform:translateY(110%); transition:transform .25s ease;
    padding:10px 12px;
  }
  #drawer.open{ transform:translateY(0%); }
  .panel{
    background:rgba(14,18,25,0.92); border:1px solid var(--border);
    border-radius:16px; padding:12px;
    display:grid; grid-template-columns:1fr 1fr; gap:10px;
  }
  .row{display:flex;justify-content:space-between;align-items:center;gap:10px;}
  label{font-size:12px;color:var(--muted);}
  input[type=range]{flex:1}
  input[type=number]{width:100px;background:#0f131b;color:var(--fg);border:1px solid var(--border);border-radius:10px;padding:6px 8px;}
  .readout{
    position:fixed; left:10px; top:calc(8px + var(--safe-top));
    padding:6px 8px; border:1px solid var(--border); background:rgba(14,18,25,0.85);
    border-radius:10px; font-size:12px; color:var(--muted); font-variant-numeric:tabular-nums;
  }
  @media(min-width:720px){ .panel{grid-template-columns:repeat(3,1fr)} }
</style>
</head>
<body>
<div id="app">
  <canvas id="gl" aria-label="Dots carpet GPU"></canvas>
  <div id="drawer" aria-hidden="true">
    <div class="panel">
      <div class="row"><label>Dot pitch (px @ 1×)</label><input id="pitch" type="number" min="8" max="128" step="1" value="18"></div>
      <div class="row"><label>Dot radius (px)</label><input id="radius" type="number" min="1" max="24" step="1" value="4"></div>
      <div class="row"><label>Ripple speed</label><input id="speed" type="range" min="0.05" max="3.0" step="0.01" value="1.0"></div>
      <div class="row"><label>Wavelength (tiles)</label><input id="lambda" type="number" min="1" max="64" step="1" value="10"></div>
      <div class="row"><label>Hue cycle</label><input id="hue" type="number" min="0" max="360" step="1" value="220"></div>
      <div class="row"><label>Saturation</label><input id="sat" type="range" min="0" max="1" step="0.01" value="0.75"></div>
      <div class="row"><label>Lightness</label><input id="light" type="range" min="0" max="1" step="0.01" value="0.55"></div>
      <div class="row"><label>Snap zoom (¼)</label><input id="snap" type="checkbox" checked></div>
      <div class="row"><label>Max levels</label><input id="maxlvl" type="number" min="64" max="1024" value="256"></div>
    </div>
  </div>
  <div class="readout" id="readout"></div>
  <div id="bar" role="toolbar" aria-label="Controls">
    <button id="menu" class="btn" aria-expanded="false">Menu</button>
    <button id="zoomOut" class="btn">Zoom Out</button>
    <button id="zoomIn" class="btn">Zoom In</button>
    <button id="reset" class="btn">Reset</button>
    <button id="snapshot" class="btn">Snapshot</button>
  </div>
</div>
<script>
// WebGL2 setup
const canvas = document.getElementById('gl');
const gl = canvas.getContext('webgl2', {antialias:false, preserveDrawingBuffer:true});
if(!gl){ alert('WebGL2 not supported'); }

const vsrc = `#version 300 es
in vec2 p;
out vec2 v_uv;
void main(){
  v_uv = p*0.5 + 0.5;
  gl_Position = vec4(p, 0.0, 1.0);
}`;

const fsrc = `#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 frag;

uniform vec2  u_res;
uniform float u_time;
uniform vec2  u_cam;     // world center
uniform float u_scale;   // pixels per world unit
uniform float u_pitch;   // world units between dot centers at level 0
uniform float u_r_px;    // dot radius in screen pixels
uniform float u_speed;   // ripple speed
uniform float u_lambda;  // wavelength in tiles
uniform float u_hue0;    // base hue [0,360)
uniform float u_sat;     // [0,1]
uniform float u_light;   // [0,1]

// hsv->rgb via IQ method (using hue in [0,1])
vec3 hsv2rgb(vec3 c){
  vec3 rgb = clamp( abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0 );
  return c.z * mix(vec3(1.0), rgb, c.y);
}

void main(){
  // Screen -> world
  vec2 fragPx = gl_FragCoord.xy;
  vec2 centered = fragPx - 0.5 * u_res;   // pixels, center at 0
  vec2 world = u_cam + centered / u_scale; // world units

  // Find position within the infinite dot lattice
  float P = u_pitch;
  vec2 grid = world / P;                  // grid coords (tile units)
  vec2 cell = fract(grid) - 0.5;          // -0.5..0.5 in each tile
  // distance in screen pixels to the dot center at this cell center
  vec2 dWorld = cell * P;                 // world delta to nearest center
  vec2 dPx = dWorld * u_scale;            // convert to pixels
  float distPx = length(dPx);

  // Anti-aliased circle
  float R = u_r_px;
  float aa = 1.0; // ~1px smoothing
  float dotAlpha = smoothstep(R + aa, R - aa, distPx);

  // Ripple from a fixed world center (0,0) to emulate the original effect
  float tileDist = length(world) / P;     // in tiles
  float lambda = max(1.0, u_lambda);
  float phase = 6.28318530718 * (tileDist / lambda - u_time * u_speed);
  float ripple = sin(phase);

  // Color modulation
  float hue = (u_hue0/360.0 + 0.12*ripple);
  float sat = clamp(u_sat + 0.25*ripple, 0.0, 1.0);
  float val = clamp(u_light + 0.35*ripple, 0.0, 1.0);

  // Vary hue slightly per tile to avoid banding but keep carpet feel
  vec2 ij = floor(grid);
  float jitter = fract(sin(dot(ij, vec2(127.1, 311.7))) * 43758.5453);
  hue = fract(hue + 0.05*(jitter-0.5));

  vec3 col = hsv2rgb(vec3(hue, sat, val));

  // Composite dot onto dark background
  vec3 bg = vec3(0.06,0.07,0.09);
  vec3 rgb = mix(bg, col, dotAlpha);

  frag = vec4(rgb, 1.0);
}`;

// Compile & link
function compile(type, src){
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
    throw new Error(gl.getShaderInfoLog(sh) || 'shader compile failed');
  }
  return sh;
}
const vs = compile(gl.VERTEX_SHADER, vsrc);
const fs = compile(gl.FRAGMENT_SHADER, fsrc);
const prog = gl.createProgram();
gl.attachShader(prog, vs);
gl.attachShader(prog, fs);
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
  throw new Error(gl.getProgramInfoLog(prog) || 'link failed');
}
gl.useProgram(prog);

// Fullscreen quad
const quad = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quad);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1,-1, 1,-1, -1,1,
  -1,1,  1,-1, 1,1
]), gl.STATIC_DRAW);
const locP = gl.getAttribLocation(prog, 'p');
gl.enableVertexAttribArray(locP);
gl.vertexAttribPointer(locP, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const U = n => gl.getUniformLocation(prog, n);
const u_res   = U('u_res');
const u_time  = U('u_time');
const u_cam   = U('u_cam');
const u_scale = U('u_scale');
const u_pitch = U('u_pitch');
const u_r_px  = U('u_r_px');
const u_speed = U('u_speed');
const u_lambda= U('u_lambda');
const u_hue0  = U('u_hue0');
const u_sat   = U('u_sat');
const u_light = U('u_light');

// UI and camera
const readout = document.getElementById('readout');
const drawer  = document.getElementById('drawer');
const menuBtn = document.getElementById('menu');
const zoomIn  = document.getElementById('zoomIn');
const zoomOut = document.getElementById('zoomOut');
const reset   = document.getElementById('reset');
const snapshot= document.getElementById('snapshot');

const pitchEl = document.getElementById('pitch');
const radiusEl= document.getElementById('radius');
const speedEl = document.getElementById('speed');
const lambdaEl= document.getElementById('lambda');
const hueEl   = document.getElementById('hue');
const satEl   = document.getElementById('sat');
const lightEl = document.getElementById('light');
const snapEl  = document.getElementById('snap');
const maxlvlEl= document.getElementById('maxlvl');

const cam = { x:0, y:0, z:0 }; // world center, log2 zoom
let basePx = +pitchEl.value;   // pixels per world tile at z=0

function resize(){
  const dpr = Math.min(2, window.devicePixelRatio||1);
  const w = Math.floor(canvas.clientWidth*dpr);
  const h = Math.floor(canvas.clientHeight*dpr);
  if(canvas.width!==w || canvas.height!==h){
    canvas.width = w; canvas.height = h;
    gl.viewport(0,0,w,h);
  }
}
window.addEventListener('resize', resize);

function pxPerWorld(){ return basePx * Math.pow(2, cam.z); }

// Gestures: pan, pinch, double-tap
const active = new Map();
let lastTapTime = 0, lastTapPos = {x:0,y:0};

canvas.addEventListener('pointerdown', e=>{ canvas.setPointerCapture(e.pointerId); active.set(e.pointerId, {x:e.clientX,y:e.clientY}); });
canvas.addEventListener('pointerup', e=>{
  active.delete(e.pointerId);
  canvas.releasePointerCapture(e.pointerId);
  const now=performance.now(), dx=e.clientX-lastTapPos.x, dy=e.clientY-lastTapPos.y;
  if(now-lastTapTime<300 && Math.hypot(dx,dy)<30){
    zoomAt(canvas.width*0.5, canvas.height*0.5, +1);
  }
  lastTapTime=now; lastTapPos={x:e.clientX,y:e.clientY};
});
canvas.addEventListener('pointercancel', e=>{ active.delete(e.pointerId); });
canvas.addEventListener('pointermove', e=>{
  if(!active.has(e.pointerId)) return;
  active.set(e.pointerId,{x:e.clientX,y:e.clientY});
  const ids = Array.from(active.keys());
  if(ids.length===1){
    const p = active.get(ids[0]);
    if(typeof p.lx==='number'){
      const dx=(p.x-p.lx), dy=(p.y-p.ly);
      const s = pxPerWorld();
      // Convert pointer delta (CSS px) to device px using current backing store ratio
      const dpr = Math.min(2, window.devicePixelRatio||1);
      cam.x -= (dx*dpr)/s;
      cam.y += (dy*dpr)/s; // y inverted to keep drag natural
    }
    p.lx=p.x; p.ly=p.y;
  } else if(ids.length>=2){
    const p1=active.get(ids[0]), p2=active.get(ids[1]);
    if(!p1||!p2) return;
    const d=Math.hypot(p2.x-p1.x, p2.y-p1.y);
    if(typeof canvas._d0==='number'){
      const scale = d / canvas._d0;
      if(scale>0){
        const dz = Math.log2(scale);
        const maxlv = +maxlvlEl.value;
        cam.z = Math.max(-maxlv, Math.min(maxlv, cam.z + dz));
        if(snapEl.checked) cam.z = Math.round(cam.z*4)/4;
      }
    }
    canvas._d0 = d;
  }
},{passive:false});

canvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const dz = -Math.sign(e.deltaY)*0.25;
  const maxlv = +maxlvlEl.value;
  cam.z = Math.max(-maxlv, Math.min(maxlv, cam.z + dz));
  if(snapEl.checked) cam.z = Math.round(cam.z*4)/4;
},{passive:false});

function zoomAt(px, py, dir){
  const maxlv = +maxlvlEl.value;
  cam.z = Math.max(-maxlv, Math.min(maxlv, cam.z + dir));
  if(snapEl.checked) cam.z = Math.round(cam.z);
}

menuBtn.onclick = ()=>{
  const open = !drawer.classList.contains('open');
  drawer.classList.toggle('open', open);
  menuBtn.setAttribute('aria-expanded', open?'true':'false');
};
zoomIn.onclick = ()=> zoomAt(canvas.width*0.5, canvas.height*0.5, +1);
zoomOut.onclick= ()=> zoomAt(canvas.width*0.5, canvas.height*0.5, -1);
reset.onclick  = ()=>{ cam.x=0; cam.y=0; cam.z=0; };
snapshot.onclick = ()=>{
  const url = canvas.toDataURL('image/png');
  const a = document.createElement('a'); a.href=url; a.download='dots_gpu.png'; a.click();
};

// Render loop
let start = performance.now();
function frame(){
  resize();
  const t = (performance.now()-start)/1000;
  gl.useProgram(prog);
  gl.uniform2f(u_res, canvas.width, canvas.height);
  gl.uniform1f(u_time, t);
  gl.uniform2f(u_cam, cam.x, cam.y);
  gl.uniform1f(u_scale, pxPerWorld());
  gl.uniform1f(u_pitch, 1.0); // world units per tile; basePx maps pixels at z=0
  gl.uniform1f(u_r_px, +radiusEl.value);
  gl.uniform1f(u_speed, +speedEl.value);
  gl.uniform1f(u_lambda, +lambdaEl.value);
  gl.uniform1f(u_hue0, +hueEl.value);
  gl.uniform1f(u_sat, +satEl.value);
  gl.uniform1f(u_light, +lightEl.value);

  gl.drawArrays(gl.TRIANGLES, 0, 6);

  // Readout
  const ppu = pxPerWorld().toFixed(2);
  document.getElementById('readout').textContent = `zoom(log2)=${cam.z.toFixed(3)}  px/unit=${ppu}`;

  requestAnimationFrame(frame);
}
frame();
</script>
</body>
</html>
