<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>voice reader — mobile v11</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#0f172a; --text:#e5e7eb; --muted:#9aa4b2; --border:#1f2937; --accent:#3b82f6;
    --radius:14px; --pad:14px; --maxw:520px;
  }
  html,body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;height:100%;}
  .app{min-height:100svh; display:flex; flex-direction:column; align-items:center;}

  /* Top tabs */
  .tabs-top{position:sticky; top:0; left:0; right:0; z-index:10;
            backdrop-filter:saturate(120%) blur(8px); background:rgba(15,23,42,.92);
            border-bottom:1px solid var(--border); width:100%; display:flex; justify-content:center;
            padding:calc(env(safe-area-inset-top) + 6px) var(--pad) 8px;}
  .tabs-top .bar{width:100%; max-width:var(--maxw); display:grid; grid-template-columns:repeat(4,1fr); gap:10px;}
  .tabbtn{appearance:none; border:1px solid var(--border); background:#0b1220; color:#e5e7eb;
          border-radius:12px; padding:10px; font-weight:700; min-height:44px;}
  .tabbtn.active{background:#3b82f6; border-color:#2563eb;}

  /* Screens */
  .screen{width:100%; max-width:var(--maxw); padding:12px var(--pad) var(--pad);
          box-sizing:border-box; flex:1; display:flex; flex-direction:column; gap:12px; min-height:0;}
  .card{background:var(--panel); border:1px solid var(--border); border-radius:var(--radius);
        padding:12px; display:flex; flex-direction:column; gap:12px; flex:1; min-height:0;}

  /* Controls */
  .btn{appearance:none; border:1px solid var(--border); background:#111827; color:#e5e7eb;
       border-radius:16px; padding:14px 18px; font-weight:800; font-size:16px;
       width:100%; touch-action:manipulation; min-height:48px;}
  .btn.primary{background:#3b82f6; border-color:#2563eb;}
  .btn.toggle{max-width:160px;}
  .btn.small{padding:10px 12px; font-weight:700; min-height:40px; width:auto;}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:nowrap;}
  .stack{display:flex; flex-direction:column; gap:10px;}
  .input, .paste{width:100%; background:#0b1220; border:1px solid var(--border); color:#e5e7eb;
                 border-radius:14px; padding:14px; font-size:16px; box-sizing:border-box;}
  .paste{min-height:180px; resize:vertical; flex:1; overflow:auto;}
  .display{white-space:pre-wrap; background:#0b1220; border:1px solid var(--border);
           border-radius:14px; padding:12px; min-height:140px; flex:1; overflow:auto;}
  .slider{width:100%;}
  .switch{display:flex; align-items:center; gap:10px;}
  .switch input{width:44px; height:24px;}
  .radio-row{display:flex; flex-wrap:wrap; gap:10px; align-items:center;}
  .kv{display:grid; grid-template-columns:1fr 2fr; gap:10px; align-items:center;}
  .help{color:var(--muted); font-size:12px;}
  /* Status footer */
  .statusbar{position:sticky; bottom:0; left:0; right:0; width:100%;
             display:flex; justify-content:center; pointer-events:none; margin-top:8px;}
  .statusbar .inner{pointer-events:auto; width:100%; max-width:var(--maxw); margin:0 var(--pad);
                    background:#0b1220; border:1px solid var(--border); border-radius:12px;
                    padding:8px 12px; color:#9aa4b2; font-size:12px;}

  /* Modal for PTT confirm */
  .modal{position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; z-index:50;}
  .modal .box{width:min(520px,92vw); background:#0b1220; border:1px solid var(--border); border-radius:16px; padding:16px; display:flex; flex-direction:column; gap:10px;}
  .modal .row{justify-content:flex-end;}
  .badge{display:inline-block; border:1px solid var(--border); padding:2px 8px; border-radius:999px; font-size:12px; color:#cbd5e1;}

  /* Transcript header */
  .transcript-head{display:flex; justify-content:space-between; align-items:center; gap:10px;}
</style>
</head>
<body>
<div class="app">
  <!-- TOP TABS -->
  <div class="tabs-top">
    <div class="bar">
      <button id="tab-search" class="tabbtn active" type="button">search</button>
      <button id="tab-aloud" class="tabbtn" type="button">aloud</button>
      <button id="tab-link" class="tabbtn" type="button">link</button>
      <button id="tab-settings" class="tabbtn" type="button">settings</button>
    </div>
  </div>

  <!-- SEARCH -->
  <div id="search-screen" class="screen">
    <div class="card">
      <button id="ptt" class="btn primary" title="hold to talk" type="button">PTT</button>

      <!-- Enter submits on all mobile keyboards -->
      <form id="search-form" action="#" method="get" autocomplete="off" style="display:flex; flex-direction:column; gap:12px;">
        <input id="q" class="input" type="search" inputmode="search" enterkeyhint="search" aria-label="search query"
               placeholder="enter query and press Enter…">
        <div class="row">
          <button id="search-toggle" class="btn toggle" type="button">pause</button>
          <input id="search-rate" class="slider" type="range" min="0.5" max="3.0" step="0.1" value="1.2" aria-label="speech rate">
        </div>
      </form>

      <div id="search-display" class="display" aria-live="polite" aria-atomic="true"></div>
    </div>
  </div>

  <!-- ALOUD -->
  <div id="aloud-screen" class="screen" style="display:none;">
    <div class="card">
      <div class="row">
        <button id="aloud-toggle" class="btn toggle" type="button">pause</button>
        <input id="aloud-rate" class="slider" type="range" min="0.5" max="3.0" step="0.1" value="1.2" aria-label="speech rate">
        <button id="paste-btn" class="btn small" title="Paste from clipboard" type="button">Paste</button>
      </div>
      <textarea id="pastebox" class="paste" placeholder="paste text here…"></textarea>
    </div>
  </div>

  <!-- LINK TAB: URL -> transcript -> TTS with toggles -->
  <div id="link-screen" class="screen" style="display:none;">
    <div class="card">
      <div class="row">
        <label class="switch"><input id="tg-transcribe" type="checkbox" checked> transcribe</label>
        <label class="switch"><input id="tg-tts" type="checkbox" checked> read out loud</label>
        <button id="btn-paste-url" class="btn small" type="button">Paste URL</button>
      </div>
      <div class="row">
        <input id="url-input" class="input" type="url" placeholder="https://example.com/article…">
        <button id="btn-fetch-url" class="btn" type="button" style="max-width:160px;">Go</button>
      </div>
      <div class="stack" id="transcribe-block" style="display:flex;">
        <div class="transcript-head">
          <span class="badge">transcript</span>
          <button id="btn-copy-transcript" class="btn small" type="button">Copy</button>
        </div>
        <div id="transcript" class="display" aria-live="polite" aria-atomic="true"></div>
        <div class="help">If a site blocks cross-origin fetch, paste the text manually.</div>
      </div>
    </div>
  </div>

  <!-- SETTINGS -->
  <div id="settings-screen" class="screen" style="display:none;">
    <div class="card">
      <div class="radio-row" role="radiogroup" aria-label="active source">
        <label><input type="radio" name="source" value="ddg" checked> DuckDuckGo</label>
        <label><input type="radio" name="source" value="gemini"> Gemini</label>
        <label><input type="radio" name="source" value="perplexity"> Perplexity</label>
        <label><input type="radio" name="source" value="venice"> Venice</label>
      </div>
      <div class="kv">
        <label for="key-gemini">Gemini API key</label>
        <input id="key-gemini" class="input" type="password" placeholder="AIza...">
        <label for="key-perplexity">Perplexity API key</label>
        <input id="key-perplexity" class="input" type="password" placeholder="pplx-...">
        <label for="key-venice">Venice.ai API key</label>
        <input id="key-venice" class="input" type="password" placeholder="venice-...">
      </div>
      <div class="help">Keys are stored in your browser's localStorage only. The active source is used for voice queries and searches.</div>
      <div class="row">
        <button id="btn-save-keys" class="btn primary" type="button" style="max-width:180px;">Save</button>
        <button id="btn-clear-keys" class="btn" type="button" style="max-width:180px;">Clear</button>
      </div>
    </div>
  </div>

  <!-- Footer status -->
  <div class="statusbar"><div id="status" class="inner">ready</div></div>
</div>

<!-- PTT confirm modal -->
<div id="ptt-modal" class="modal" aria-modal="true" role="dialog">
  <div class="box">
    <div class="badge">listening</div>
    <div id="ptt-heard" class="display" style="min-height:80px;"></div>
    <div class="row">
      <button id="btn-ptt-cancel" class="btn" type="button" style="max-width:140px;">Cancel</button>
      <button id="btn-ptt-ok" class="btn primary" type="button" style="max-width:140px;">OK</button>
    </div>
  </div>
</div>

<script>
(function(){
  'use strict';
  const $ = s => document.querySelector(s);
  const $$ = s => Array.from(document.querySelectorAll(s));
  const statusEl=$('#status'); const setStatus=t=>statusEl.textContent=t;

  /* Tabs */
  const tabSearch=$('#tab-search'), tabAloud=$('#tab-aloud'), tabLink=$('#tab-link'), tabSettings=$('#tab-settings');
  const searchScreen=$('#search-screen'), aloudScreen=$('#aloud-screen'), linkScreen=$('#link-screen'), settingsScreen=$('#settings-screen');
  function showTab(name){
    const map={search:searchScreen, aloud:aloudScreen, link:linkScreen, settings:settingsScreen};
    $$('.tabbtn').forEach(b=>b.classList.remove('active'));
    $$('#search-screen, #aloud-screen, #link-screen, #settings-screen').forEach(el=>el.style.display='none');
    if(name==='search') tabSearch.classList.add('active');
    if(name==='aloud') tabAloud.classList.add('active');
    if(name==='link') tabLink.classList.add('active');
    if(name==='settings') tabSettings.classList.add('active');
    map[name].style.display='flex';
  }
  tabSearch.addEventListener('click', ()=>showTab('search'));
  tabAloud.addEventListener('click',  ()=>showTab('aloud'));
  tabLink.addEventListener('click',   ()=>showTab('link'));
  tabSettings.addEventListener('click',()=>showTab('settings'));

  /* -------- Robust Reader (state machine + chunking) ------- */
  // States: 'idle' | 'playing' | 'paused'
  class Reader {
    constructor(){
      this.state = 'idle';
      this.text  = '';
      this.rate  = 1.2;
      this.idx   = 0;            // absolute char index into text
      this._u    = null;         // current utterance
      this._interrupted = false; // cancel reason: pause, not end-of-chunk
      this._boundarySeen = false;
    }

    setRate(v){
      // Do not restart current chunk. Apply new rate to next chunk only.
      this.rate = v;
      // No cancellation. Keeps speaking, picks up new rate on next chunk.
      setStatus('rate '+v.toFixed(1));
    }

    setText(t){
      this.text = String(t || '');
      this.idx  = 0;
      if(!this.text) { this.stop(); return; }
      this.play();
    }

    play(){
      if(!this.text){ return; }
      if(this.state === 'playing'){ return; }
      this.state = 'playing';
      this._startChunk();
      syncUI();
    }

    pause(){
      if(this.state !== 'playing') return;
      this.state = 'paused';
      this._interrupted = true;
      try { speechSynthesis.cancel(); } catch(_) {}
      setStatus('paused');
      syncUI();
    }

    toggle(){
      if(this.state === 'playing'){ this.pause(); }
      else if(this.state === 'paused'){ this._interrupted = false; this.state='playing'; this._startChunk(); syncUI(); }
      else if(this.state === 'idle' && this.text){ this.play(); }
    }

    stop(){
      this.state = 'idle';
      this.text  = '';
      this.idx   = 0;
      this._interrupted = false;
      try { speechSynthesis.cancel(); } catch(_) {}
      setStatus('done');
      syncUI();
    }

    /* Speak next chunk from current idx.
       Chunk boundary = next sentence end OR ~280 chars, whichever comes first. */
    _startChunk(){
      if(this.state !== 'playing'){ return; }
      if(this.idx >= this.text.length){ this.stop(); return; }

      this._boundarySeen = false;
      const start = this.idx;
      const end   = this._findNextBreak(start);
      const chunk = this.text.slice(start, end);

      try { speechSynthesis.cancel(); } catch(_) {}

      const u = new SpeechSynthesisUtterance(chunk);
      u.rate  = this.rate;

      u.onstart = () => {
        this._u = u;
        setStatus('reading…');
        syncUI();
      };

      u.onboundary = (e) => {
        if(typeof e.charIndex === 'number'){
          this.idx = start + e.charIndex;
          this._boundarySeen = true;
        }
      };

      u.onend = () => {
        this._u = null;
        if(this._interrupted){
          this._interrupted = false;
          syncUI();
          return;
        }
        if(!this._boundarySeen){
          this.idx = end;
        }
        if(this.state === 'playing' && this.idx < this.text.length){
          this._startChunk();
        } else if (this.idx >= this.text.length){
          this.stop();
        } else {
          syncUI();
        }
      };

      u.onerror = () => {
        this._u = null;
        setStatus('tts error');
        if(this.state === 'playing'){
          this.idx = end;
          this._startChunk();
        }
      };

      speechSynthesis.speak(u);
    }

    _findNextBreak(from){
      const maxSpan = 280;
      const hardCap = Math.min(this.text.length, from + maxSpan);
      const slice = this.text.slice(from, hardCap);
      const m = /[\.!?…](?:\s|$)|\n{1,2}/g;
      let match, lastBreak = -1;
      while((match = m.exec(slice)) !== null){
        lastBreak = match.index + match[0].length;
      }
      if(lastBreak > 0) return from + lastBreak;
      return hardCap;
    }
  }

  const tts = new Reader();

  /* --- UI sync --- */
  function syncUI(){
    const label =
      (tts.state === 'paused') ? 'go' :
      (tts.state === 'playing') ? 'pause' : 'pause';
    $('#search-toggle').textContent = label;
    $('#aloud-toggle').textContent  = label;
  }
  setInterval(syncUI, 300);

  /* -------- SETTINGS: API keys + active source -------- */
  const keyGem=$('#key-gemini'), keyPplx=$('#key-perplexity'), keyVen=$('#key-venice');
  const btnSave=$('#btn-save-keys'), btnClear=$('#btn-clear-keys');
  function loadSettings(){
    try{
      keyGem.value = localStorage.getItem('key_gemini') || '';
      keyPplx.value = localStorage.getItem('key_perplexity') || '';
      keyVen.value = localStorage.getItem('key_venice') || '';
      const src = localStorage.getItem('active_source') || 'ddg';
      $$('input[name="source"]').forEach(r=>r.checked = (r.value===src));
    }catch(_){}
  }
  function saveSettings(){
    try{
      localStorage.setItem('key_gemini', keyGem.value.trim());
      localStorage.setItem('key_perplexity', keyPplx.value.trim());
      localStorage.setItem('key_venice', keyVen.value.trim());
      const src = ($$('input[name="source"]').find(r=>r.checked)||{value:'ddg'}).value;
      localStorage.setItem('active_source', src);
      setStatus('settings saved');
    }catch(_){ setStatus('cannot save settings'); }
  }
  btnSave.addEventListener('click', saveSettings);
  btnClear.addEventListener('click', ()=>{ try{
    ['key_gemini','key_perplexity','key_venice'].forEach(k=>localStorage.removeItem(k));
    keyGem.value=''; keyPplx.value=''; keyVen.value='';
    setStatus('keys cleared');
  }catch(_){ setStatus('cannot clear'); }});
  $$('input[name="source"]').forEach(r=>r.addEventListener('change', saveSettings));

  function activeSource(){ return localStorage.getItem('active_source') || 'ddg'; }
  function getKeys(){ return {
    gemini: localStorage.getItem('key_gemini') || '',
    perplexity: localStorage.getItem('key_perplexity') || '',
    venice: localStorage.getItem('key_venice') || ''
  };}

  /* -------- SEARCH wiring -------- */
  const form=$('#search-form'), q=$('#q'), sDisp=$('#search-display');
  const sToggle=$('#search-toggle'), sRate=$('#search-rate');

  form.addEventListener('submit', (e)=>{ e.preventDefault(); runQuery(q.value.trim()); });
  q.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); form.requestSubmit ? form.requestSubmit() : form.dispatchEvent(new Event('submit',{cancelable:true})); } });
  sToggle.addEventListener('click', ()=>tts.toggle());
  sRate.addEventListener('input', ()=>tts.setRate(parseFloat(sRate.value)));

  function renderResult(obj){
    const text = [obj.title?('** '+obj.title+' **\n'):'', obj.extract||'', obj._src?('\\n['+obj._src+(obj.url?(' | '+obj.url):'')+']'):(obj.url?('\\n'+obj.url):'')].join('').trim();
    sDisp.textContent = text || 'no result';
    if(text && obj.speak !== false){ tts.setText(text); } else { setStatus(''); }
  }

  async function runQuery(raw){
    const v=(raw||'').trim(); if(!v) return;
    const src=activeSource();
    const res = await fetchBySource(v, src);
    renderResult(res);
  }

  /* -------- ALOUD wiring -------- */
  const pasteArea=$('#pastebox'), pasteBtn=$('#paste-btn');
  const aToggle=$('#aloud-toggle'), aRate=$('#aloud-rate');

  aToggle.addEventListener('click', ()=>tts.toggle());
  aRate.addEventListener('input', ()=>tts.setRate(parseFloat(aRate.value)));

  function speakFromPaste(){
    const t=pasteArea.value.trim();
    if(t){ tts.setText(t); }
  }
  pasteArea.addEventListener('paste', ()=>{ setTimeout(speakFromPaste,0); });
  pasteBtn.addEventListener('click', async ()=>{
    try{
      if(navigator.clipboard && navigator.clipboard.readText){
        const t = await navigator.clipboard.readText();
        if(t){ pasteArea.value=t; tts.setText(t.trim()); }
      } else { setStatus('clipboard API not available'); }
    }catch(e){ setStatus('clipboard blocked'); }
  });

  /* -------- LINK TAB logic -------- */
  const tgTrans=$('#tg-transcribe'), tgTTS=$('#tg-tts');
  const btnPasteUrl=$('#btn-paste-url'), btnFetchUrl=$('#btn-fetch-url'), urlInput=$('#url-input');
  const transcriptBlock=$('#transcribe-block'), transcriptEl=$('#transcript'), btnCopyTrans=$('#btn-copy-transcript');

  function updateTranscriptBlock(){
    transcriptBlock.style.display = tgTrans.checked ? 'flex' : 'none';
  }
  tgTrans.addEventListener('change', updateTranscriptBlock);
  updateTranscriptBlock();

  btnPasteUrl.addEventListener('click', async ()=>{
    try{
      const t = await navigator.clipboard.readText();
      if(t){ urlInput.value = t.trim(); btnFetchUrl.click(); }
    }catch(_){ setStatus('clipboard blocked'); }
  });

  btnCopyTrans.addEventListener('click', async ()=>{
    try{
      await navigator.clipboard.writeText(transcriptEl.textContent || '');
      setStatus('transcript copied');
    }catch(_){ setStatus('copy blocked'); }
  });

  btnFetchUrl.addEventListener('click', async ()=>{
    const u = urlInput.value.trim();
    if(!u){ setStatus('enter URL'); return; }
    const {text, error} = await fetchAndExtract(u);
    if(error){ transcriptEl.textContent = 'fetch error: '+error; }
    else if(tgTrans.checked){ transcriptEl.textContent = text; }
    if(tgTTS.checked && text){ tts.setText(text); } else { setStatus('ready'); }
  });

  async function fetchAndExtract(u){
    try{
      const r = await fetch(u, {mode:'cors'});
      const raw = await r.text();
      const text = stripHTML(raw).trim();
      return {text};
    }catch(e){
      return {text:'', error:String(e.message||e)};
    }
  }
  function stripHTML(html){
    try{
      const doc = new DOMParser().parseFromString(html, 'text/html');
      // remove script/style
      doc.querySelectorAll('script,style,noscript').forEach(n=>n.remove());
      const main = doc.querySelector('main, article') || doc.body;
      return (main.textContent || '').replace(/\s+\n/g,'\n').replace(/\n{3,}/g,'\n\n');
    }catch(_){ return html; }
  }

  /* -------- Sources -------- */
  async function ddg(q){
    const u='https://api.duckduckgo.com/?q='+encodeURIComponent(q)+'&format=json&no_html=1&no_redirect=1';
    const r=await fetch(u,{mode:'cors'}); if(!r.ok) throw new Error('ddg '+r.status);
    return await r.json();
  }
  function pickDDG(j){
    if(j && j.AbstractText) return { title:j.Heading||'', extract:j.AbstractText, url:j.AbstractURL||'' };
    if(j && Array.isArray(j.RelatedTopics)){
      const rt=j.RelatedTopics.find(x=>x && x.Text);
      if(rt) return { title:j.Heading||'', extract:rt.Text, url:rt.FirstURL||'' };
    }
    return null;
  }
  async function openMeteo(place){
    const g='https://geocoding-api.open-meteo.com/v1/search?name='+encodeURIComponent(place)+'&count=1';
    const gr=await fetch(g); if(!gr.ok) throw new Error('geo '+gr.status);
    const gj=await gr.json(); if(!gj.results||!gj.results.length) return null;
    const {latitude,longitude,name,country_code}=gj.results[0];
    const wx='https://api.open-meteo.com/v1/forecast?latitude='+latitude+'&longitude='+longitude+'&current=temperature_2m,apparent_temperature,weather_code,wind_speed_10m&daily=temperature_2m_max,temperature_2m_min,precipitation_probability_max&timezone=auto';
    const wr=await fetch(wx); if(!wr.ok) throw new Error('meteo '+wr.status);
    const wj=await wr.json();
    const now=wj.current, d=wj.daily;
    const desc=`Weather for ${name}, ${country_code}. Current ${Math.round(now.temperature_2m)}°C, wind ${Math.round(now.wind_speed_10m)} km/h. Today max ${Math.round(d.temperature_2m_max[0])}°C, min ${Math.round(d.temperature_2m_min[0])}°C, precip prob ${d.precipitation_probability_max[0]}%.`;
    return { title:'Weather: '+name, extract:desc, url:'https://open-meteo.com/' };
  }
  function detectIntent(s){
    s = s.toLowerCase();
    if (/\bweather\b|\bforecast\b/.test(s) || /^weather in /.test(s)) return 'weather';
    return 'web';
  }

  async function queryGemini(query, key){
    const url = 'https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent?key='+encodeURIComponent(key);
    const body = { contents:[{ role:'user', parts:[{text: query}]}] };
    const r = await fetch(url, {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok) throw new Error('gemini '+r.status);
    const j = await r.json();
    const text = (j.candidates && j.candidates[0] && j.candidates[0].content && j.candidates[0].content.parts && j.candidates[0].content.parts[0].text) || '';
    return { title:'Gemini', extract:text, _src:'Gemini' };
  }

  async function queryPerplexity(query, key){
    const url = 'https://api.perplexity.ai/chat/completions';
    const body = { model:'sonar', messages:[{role:'user', content:query}] };
    const r = await fetch(url, {method:'POST', headers:{'Content-Type':'application/json', 'Authorization':'Bearer '+key}, body:JSON.stringify(body)});
    if(!r.ok) throw new Error('perplexity '+r.status);
    const j = await r.json();
    const text = (j.choices && j.choices[0] && j.choices[0].message && j.choices[0].message.content) || '';
    return { title:'Perplexity', extract:text, _src:'Perplexity' };
  }

  async function queryVenice(query, key){
    const url = 'https://api.venice.ai/api/v1/chat/completions';
    const body = { model:'gpt-3.5-turbo', messages:[{role:'user', content:query}] };
    const r = await fetch(url, {method:'POST', headers:{'Content-Type':'application/json', 'Authorization':'Bearer '+key}, body:JSON.stringify(body)});
    if(!r.ok) throw new Error('venice '+r.status);
    const j = await r.json();
    const text = (j.choices && j.choices[0] && j.choices[0].message && j.choices[0].message.content) || '';
    return { title:'Venice', extract:text, _src:'Venice' };
  }

  async function fetchBySource(query, src){
    const k = detectIntent(query);
    try{
      if(k==='weather'){
        const m=/weather in (.+)/i.exec(query);
        const place = m ? m[1] : query.replace(/^weather\b\s*/i,'').trim();
        if(place){ const w = await openMeteo(place); if(w) return {...w, _src:'Open-Meteo'}; }
      }
      if(src==='gemini'){
        const key = getKeys().gemini; if(!key) throw new Error('no gemini key');
        return await queryGemini(query, key);
      }else if(src==='perplexity'){
        const key = getKeys().perplexity; if(!key) throw new Error('no perplexity key');
        return await queryPerplexity(query, key);
      }else if(src==='venice'){
        const key = getKeys().venice; if(!key) throw new Error('no venice key');
        return await queryVenice(query, key);
      }else{
        // DuckDuckGo only. Wikipedia intentionally not used.
        const ddgJson = await ddg(query);
        const p = pickDDG(ddgJson);
        if(p) return {...p, _src:'DuckDuckGo'};
      }
    }catch(e){
      try{
        // Fallback to DDG
        const ddgJson = await ddg(query);
        const p = pickDDG(ddgJson);
        if(p) return {...p, _src:'DuckDuckGo'};
      }catch(_){}
    }
    return { title:'', extract:'no result', url:'', speak:false };
  }

  /* -------- PTT with confirm modal -------- */
  const ptt=$('#ptt');
  const modal=$('#ptt-modal'), heard=$('#ptt-heard');
  const btnCancel=$('#btn-ptt-cancel'), btnOK=$('#btn-ptt-ok');

  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  let rec=null, silence=null, holding=false, interim='';
  function ensureRec(){
    if(!SR) return null; if(rec) return rec;
    rec = new SR();
    rec.lang='en-US'; rec.continuous=false; rec.interimResults=true; rec.maxAlternatives=1;

    rec.onresult=(e)=>{
      let final=''; interim='';
      for(let i=e.resultIndex;i<e.results.length;i++){
        const r=e.results[i];
        if(r.isFinal) final+=r[0].transcript;
        else interim+=r[0].transcript;
      }
      heard.textContent = (final || interim || '').trim();
      if(final){ q.value = final.trim(); resetSilence(); }
    };
    rec.onend=()=>{ clearTimeout(silence); };
    rec.onerror=()=>{ setStatus('mic error'); hideModal(); };
    rec.onspeechstart=resetSilence; rec.onspeechend=stopASR;
    return rec;
  }
  function startASR(){
    const R=(window.isSecureContext && (window.SpeechRecognition||window.webkitSpeechRecognition));
    if(!R){ setStatus('microphone blocked (allow mic on this site)'); return; }
    heard.textContent=''; showModal();
    const r=ensureRec();
    try{ r.start(); setStatus('listening…'); }catch(_){}
    resetSilence();
  }
  function stopASR(){ clearTimeout(silence); if(rec){ try{ rec.stop(); }catch(_){ } } }
  function resetSilence(){ clearTimeout(silence); silence=setTimeout(()=>{ stopASR(); setStatus('idle'); },8000); }

  function showModal(){ modal.style.display='flex'; }
  function hideModal(){ modal.style.display='none'; }

  ptt.addEventListener('pointerdown', e=>{
    if(e.button!==0 && e.pointerType!=='touch' && e.pointerType!=='pen') return;
    holding=true; startASR();
  });
  ptt.addEventListener('pointerup',   ()=>{ holding=false; stopASR(); });
  ptt.addEventListener('pointerleave',()=>{ if(holding){ holding=false; stopASR(); } });

  btnCancel.addEventListener('click', ()=>{ hideModal(); });
  btnOK.addEventListener('click', async ()=>{
    hideModal();
    const v=q.value.trim() || heard.textContent.trim();
    if(v){ await runQuery(v); }
  });

  /* Init */
  document.addEventListener('DOMContentLoaded', ()=>{ loadSettings(); setStatus('ready'); syncUI(); updateTranscriptBlock(); });
})();
</script>
</body>
</html>
