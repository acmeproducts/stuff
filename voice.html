<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>voice reader — mobile v10</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#0f172a; --text:#e5e7eb; --muted:#9aa4b2; --border:#1f2937; --accent:#3b82f6;
    --radius:14px; --pad:14px; --maxw:440px;
  }
  html,body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;height:100%;}
  .app{min-height:100svh; display:flex; flex-direction:column; align-items:center;}

  /* Top tabs */
  .tabs-top{position:sticky; top:0; left:0; right:0; z-index:10;
            backdrop-filter:saturate(120%) blur(8px); background:rgba(15,23,42,.92);
            border-bottom:1px solid var(--border); width:100%; display:flex; justify-content:center;
            padding:calc(env(safe-area-inset-top) + 6px) var(--pad) 8px;}
  .tabs-top .bar{width:100%; max-width:var(--maxw); display:grid; grid-template-columns:1fr 1fr; gap:10px;}
  .tabbtn{appearance:none; border:1px solid var(--border); background:#0b1220; color:#e5e7eb;
          border-radius:12px; padding:10px; font-weight:700; min-height:44px;}
  .tabbtn.active{background:#3b82f6; border-color:#2563eb;}

  /* Screens */
  .screen{width:100%; max-width:var(--maxw); padding:12px var(--pad) var(--pad);
          box-sizing:border-box; flex:1; display:flex; flex-direction:column; gap:12px; min-height:0;}
  .card{background:var(--panel); border:1px solid var(--border); border-radius:var(--radius);
        padding:12px; display:flex; flex-direction:column; gap:12px; flex:1; min-height:0;}

  /* Controls */
  .btn{appearance:none; border:1px solid var(--border); background:#111827; color:#e5e7eb;
       border-radius:16px; padding:14px 18px; font-weight:800; font-size:16px;
       width:100%; touch-action:manipulation; min-height:48px;}
  .btn.primary{background:#3b82f6; border-color:#2563eb;}
  .btn.toggle{max-width:160px;}
  .btn.small{padding:10px 12px; font-weight:700; min-height:40px; width:auto;}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:nowrap;}
  .input, .paste{width:100%; background:#0b1220; border:1px solid var(--border); color:#e5e7eb;
                 border-radius:14px; padding:14px; font-size:16px; box-sizing:border-box;}
  .paste{min-height:180px; resize:vertical; flex:1; overflow:auto;}
  .display{white-space:pre-wrap; background:#0b1220; border:1px solid var(--border);
           border-radius:14px; padding:12px; min-height:140px; flex:1; overflow:auto;}
  .slider{width:100%;}
  /* Status footer */
  .statusbar{position:sticky; bottom:0; left:0; right:0; width:100%;
             display:flex; justify-content:center; pointer-events:none; margin-top:8px;}
  .statusbar .inner{pointer-events:auto; width:100%; max-width:var(--maxw); margin:0 var(--pad);
                    background:#0b1220; border:1px solid var(--border); border-radius:12px;
                    padding:8px 12px; color:#9aa4b2; font-size:12px;}
</style>
</head>
<body>
<div class="app">
  <!-- TOP TABS -->
  <div class="tabs-top">
    <div class="bar">
      <button id="tab-search" class="tabbtn active" type="button">search</button>
      <button id="tab-aloud" class="tabbtn" type="button">aloud</button>
    </div>
  </div>

  <!-- SEARCH -->
  <div id="search-screen" class="screen">
    <div class="card">
      <button id="ptt" class="btn primary" title="hold to talk" type="button">PTT</button>

      <!-- Enter submits on all mobile keyboards -->
      <form id="search-form" action="#" method="get" autocomplete="off" style="display:flex; flex-direction:column; gap:12px;">
        <input id="q" class="input" type="search" inputmode="search" enterkeyhint="search" aria-label="search query"
               placeholder="enter query and press Enter…">
        <div class="row">
          <button id="search-toggle" class="btn toggle" type="button">pause</button>
          <input id="search-rate" class="slider" type="range" min="0.5" max="3.0" step="0.1" value="1.2" aria-label="speech rate">
        </div>
      </form>

      <div id="search-display" class="display" aria-live="polite" aria-atomic="true"></div>
    </div>
  </div>

  <!-- ALOUD -->
  <div id="aloud-screen" class="screen" style="display:none;">
    <div class="card">
      <div class="row">
        <button id="aloud-toggle" class="btn toggle" type="button">pause</button>
        <input id="aloud-rate" class="slider" type="range" min="0.5" max="3.0" step="0.1" value="1.2" aria-label="speech rate">
        <button id="paste-btn" class="btn small" title="Paste from clipboard" type="button">Paste</button>
      </div>
      <textarea id="pastebox" class="paste" placeholder="paste text here…"></textarea>
    </div>
  </div>

  <!-- Footer status -->
  <div class="statusbar"><div id="status" class="inner">ready</div></div>
</div>

<script>
(function(){
  'use strict';
  const $ = s => document.querySelector(s);
  const statusEl=$('#status'); const setStatus=t=>statusEl.textContent=t;

  /* Tabs */
  const tabSearch=$('#tab-search'), tabAloud=$('#tab-aloud');
  const searchScreen=$('#search-screen'), aloudScreen=$('#aloud-screen');
  tabSearch.addEventListener('click', ()=>{ tabSearch.classList.add('active'); tabAloud.classList.remove('active'); searchScreen.style.display='flex'; aloudScreen.style.display='none'; });
  tabAloud.addEventListener('click',  ()=>{ tabAloud.classList.add('active'); tabSearch.classList.remove('active'); searchScreen.style.display='none'; aloudScreen.style.display='flex'; });

  /* -------- Robust Reader (state machine + chunking + boundary fallback) ------- */
  // States: 'idle' | 'playing' | 'paused'
  class Reader {
    constructor(){
      this.state = 'idle';
      this.text  = '';
      this.rate  = 1.2;
      this.idx   = 0;            // absolute char index into text
      this._u    = null;         // current utterance
      this._interrupted = false; // cancel reason: pause/speed change, not end-of-chunk
      this._boundarySeen = false;
    }

    setRate(v){
      this.rate = v;
      if(this.state === 'playing'){
        this._interrupted = true;
        speechSynthesis.cancel();   // stop current chunk
        // restart from current idx with new rate
        this._startChunk();
        this._interrupted = false;
      }
      // if paused/idle, just store the new rate; resume will use it
    }

    setText(t){
      this.text = String(t || '');
      this.idx  = 0;
      if(!this.text) { this.stop(); return; }
      this.play();
    }

    play(){
      if(!this.text){ return; }
      if(this.state === 'playing'){ return; }
      this.state = 'playing';
      this._startChunk();
      syncUI();
    }

    pause(){
      if(this.state !== 'playing') return;
      this.state = 'paused';
      this._interrupted = true;
      try { speechSynthesis.cancel(); } catch(_) {}
      setStatus('paused');
      syncUI();
    }

    toggle(){
      if(this.state === 'playing'){ this.pause(); }
      else if(this.state === 'paused'){ this.play(); }
      else if(this.state === 'idle' && this.text){ this.play(); }
    }

    stop(){
      this.state = 'idle';
      this.text  = '';
      this.idx   = 0;
      this._interrupted = false;
      try { speechSynthesis.cancel(); } catch(_) {}
      setStatus('done');
      syncUI();
    }

    /* Speak next chunk from current idx.
       Chunk boundary = next sentence end OR ~280 chars, whichever comes first. */
    _startChunk(){
      if(this.state !== 'playing'){ return; }
      if(this.idx >= this.text.length){ this.stop(); return; }

      this._boundarySeen = false;
      const start = this.idx;
      const end   = this._findNextBreak(start);
      const chunk = this.text.slice(start, end);

      try { speechSynthesis.cancel(); } catch(_) {}

      const u = new SpeechSynthesisUtterance(chunk);
      u.rate  = this.rate;

      u.onstart = () => {
        this._u = u;
        setStatus('reading…');
        syncUI();
      };

      u.onboundary = (e) => {
        // Chrome/Edge populate charIndex; Safari often doesn't.
        if(typeof e.charIndex === 'number'){
          this.idx = start + e.charIndex;
          this._boundarySeen = true;
        }
      };

      u.onend = () => {
        this._u = null;
        // If we intentionally interrupted (pause/speed change), don't auto-advance
        if(this._interrupted){
          this._interrupted = false;
          // If pause: remain paused; if speed change: state still 'playing' and _startChunk already called
          syncUI();
          return;
        }

        // Normal end of this chunk: advance index
        if(!this._boundarySeen){
          // Fallback: if no boundaries fired, jump to end of chunk
          this.idx = end;
        }

        if(this.state === 'playing' && this.idx < this.text.length){
          // Continue with next chunk
          this._startChunk();
        } else if (this.idx >= this.text.length){
          this.stop();
        } else {
          syncUI();
        }
      };

      u.onerror = () => {
        this._u = null;
        setStatus('tts error');
        // Try to continue to avoid getting stuck
        if(this.state === 'playing'){
          this.idx = end;
          this._startChunk();
        }
      };

      speechSynthesis.speak(u);
    }

    _findNextBreak(from){
      const maxSpan = 280;
      const hardCap = Math.min(this.text.length, from + maxSpan);
      // Look for sentence end chars between 'from' and 'hardCap'
      const slice = this.text.slice(from, hardCap);
      const m = /[\.!?…](?:\s|$)|\n{1,2}/g;
      let match, lastBreak = -1;
      while((match = m.exec(slice)) !== null){
        lastBreak = match.index + match[0].length;
      }
      if(lastBreak > 0) return from + lastBreak;
      return hardCap; // no sentence end found, cut at cap
    }
  }

  const tts = new Reader();

  /* --- UI sync --- */
  function syncUI(){
    const label =
      (tts.state === 'paused') ? 'go' :
      (tts.state === 'playing') ? 'pause' : 'pause';
    $('#search-toggle').textContent = label;
    $('#aloud-toggle').textContent  = label;
  }
  setInterval(syncUI, 300); // safety sync for engines that miss events

  /* -------- SEARCH wiring -------- */
  const form=$('#search-form'), q=$('#q'), sDisp=$('#search-display');
  const sToggle=$('#search-toggle'), sRate=$('#search-rate');

  form.addEventListener('submit', (e)=>{ e.preventDefault(); runQuery(q.value.trim()); });
  q.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); form.requestSubmit ? form.requestSubmit() : form.dispatchEvent(new Event('submit',{cancelable:true})); } });
  sToggle.addEventListener('click', ()=>tts.toggle());
  sRate.addEventListener('input', ()=>tts.setRate(parseFloat(sRate.value)));

  function renderResult(obj){
    const text = [obj.title?('** '+obj.title+' **\n'):'', obj.extract||'', obj._src?('\n['+obj._src+(obj.url?(' | '+obj.url):'')+']'):(obj.url?('\n'+obj.url):'')].join('').trim();
    sDisp.textContent = text || 'no result';
    if(text){ tts.setText(text); } else { setStatus(''); }
  }

  async function runQuery(raw){
    const v=(raw||'').trim(); if(!v) return;
    const res = await fetchAuto(v);
    renderResult(res);
  }

  /* -------- ALOUD wiring -------- */
  const pasteArea=$('#pastebox'), pasteBtn=$('#paste-btn');
  const aToggle=$('#aloud-toggle'), aRate=$('#aloud-rate');

  aToggle.addEventListener('click', ()=>tts.toggle());
  aRate.addEventListener('input', ()=>tts.setRate(parseFloat(aRate.value)));

  function speakFromPaste(){
    const t=pasteArea.value.trim();
    if(t){ tts.setText(t); }
  }
  pasteArea.addEventListener('paste', ()=>{ setTimeout(speakFromPaste,0); });
  pasteBtn.addEventListener('click', async ()=>{
    try{
      if(navigator.clipboard && navigator.clipboard.readText){
        const t = await navigator.clipboard.readText();
        if(t){ pasteArea.value=t; tts.setText(t.trim()); }
      } else { setStatus('clipboard API not available'); }
    }catch(e){ setStatus('clipboard blocked'); }
  });

  /* -------- Key-free sources (DDG/Wikipedia/Open-Meteo) -------- */
  async function ddg(q){
    const u='https://api.duckduckgo.com/?q='+encodeURIComponent(q)+'&format=json&no_html=1&no_redirect=1';
    const r=await fetch(u,{mode:'cors'}); if(!r.ok) throw new Error('ddg '+r.status);
    return await r.json();
  }
  function pickDDG(j){
    if(j && j.AbstractText) return { title:j.Heading||'', extract:j.AbstractText, url:j.AbstractURL||'' };
    if(j && Array.isArray(j.RelatedTopics)){
      const rt=j.RelatedTopics.find(x=>x && x.Text);
      if(rt) return { title:j.Heading||'', extract:rt.Text, url:rt.FirstURL||'' };
    }
    return null;
  }
  async function wikiSummary(q){
    const s='https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch='+encodeURIComponent(q)+'&format=json&origin=*';
    const sr=await fetch(s); if(!sr.ok) throw new Error('wiki search '+sr.status);
    const sj=await sr.json();
    const first=(sj.query&&sj.query.search&&sj.query.search[0])?sj.query.search[0]:null;
    if(!first) return null;
    const title=first.title;
    const u='https://en.wikipedia.org/api/rest_v1/page/summary/'+encodeURIComponent(title);
    const ur=await fetch(u,{headers:{'Accept':'application/json'}}); if(!ur.ok) throw new Error('wiki sum '+ur.status);
    const j=await ur.json();
    return { title:j.title||title, extract:j.extract||'', url:(j.content_urls&&j.content_urls.desktop)?j.content_urls.desktop.page:('https://en.wikipedia.org/wiki/'+encodeURIComponent(title)) };
  }
  async function openMeteo(place){
    const g='https://geocoding-api.open-meteo.com/v1/search?name='+encodeURIComponent(place)+'&count=1';
    const gr=await fetch(g); if(!gr.ok) throw new Error('geo '+gr.status);
    const gj=await gr.json(); if(!gj.results||!gj.results.length) return null;
    const {latitude,longitude,name,country_code}=gj.results[0];
    const wx='https://api.open-meteo.com/v1/forecast?latitude='+latitude+'&longitude='+longitude+'&current=temperature_2m,apparent_temperature,weather_code,wind_speed_10m&daily=temperature_2m_max,temperature_2m_min,precipitation_probability_max&timezone=auto';
    const wr=await fetch(wx); if(!wr.ok) throw new Error('meteo '+wr.status);
    const wj=await wr.json();
    const now=wj.current, d=wj.daily;
    const desc=`Weather for ${name}, ${country_code}. Current ${Math.round(now.temperature_2m)}°C, wind ${Math.round(now.wind_speed_10m)} km/h. Today max ${Math.round(d.temperature_2m_max[0])}°C, min ${Math.round(d.temperature_2m_min[0])}°C, precip prob ${d.precipitation_probability_max[0]}%.`;
    return { title:'Weather: '+name, extract:desc, url:'https://open-meteo.com/' };
  }
  function detectIntent(s){
    s = s.toLowerCase();
    if (/\bweather\b|\bforecast\b/.test(s) || /^weather in /.test(s)) return 'weather';
    if (/\bnews\b|\bheadline(s)?\b/.test(s)) return 'news';
    return 'web';
  }
  async function fetchAuto(query){
    const k = detectIntent(query);
    try{
      if(k==='weather'){
        const m=/weather in (.+)/i.exec(query);
        const place = m ? m[1] : query.replace(/^weather\b\s*/i,'').trim();
        if(place){ const w = await openMeteo(place); if(w) return {...w, _src:'Open-Meteo'}; }
      }
      const ddgJson = await ddg(query);
      const p = pickDDG(ddgJson);
      if(p) return {...p, _src:'DuckDuckGo'};
      const wk = await wikiSummary(query);
      if(wk) return {...wk, _src:'Wikipedia'};
    }catch(e){
      try{ const wk = await wikiSummary(query); if(wk) return {...wk, _src:'Wikipedia'}; }catch(_){}
    }
    return { title:'', extract:'no result', url:'' };
  }

  /* -------- PTT -------- */
  const ptt=$('#ptt');
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  let rec=null, silence=null, holding=false;
  function ensureRec(){
    if(!SR) return null; if(rec) return rec;
    rec = new SR();
    rec.lang='en-US'; rec.continuous=false; rec.interimResults=true; rec.maxAlternatives=1;
    rec.onresult=(e)=>{ let final=''; for(let i=e.resultIndex;i<e.results.length;i++){ const r=e.results[i]; if(r.isFinal) final+=r[0].transcript; }
      if(final){ q.value = final.trim(); } resetSilence(); };
    rec.onend=()=>{ const v=q.value.trim(); if(v){ (async()=>{ const res=await fetchAuto(v); renderResult(res); })(); } };
    rec.onerror=()=>{ setStatus('mic error'); };
    rec.onspeechstart=resetSilence; rec.onspeechend=stopASR;
    return rec;
  }
  function startASR(){
    const R=(window.isSecureContext && (window.SpeechRecognition||window.webkitSpeechRecognition));
    if(!R){ setStatus('microphone blocked (allow mic on this site)'); return; }
    const r=ensureRec();
    try{ r.start(); setStatus('listening…'); }catch(_){}
    resetSilence();
  }
  function stopASR(){ clearTimeout(silence); if(rec){ try{ rec.stop(); }catch(_){ } } }
  function resetSilence(){ clearTimeout(silence); silence=setTimeout(()=>{ stopASR(); setStatus('idle'); },8000); }
  ptt.addEventListener('pointerdown', e=>{ if(e.button!==0 && e.pointerType!=='touch' && e.pointerType!=='pen') return; holding=true; startASR(); });
  ptt.addEventListener('pointerup',   ()=>{ holding=false; stopASR(); });
  ptt.addEventListener('pointerleave',()=>{ if(holding){ holding=false; stopASR(); } });

  /* Init */
  document.addEventListener('DOMContentLoaded', ()=>{ setStatus('ready'); syncUI(); });
})();
</script>
</body>
</html>
