<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BlockBuilder Infinite</title>
    <style>
        :root {
            --bg-color: #f0f4f8;
            --panel-bg: #ffffff;
            --text-color: #333;
            --accent: #6366f1;
            --accent-hover: #4f46e5;
            --border: #e2e8f0;
            --danger: #ef4444;
        }
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-color);
            touch-action: none;
        }
        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        /* Header / Toolbar */
        header {
            background: var(--panel-bg);
            padding: 8px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);
            z-index: 20;
            flex-wrap: nowrap;
            overflow-x: auto;
            gap: 10px;
            height: 60px;
        }

        .tools-left, .tools-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Buttons & Inputs */
        button, .icon-btn {
            height: 40px;
            min-width: 40px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--panel-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.1s;
            color: #475569;
            padding: 0 10px;
            font-weight: 600;
            font-size: 0.9rem;
        }
        button:active { transform: translateY(1px); background: #f8fafc; }
        
        button.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        button.active.delete-mode {
            background: var(--danger);
            border-color: var(--danger);
        }

        .divider { width: 1px; height: 24px; background: var(--border); margin: 0 4px; }

        /* Color Picker */
        .color-wrap {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
            position: relative;
        }
        input[type="color"] {
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            border: none; cursor: pointer;
        }

        /* Canvas */
        .viewport {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #f1f5f9 0%, #cbd5e1 100%);
            overflow: hidden;
            cursor: crosshair;
        }
        
        .hud {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            pointer-events: none;
            backdrop-filter: blur(4px);
            opacity: 0;
            transition: opacity 0.3s;
        }
        .hud.visible { opacity: 1; }

        /* Icon SVG Styling */
        svg { width: 20px; height: 20px; pointer-events: none; }
    </style>
</head>
<body>

<div id="app">
    <header>
        <div class="tools-left">
            <div class="color-wrap" title="Color">
                <input type="color" id="colorPicker" value="#6366f1">
            </div>
            
            <div class="divider"></div>

            <button class="shape-btn active" onclick="builder.setShape('cube')" title="Cube">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M21 16.5l-9 5-9-5V7.5l9-5 9 5v9z"/></svg>
            </button>
            <button class="shape-btn" onclick="builder.setShape('slab')" title="Slab">
                <svg viewBox="0 0 24 24" fill="currentColor"><rect x="2" y="12" width="20" height="8" rx="2"/></svg>
            </button>
            <button class="shape-btn" onclick="builder.setShape('slope')" title="Slope">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 20h18L3 4v16z"/></svg>
            </button>
            <button class="shape-btn" onclick="builder.setShape('pyramid')" title="Pyramid">
                 <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 22h20L12 2z"/></svg>
            </button>

            <div class="divider"></div>

            <button id="btnDelete" onclick="builder.toggleDelete()" title="Delete Mode">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                </svg>
            </button>
        </div>

        <div class="tools-right">
            <button onclick="builder.clear()">Clear</button>
            <button onclick="builder.saveIO()">Save/Export</button>
            <input type="file" id="fileIn" hidden onchange="builder.importFile(this)">
            <button onclick="document.getElementById('fileIn').click()">Import</button>
        </div>
    </header>

    <div class="viewport" id="container">
        <canvas id="canvas"></canvas>
        <div id="hud" class="hud">Action</div>
    </div>
</div>

<script>
class VoxelEngine {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.container = document.getElementById('container');
        
        // --- Configuration ---
        this.tileW = 64;  // Width of tile
        this.tileH = 32;  // Height of top face (Iso projection)
        this.blockH = 32; // Extrusion height
        
        // --- State ---
        // Blocks stored as key "x,y,z" -> { type, color, shape }
        this.blocks = {};
        
        // Camera
        this.camX = 0;
        this.camY = 0;
        this.zoom = 1.0;
        
        // Interaction
        this.currentShape = 'cube';
        this.isDeleteMode = false;
        
        this.isDragging = false;
        this.lastMouse = {x:0, y:0};
        this.touchStart = 0;
        
        // Init
        this.resize();
        this.load();
        
        // Events
        window.addEventListener('resize', () => this.resize());
        
        // Mouse
        this.canvas.addEventListener('mousedown', e => this.onDown(e));
        window.addEventListener('mousemove', e => this.onMove(e));
        window.addEventListener('mouseup', e => this.onUp(e));
        this.canvas.addEventListener('wheel', e => this.onWheel(e), {passive: false});
        
        // Touch
        this.canvas.addEventListener('touchstart', e => this.onTouchStart(e), {passive:false});
        this.canvas.addEventListener('touchmove', e => this.onTouchMove(e), {passive:false});
        this.canvas.addEventListener('touchend', e => this.onTouchEnd(e), {passive:false});

        // Loop
        requestAnimationFrame(() => this.loop());
    }

    resize() {
        this.canvas.width = this.container.clientWidth;
        this.canvas.height = this.container.clientHeight;
        if(this.camX === 0 && this.camY === 0) {
            this.camX = this.canvas.width/2;
            this.camY = this.canvas.height/2;
        }
        this.draw();
    }

    loop() {
        this.draw();
        requestAnimationFrame(() => this.loop());
    }

    // --- Core Isometric Math ---
    
    // Grid (x,y,z) -> Screen (x,y)
    toScreen(x, y, z) {
        // Isometric projection formulas
        // Screen X = (GridX - GridY) * (Width / 2)
        // Screen Y = (GridX + GridY) * (Height / 2) - (GridZ * BlockHeight)
        const sx = (x - y) * this.tileW * 0.5;
        const sy = (x + y) * this.tileH * 0.5 - (z * this.blockH);
        return {
            x: sx * this.zoom + this.camX,
            y: sy * this.zoom + this.camY
        };
    }

    // Screen (x,y) -> Grid (x,y) at Z=0 plane
    toGrid(sx, sy) {
        const adjX = (sx - this.camX) / this.zoom;
        const adjY = (sy - this.camY) / this.zoom;
        
        // Inverse Iso Matrix
        // y = (2*adjY - adjX * (H/W fraction? No, standard iso inverse))
        // Let's derive from toScreen:
        // sx = (x-y)*W/2  =>  2*sx/W = x - y
        // sy = (x+y)*H/2  =>  2*sy/H = x + y
        // Add: 2*sx/W + 2*sy/H = 2x  => x = sx/W + sy/H
        // Sub: 2*sy/H - 2*sx/W = 2y  => y = sy/H - sx/W
        
        const isoX = (adjX / this.tileW) + (adjY / this.tileH);
        const isoY = (adjY / this.tileH) - (adjX / this.tileW);
        
        return {
            x: Math.floor(isoX),
            y: Math.floor(isoY),
            fx: isoX, // floating point exact
            fy: isoY
        };
    }

    // --- Rendering ---

    draw() {
        const ctx = this.ctx;
        const W = this.canvas.width;
        const H = this.canvas.height;
        
        // Background
        ctx.fillStyle = '#f0f4f8'; // Skyish
        ctx.fillRect(0,0,W,H);
        
        // 1. Draw Infinite Dynamic Grid
        // We calculate the visible range of tiles based on viewport to save performance
        // (Simplified: Draw a large enough grid centered on view)
        this.drawGrid(ctx);

        // 2. Sort Blocks (Painter's Algo)
        // Depth = x + y. If tie, z.
        const list = Object.keys(this.blocks).map(k => {
            const p = k.split(',').map(Number);
            return {
                x:p[0], y:p[1], z:p[2], 
                data: this.blocks[k]
            };
        });

        list.sort((a,b) => {
            const d1 = a.x + a.y;
            const d2 = b.x + b.y;
            if(d1 !== d2) return d1 - d2;
            return a.z - b.z;
        });

        // 3. Draw Blocks
        list.forEach(b => {
            this.drawShape(ctx, b.x, b.y, b.z, b.data);
        });
    }

    drawGrid(ctx) {
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#cbd5e1';
        
        // Optimization: Calculate roughly which tiles are on screen
        // Center tile
        const center = this.toGrid(this.canvas.width/2, this.canvas.height/2);
        const range = Math.ceil(Math.max(this.canvas.width, this.canvas.height) / (this.tileW*this.zoom)) + 2;
        
        const startX = center.x - range;
        const endX = center.x + range;
        const startY = center.y - range;
        const endY = center.y + range;

        ctx.beginPath();
        // Draw grid lines in iso perspective
        for(let x=startX; x<=endX; x++) {
            const p1 = this.toScreen(x, startY, 0);
            const p2 = this.toScreen(x, endY, 0);
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
        }
        for(let y=startY; y<=endY; y++) {
            const p1 = this.toScreen(startX, y, 0);
            const p2 = this.toScreen(endX, y, 0);
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
        }
        ctx.stroke();
    }

    drawShape(ctx, x, y, z, data) {
        const { color, type } = data;
        const p = this.toScreen(x, y, z);
        const w = this.tileW * this.zoom;
        const h = this.tileH * this.zoom; // Top face height
        const bh = this.blockH * this.zoom; // Extrusion
        
        // Colors
        const base = color;
        const left = this.shade(color, -20);
        const right = this.shade(color, -40);

        const cx = p.x;
        const cy = p.y; // Bottom-center of the "sprite" logic (conceptually)

        ctx.lineWidth = 0.5;
        ctx.strokeStyle = 'rgba(0,0,0,0.1)';

        switch(type) {
            case 'cube':
                this.drawPrism(ctx, cx, cy, w, h, bh, base, left, right);
                break;
            case 'slab':
                this.drawPrism(ctx, cx, cy, w, h, bh*0.5, base, left, right);
                break;
            case 'slope':
                // Triangle Slope (Ramp up North)
                this.drawSlope(ctx, cx, cy, w, h, bh, base, left, right);
                break;
            case 'pyramid':
                this.drawPyramid(ctx, cx, cy, w, h, bh, base, left, right);
                break;
            default: // fallback
                this.drawPrism(ctx, cx, cy, w, h, bh, base, left, right);
        }
    }

    // Geometry Helpers

    drawPrism(ctx, cx, cy, w, h, bh, cTop, cLeft, cRight) {
        // Top Face
        ctx.beginPath();
        ctx.moveTo(cx, cy - bh); // Center
        ctx.lineTo(cx + w/2, cy - bh - h/2);
        ctx.lineTo(cx, cy - bh - h);
        ctx.lineTo(cx - w/2, cy - bh - h/2);
        ctx.closePath();
        ctx.fillStyle = cTop; ctx.fill(); ctx.stroke();

        // Right Face
        ctx.beginPath();
        ctx.moveTo(cx, cy - bh);
        ctx.lineTo(cx + w/2, cy - bh - h/2);
        ctx.lineTo(cx + w/2, cy - h/2);
        ctx.lineTo(cx, cy);
        ctx.closePath();
        ctx.fillStyle = cRight; ctx.fill(); ctx.stroke();

        // Left Face
        ctx.beginPath();
        ctx.moveTo(cx, cy - bh);
        ctx.lineTo(cx - w/2, cy - bh - h/2);
        ctx.lineTo(cx - w/2, cy - h/2);
        ctx.lineTo(cx, cy);
        ctx.closePath();
        ctx.fillStyle = cLeft; ctx.fill(); ctx.stroke();
    }
    
    drawPyramid(ctx, cx, cy, w, h, bh, cTop, cLeft, cRight) {
        // Peak is at cx, cy - bh - h/2
        const peakY = cy - bh - h/2;
        
        // Right Face Triangle
        ctx.beginPath();
        ctx.moveTo(cx, peakY);
        ctx.lineTo(cx + w/2, cy - h/2);
        ctx.lineTo(cx, cy); // Base center
        ctx.closePath();
        ctx.fillStyle = cRight; ctx.fill(); ctx.stroke();
        
        // Left Face Triangle
        ctx.beginPath();
        ctx.moveTo(cx, peakY);
        ctx.lineTo(cx - w/2, cy - h/2);
        ctx.lineTo(cx, cy);
        ctx.closePath();
        ctx.fillStyle = cLeft; ctx.fill(); ctx.stroke();
    }

    drawSlope(ctx, cx, cy, w, h, bh, cTop, cLeft, cRight) {
        // Ramp going UP towards North (Back)
        // Base is normal square
        // Top edge is the back line
        
        // Right Side (Triangle)
        ctx.beginPath();
        ctx.moveTo(cx, cy); // Bottom center
        ctx.lineTo(cx + w/2, cy - h/2); // Right corner low
        ctx.lineTo(cx, cy - bh - h); // Top back center
        ctx.closePath();
        ctx.fillStyle = cRight; ctx.fill(); ctx.stroke();
        
        // Left Side (Triangle)
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx - w/2, cy - h/2);
        ctx.lineTo(cx, cy - bh - h);
        ctx.closePath();
        ctx.fillStyle = cLeft; ctx.fill(); ctx.stroke();

        // Ramp Face
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + w/2, cy - h/2);
        ctx.lineTo(cx, cy - bh - h);
        ctx.lineTo(cx - w/2, cy - h/2);
        ctx.closePath();
        ctx.fillStyle = cTop; ctx.fill(); ctx.stroke();
    }

    shade(hex, percent) {
        let R = parseInt(hex.substring(1,3),16);
        let G = parseInt(hex.substring(3,5),16);
        let B = parseInt(hex.substring(5,7),16);

        R = parseInt(R * (100 + percent) / 100);
        G = parseInt(G * (100 + percent) / 100);
        B = parseInt(B * (100 + percent) / 100);

        R = (R<255)?R:255; G = (G<255)?G:255; B = (B<255)?B:255;
        
        const RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
        const GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
        const BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));

        return "#"+RR+GG+BB;
    }

    // --- Input Handling ---

    handleTap(mx, my) {
        // 1. Raycast for existing blocks (Hit Test)
        // Sort blocks by draw order (reverse for hit testing usually, but simpler: check dist to center)
        // Because shapes vary, simple bounding box is tricky. 
        // We will project mouse to grid at various heights.
        
        let hit = null;
        let minDist = Infinity;

        // Iterate all blocks to find clicked one (inefficient for massive worlds, but fine for local)
        // Better: sort reverse Z
        for(let key in this.blocks) {
            const [x,y,z] = key.split(',').map(Number);
            const scr = this.toScreen(x,y,z);
            // Height adjust based on shape?
            // Simple hit: Check if inside the rhombus of the top face
            // This is "good enough" for tile interactions
            
            // Adjust hit zone for height
            const hOffset = this.blockH * this.zoom * (this.blocks[key].type === 'slab' ? 0.5 : 1);
            const cy = scr.y - hOffset; 
            const cx = scr.x;
            
            if(this.pointInRhombus(mx, my, cx, cy)) {
                // We have a hit candidate. Highest Z wins usually?
                // Actually we just want the "closest" to camera usually means highest Z + X + Y logic
                // Let's use Z-index sort
                const score = (x+y)*1000 + z; 
                if(minDist === Infinity || score > hit.score) {
                    hit = { x,y,z, score };
                }
            }
        }

        if(this.isDeleteMode) {
            if(hit) {
                delete this.blocks[`${hit.x},${hit.y},${hit.z}`];
                this.toast("Deleted");
            }
        } else {
            // Build Mode
            const color = document.getElementById('colorPicker').value;
            
            if(hit) {
                // Stack on top
                // Check shape height? Standard: always stack at next integer Z
                // If hitting a slab, maybe stack at z+0.5? Keeping it integer based for simplicity
                const newZ = hit.z + 1;
                this.blocks[`${hit.x},${hit.y},${newZ}`] = { type: this.currentShape, color };
            } else {
                // Hit Ground?
                const g = this.toGrid(mx, my);
                // Verify z=0 stack
                let z = 0;
                while(this.blocks[`${g.x},${g.y},${z}`]) z++;
                this.blocks[`${g.x},${g.y},${z}`] = { type: this.currentShape, color };
            }
        }
        this.save();
    }

    pointInRhombus(px, py, cx, cy) {
        const w = this.tileW * this.zoom / 2;
        const h = this.tileH * this.zoom / 2;
        const dx = Math.abs(px - cx);
        const dy = Math.abs(py - cy);
        return (dx/w + dy/h) <= 1;
    }

    // --- Inputs ---
    
    onDown(e) {
        this.isDragging = false;
        this.lastMouse = {x: e.clientX, y: e.clientY};
        this.clickTime = Date.now();
    }
    onMove(e) {
        if(e.buttons) {
            const dx = e.clientX - this.lastMouse.x;
            const dy = e.clientY - this.lastMouse.y;
            if(Math.abs(dx)>2 || Math.abs(dy)>2) {
                this.isDragging = true;
                this.camX += dx;
                this.camY += dy;
                this.lastMouse = {x: e.clientX, y: e.clientY};
            }
        }
    }
    onUp(e) {
        if(!this.isDragging && Date.now() - this.clickTime < 300) {
            const rect = this.canvas.getBoundingClientRect();
            this.handleTap(e.clientX - rect.left, e.clientY - rect.top);
        }
    }
    onWheel(e) {
        e.preventDefault();
        const d = -Math.sign(e.deltaY) * 0.1;
        this.zoom = Math.max(0.5, Math.min(3, this.zoom + d));
    }

    // Touch logic
    onTouchStart(e) {
        e.preventDefault();
        if(e.touches.length === 1) {
            this.isDragging = false;
            this.touchStart = Date.now();
            this.lastMouse = {x: e.touches[0].clientX, y: e.touches[0].clientY};
        }
    }
    onTouchMove(e) {
        e.preventDefault();
        if(e.touches.length === 1) {
             const dx = e.touches[0].clientX - this.lastMouse.x;
             const dy = e.touches[0].clientY - this.lastMouse.y;
             if(Math.abs(dx)>2 || Math.abs(dy)>2) {
                 this.isDragging = true;
                 this.camX += dx;
                 this.camY += dy;
                 this.lastMouse = {x: e.touches[0].clientX, y: e.touches[0].clientY};
             }
        }
    }
    onTouchEnd(e) {
        e.preventDefault();
        if(!this.isDragging && Date.now() - this.touchStart < 400 && e.changedTouches.length > 0) {
            const t = e.changedTouches[0];
            const rect = this.canvas.getBoundingClientRect();
            this.handleTap(t.clientX - rect.left, t.clientY - rect.top);
        }
    }

    // --- UI & IO ---

    setShape(s) {
        this.currentShape = s;
        this.isDeleteMode = false;
        document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
        document.querySelector(`button[onclick="builder.setShape('${s}')"]`).classList.add('active');
        document.getElementById('btnDelete').classList.remove('active');
        this.toast("Shape: " + s);
    }
    
    toggleDelete() {
        this.isDeleteMode = !this.isDeleteMode;
        document.getElementById('btnDelete').classList.toggle('active', this.isDeleteMode);
        document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
        if(this.isDeleteMode) this.toast("Delete Mode");
        else {
            this.setShape(this.currentShape);
        }
    }

    toast(msg) {
        const h = document.getElementById('hud');
        h.innerText = msg;
        h.classList.add('visible');
        setTimeout(() => h.classList.remove('visible'), 1000);
    }

    save() {
        localStorage.setItem('blockWorldInf', JSON.stringify(this.blocks));
    }
    load() {
        const d = localStorage.getItem('blockWorldInf');
        if(d) this.blocks = JSON.parse(d);
    }
    clear() {
        if(confirm("Clear World?")) {
            this.blocks = {};
            this.save();
        }
    }
    saveIO() {
        const str = JSON.stringify(this.blocks);
        const blob = new Blob([str], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "world.json";
        a.click();
    }
    importFile(input) {
        const f = input.files[0];
        if(!f) return;
        const r = new FileReader();
        r.onload = e => {
            this.blocks = JSON.parse(e.target.result);
            this.save();
        };
        r.readAsText(f);
    }
}

const builder = new VoxelEngine();
</script>
</body>
</html>