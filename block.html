<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BlockBuilder Stable</title>
    <style>
        :root {
            --bg: #f1f5f9;
            --panel: rgba(255, 255, 255, 0.95);
            --border: #cbd5e1;
            --primary: #3b82f6;
            --text: #1e293b;
            --danger: #ef4444;
        }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: -apple-system, BlinkMacSystemFont, sans-serif; touch-action: none; user-select: none; }
        #app { display: flex; flex-direction: column; height: 100vh; }
        
        /* Toolbar */
        header {
            padding: 0 12px; background: var(--panel); border-bottom: 1px solid var(--border);
            display: flex; gap: 12px; align-items: center; height: 64px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05); z-index: 10;
        }
        
        /* Icons & Buttons */
        .group { display: flex; background: #e2e8f0; padding: 4px; border-radius: 10px; gap: 4px; }
        
        button {
            width: 44px; height: 44px; border: none; background: transparent; border-radius: 8px;
            cursor: pointer; color: #64748b; flex-shrink: 0; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        button.active { background: white; color: var(--primary); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        button:active { transform: scale(0.95); }
        button svg { width: 24px; height: 24px; fill: currentColor; }

        .color-pick {
            width: 44px; height: 44px; border-radius: 10px; overflow: hidden; position: relative;
            border: 2px solid white; box-shadow: 0 0 0 1px var(--border);
        }
        
        /* Viewport */
        #viewport { flex: 1; position: relative; background: radial-gradient(circle at center, #f8fafc, #cbd5e1); cursor: crosshair; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }

        /* HUD & Toast */
        .toast {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.9); color: white; padding: 8px 16px;
            border-radius: 20px; font-size: 0.9rem; font-weight: 500;
            opacity: 0; pointer-events: none; transition: opacity 0.2s, transform 0.2s;
        }
        .toast.show { opacity: 1; transform: translateX(-50%) translateY(5px); }
        
        /* Edit Menu */
        #menu {
            position: absolute; bottom: 0; left: 0; width: 100%; background: white;
            padding: 24px; border-radius: 24px 24px 0 0; transform: translateY(110%);
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            box-shadow: 0 -10px 30px rgba(0,0,0,0.1); box-sizing: border-box;
            display: flex; flex-direction: column; gap: 16px; z-index: 20;
        }
        #menu.open { transform: translateY(0); }
        .row { display: flex; gap: 10px; align-items: center; justify-content: space-between; }
        .menu-title { font-weight: 700; font-size: 1.1rem; color: var(--text); }
        .btn-full { flex: 1; padding: 12px; background: #f1f5f9; border: 1px solid var(--border); border-radius: 8px; font-weight: 600; color: var(--text); }
        .btn-danger { background: #fef2f2; color: var(--danger); border-color: #fecaca; }

    </style>
</head>
<body>

<div id="app">
    <header>
        <div class="color-pick" id="colorPreview" style="background:#3b82f6">
            <input type="color" id="colorIn" value="#3b82f6" oninput="app.setColor(this.value)" style="position:absolute; top:-10px; left:-10px; width:60px; height:60px; opacity:0; cursor:pointer;">
        </div>
        
        <div class="group">
            <button class="active shape-btn" onclick="app.setShape('cube')" title="Cube">
                <svg viewBox="0 0 24 24"><path d="M12 3.5l8 4.5v9L12 21.5l-8-4.5v-9L12 3.5z"/></svg>
            </button>
            <button class="shape-btn" onclick="app.setShape('slab')" title="Slab">
                <svg viewBox="0 0 24 24"><path d="M12 14l8 3.5v3l-8 3.5-8-3.5v-3L12 14z"/></svg>
            </button>
            <button class="shape-btn" onclick="app.setShape('pillar')" title="Pillar">
                <svg viewBox="0 0 24 24"><rect x="10" y="4" width="4" height="16" rx="0.5"/></svg>
            </button>
            <button class="shape-btn" onclick="app.setShape('beam')" title="Beam">
                <svg viewBox="0 0 24 24"><rect x="4" y="10" width="16" height="4" rx="0.5"/></svg>
            </button>
        </div>

        <div style="flex:1"></div>

        <div class="group">
            <button onclick="app.saveIO()" title="Save">
                <svg viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/></svg>
            </button>
            <button onclick="document.getElementById('fileIn').click()" title="Import">
                <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
            </button>
            <input type="file" id="fileIn" hidden onchange="app.importFile(this)">
        </div>
    </header>

    <div id="viewport">
        <canvas id="canvas"></canvas>
        <div id="toast" class="toast">Action</div>
    </div>

    <div id="menu">
        <div class="row">
            <span class="menu-title">Edit Block</span>
            <button onclick="app.closeMenu()" style="width:32px; height:32px; background:#f1f5f9;">âœ•</button>
        </div>
        <div class="row">
            <button class="btn-full" onclick="app.setTexture('none')">Smooth</button>
            <button class="btn-full" onclick="app.setTexture('lines')">Lines</button>
            <button class="btn-full" onclick="app.setTexture('grid')">Grid</button>
        </div>
        <button class="btn-full btn-danger" onclick="app.deleteBlock()">Delete Block</button>
    </div>
</div>

<script>
class Engine {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.tileW = 64; 
        this.tileH = 32;
        this.blockH = 40;
        
        this.blocks = {}; // "x,y,z" -> { type, color, sub, texture }
        this.cam = { x: 0, y: 0, zoom: 1 };
        this.tool = { shape: 'cube', color: '#3b82f6' };
        this.selection = null;
        
        this.cursor = null; // {x, y, z, sub}

        this.resize();
        this.load();
        
        window.addEventListener('resize', () => this.resize());
        this.setupInputs();
        
        requestAnimationFrame(() => this.loop());
    }

    resize() {
        this.canvas.width = this.canvas.parentElement.clientWidth;
        this.canvas.height = this.canvas.parentElement.clientHeight;
        if(this.cam.x === 0) {
            this.cam.x = this.canvas.width/2; 
            this.cam.y = this.canvas.height/2;
        }
        this.draw();
    }

    // --- Core Logic ---

    // Calculate Grid & Snap Position
    getSnap(mx, my) {
        const Z = this.cam.zoom;
        const adjX = (mx - this.cam.x) / Z;
        const adjY = (my - this.cam.y) / Z;

        const gy = (adjY / this.tileH - adjX / this.tileW);
        const gx = (adjX / this.tileW + adjY / this.tileH);
        
        const ix = Math.floor(gx);
        const iy = Math.floor(gy);

        // Sub-grid Logic for snapping
        const dx = gx - ix;
        const dy = gy - iy;
        let sub = 0; 

        if(this.tool.shape === 'pillar') {
            // 4 Corners: 0=Top, 1=Right, 2=Bottom, 3=Left
            if(dx < 0.5 && dy < 0.5) sub = 0; 
            else if(dx > 0.5 && dy < 0.5) sub = 1; 
            else if(dx > 0.5 && dy > 0.5) sub = 2; 
            else sub = 3; 
        } else if (this.tool.shape === 'beam') {
            // 4 Edges: 0=Top(N), 1=Right(E), 2=Bottom(S), 3=Left(W)
            const dTop = dy;
            const dRight = 1 - dx;
            const dBottom = 1 - dy;
            const dLeft = dx;
            const min = Math.min(dTop, dRight, dBottom, dLeft);
            if(min === dTop) sub = 0;
            else if(min === dRight) sub = 1;
            else if(min === dBottom) sub = 2;
            else sub = 3;
        }

        return { x: ix, y: iy, sub };
    }

    // --- Rendering ---

    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.drawGrid();

        // 1. Convert Blocks to Render List
        const list = Object.keys(this.blocks).map(k => {
            const [x,y,z] = k.split(',').map(Number);
            return { x, y, z, ...this.blocks[k], key: k, ghost: false };
        });

        // 2. Add Ghost Cursor (if hovering and not dragging)
        if(this.cursor) {
            list.push({ 
                x: this.cursor.x, y: this.cursor.y, z: this.cursor.z, 
                type: this.tool.shape, color: this.tool.color, sub: this.cursor.sub, 
                ghost: true, key: 'ghost' 
            });
        }

        // 3. Sort (Painter's Algorithm)
        list.sort((a,b) => {
            // Z height first
            if(a.z !== b.z) return a.z - b.z;
            // Then Depth (x+y)
            const d1 = a.x + a.y;
            const d2 = b.x + b.y;
            if(d1 !== d2) return d1 - d2;
            // Tie-break: Ghost always on top? Or specific sub-order
            return a.sub - b.sub;
        });

        list.forEach(b => this.drawBlock(b));
    }

    drawBlock(b) {
        const ctx = this.ctx;
        const Z = this.cam.zoom;
        
        let pos = this.iso(b.x, b.y, b.z);
        
        let w = this.tileW * Z;
        let d = this.tileH * Z;
        let h = this.blockH * Z;

        // Shape Geometry Modifiers
        if(b.type === 'slab') {
            h *= 0.2; 
            // Draws at bottom of cell
        }
        else if(b.type === 'pillar') {
            w *= 0.25; d *= 0.25; h *= 1.2;
            // Shift position to corners
            let sx = 0.5, sy = 0.5;
            if(b.sub === 0) { sx = 0.2; sy = 0.2; } // N
            if(b.sub === 1) { sx = 0.8; sy = 0.2; } // E
            if(b.sub === 2) { sx = 0.8; sy = 0.8; } // S
            if(b.sub === 3) { sx = 0.2; sy = 0.8; } // W
            pos = this.iso(b.x + (sx-0.5), b.y + (sy-0.5), b.z);
        }
        else if(b.type === 'beam') {
            h *= 0.4;
            let long = this.tileW * Z; 
            let short = this.tileW * Z * 0.2;
            let sx=0.5, sy=0.5;

            if(b.sub === 0) { sy=0.1; w=long; d=short; } // Top Edge
            else if(b.sub === 2) { sy=0.9; w=long; d=short; } // Bottom Edge
            else if(b.sub === 1) { sx=0.9; w=short; d=this.tileH*Z; } // Right Edge
            else if(b.sub === 3) { sx=0.1; w=short; d=this.tileH*Z; } // Left Edge

            pos = this.iso(b.x + (sx-0.5), b.y + (sy-0.5), b.z);
        }

        // Colors
        let c1 = b.color, c2 = this.shade(b.color, -15), c3 = this.shade(b.color, -25);
        if(b.ghost) {
            // Transparency for ghost cursor
            ctx.globalAlpha = 0.5;
        }

        // Draw Prism
        const cx = pos.x;
        const cy = pos.y - (b.z * this.blockH * Z);
        const hw = w/2; 
        const hd = d/2;

        // Top Face (Centered at cy - h)
        ctx.beginPath();
        ctx.moveTo(cx, cy - h - hd);
        ctx.lineTo(cx + hw, cy - h);
        ctx.lineTo(cx, cy - h + hd);
        ctx.lineTo(cx - hw, cy - h);
        ctx.closePath();
        ctx.fillStyle = c1; ctx.fill(); 
        
        // Texture
        if(b.texture === 'lines') {
            ctx.fillStyle='rgba(0,0,0,0.1)'; 
            ctx.fillRect(cx-hw/2, cy-h-hd/2, hw, 2); 
            ctx.fillRect(cx-hw/2, cy-h+hd/4, hw, 2);
        }
        if(b.texture === 'grid') {
            ctx.fillStyle='rgba(0,0,0,0.1)';
            ctx.fillRect(cx-hw, cy-h, w, 1);
            ctx.fillRect(cx, cy-h-hd, 1, d);
        }

        // Outline
        ctx.lineWidth = (b.key === this.selection) ? 2 : 0.5;
        ctx.strokeStyle = (b.key === this.selection) ? 'white' : 'rgba(0,0,0,0.1)';
        ctx.stroke();

        // Right Face
        ctx.beginPath();
        ctx.moveTo(cx, cy - h + hd);
        ctx.lineTo(cx + hw, cy - h);
        ctx.lineTo(cx + hw, cy);
        ctx.lineTo(cx, cy + hd);
        ctx.closePath();
        ctx.fillStyle = c2; ctx.fill(); ctx.stroke();

        // Left Face
        ctx.beginPath();
        ctx.moveTo(cx, cy - h + hd);
        ctx.lineTo(cx - hw, cy - h);
        ctx.lineTo(cx - hw, cy);
        ctx.lineTo(cx, cy + hd);
        ctx.closePath();
        ctx.fillStyle = c3; ctx.fill(); ctx.stroke();

        ctx.globalAlpha = 1.0;
    }

    drawGrid() {
        const ctx = this.ctx;
        ctx.lineWidth = 1; ctx.strokeStyle = '#cbd5e1';
        const range = 10;
        ctx.beginPath();
        for(let i=-range; i<=range; i++) {
            let p1=this.iso(i,-range,0), p2=this.iso(i,range,0);
            ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
            let p3=this.iso(-range,i,0), p4=this.iso(range,i,0);
            ctx.moveTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y);
        }
        ctx.stroke();
    }

    iso(x,y,z) {
        return {
            x: (x - y) * this.tileW * 0.5 * this.cam.zoom + this.cam.x,
            y: (x + y) * this.tileH * 0.5 * this.cam.zoom - (z * this.blockH * this.cam.zoom) + this.cam.y
        };
    }

    shade(hex, p) {
        const num = parseInt(hex.replace("#",""), 16);
        const amt = Math.round(2.55 * p);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
    }

    // --- Inputs & Event Handling ---

    setupInputs() {
        const c = this.canvas;
        let start = {x:0, y:0}, last = {x:0, y:0};
        let moved = false;
        let longPressTimer = null;
        let isTouch = false; // Flag to prevent double firing

        // Handler Wrapper
        const down = (x, y, type) => {
            if(type === 'mouse' && isTouch) return; // Ignore mouse if touch is active
            if(type === 'touch') isTouch = true;

            moved = false;
            start = {x, y};
            last = {x, y};
            
            // Long Press Detector
            clearTimeout(longPressTimer);
            longPressTimer = setTimeout(() => {
                if(!moved) this.longPress(x, y);
            }, 600);
        };

        const move = (x, y, type) => {
            if(type === 'mouse' && isTouch) return;
            
            // Update Cursor Highlight
            const snap = this.getSnap(x, y);
            // Calculate z for cursor
            let z = 0;
            while(this.blocks[`${snap.x},${snap.y},${z}`]) z++;
            this.cursor = { x: snap.x, y: snap.y, z: z, sub: snap.sub };

            if(Math.hypot(x-start.x, y-start.y) > 8) {
                moved = true;
                clearTimeout(longPressTimer);
                this.cam.x += x - last.x;
                this.cam.y += y - last.y;
                last = {x, y};
            }
            this.draw();
        };

        const up = (x, y, type) => {
            if(type === 'mouse' && isTouch) {
                // Reset touch flag after small delay to allow mouse to re-engage later if needed?
                // Actually, hybrid devices usually fire both sequence rapidly.
                setTimeout(() => isTouch = false, 500); 
                return;
            }
            clearTimeout(longPressTimer);
            if(!moved) this.tap(x, y);
            else {
                // Just ended a drag, reset cursor if needed
                // this.cursor = null;
                // this.draw();
            }
        };

        // Events
        c.addEventListener('mousedown', e => down(e.clientX, e.clientY, 'mouse'));
        window.addEventListener('mousemove', e => { 
            // Always track cursor for mouse even if buttons not pressed
            if(!e.buttons) {
                const snap = this.getSnap(e.clientX, e.clientY);
                let z = 0;
                while(this.blocks[`${snap.x},${snap.y},${z}`]) z++;
                this.cursor = { x: snap.x, y: snap.y, z: z, sub: snap.sub };
                this.draw();
            } else {
                move(e.clientX, e.clientY, 'mouse');
            }
        });
        window.addEventListener('mouseup', e => up(e.clientX, e.clientY, 'mouse'));
        
        c.addEventListener('touchstart', e => { if(e.touches.length===1) down(e.touches[0].clientX, e.touches[0].clientY, 'touch'); }, {passive:false});
        c.addEventListener('touchmove', e => { 
            e.preventDefault(); // Stop scroll
            if(e.touches.length===1) move(e.touches[0].clientX, e.touches[0].clientY, 'touch'); 
        }, {passive:false});
        c.addEventListener('touchend', e => { 
            if(e.changedTouches.length>0) up(e.changedTouches[0].clientX, e.changedTouches[0].clientY, 'touch'); 
        }, {passive:false});
        
        c.addEventListener('wheel', e => { 
            this.cam.zoom = Math.max(0.5, Math.min(3, this.cam.zoom - Math.sign(e.deltaY)*0.1)); 
            this.draw(); 
        });
        
        // Mouse leave clears cursor
        c.addEventListener('mouseleave', () => { this.cursor = null; this.draw(); });
    }

    tap(mx, my) {
        if(document.getElementById('menu').classList.contains('open')) { 
            this.closeMenu(); return; 
        }

        const snap = this.getSnap(mx, my);
        
        // Find Stack Height
        let z = 0;
        // Simple stacking: if ANY block exists at this x,y,z, go up.
        // We do not currently support multiple sub-blocks in one cell (too complex for data structure)
        while(this.blocks[`${snap.x},${snap.y},${z}`]) z++;

        this.blocks[`${snap.x},${snap.y},${z}`] = {
            type: this.tool.shape,
            color: this.tool.color,
            sub: snap.sub,
            texture: 'none'
        };
        
        this.saveIO();
        this.draw();
        
        // Update cursor z immediately for next click
        if(this.cursor) this.cursor.z = z + 1;
        this.showToast(`Placed ${this.tool.shape}`);
    }

    longPress(mx, my) {
        // Find top-most block at this location
        const snap = this.getSnap(mx, my);
        let topZ = -1;
        for(let z=0; z<20; z++) {
            if(this.blocks[`${snap.x},${snap.y},${z}`]) topZ = z;
        }
        
        if(topZ > -1) {
            this.selection = `${snap.x},${snap.y},${topZ}`;
            document.getElementById('menu').classList.add('open');
            this.draw();
        }
    }

    // --- UI State ---
    setShape(s) { 
        this.tool.shape = s; 
        document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
        document.querySelector(`button[onclick="app.setShape('${s}')"]`).classList.add('active');
        this.showToast(s + " Mode");
    }
    setColor(c) { 
        this.tool.color = c; 
        document.getElementById('colorPreview').style.background = c; 
    }
    setTexture(t) {
        if(this.selection && this.blocks[this.selection]) {
            this.blocks[this.selection].texture = t;
            this.saveIO(); this.draw();
        }
    }
    deleteBlock() {
        if(this.selection && this.blocks[this.selection]) {
            delete this.blocks[this.selection];
            this.selection = null;
            this.closeMenu();
            this.saveIO(); this.draw();
        }
    }
    closeMenu() { document.getElementById('menu').classList.remove('open'); this.selection=null; this.draw(); }
    showToast(m) { const t = document.getElementById('toast'); t.innerText=m; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1000); }

    // IO
    saveIO() { localStorage.setItem('blockAppV4', JSON.stringify(this.blocks)); }
    load() { const d = localStorage.getItem('blockAppV4'); if(d) this.blocks = JSON.parse(d); }
    importFile(el) { 
        const f=el.files[0]; if(!f)return; 
        const r=new FileReader(); r.onload=e=>{this.blocks=JSON.parse(e.target.result);this.saveIO();this.draw();}; 
        r.readAsText(f); 
    }
    loop() { this.draw(); requestAnimationFrame(()=>this.loop()); }
}

const app = new Engine();
</script>
</body>
</html>