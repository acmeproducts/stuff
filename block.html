<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BlockBuilder Rebuilt</title>
    <style>
        :root {
            --bg: #f8fafc;
            --panel: rgba(255, 255, 255, 0.95);
            --border: #cbd5e1;
            --primary: #4f46e5;
            --text: #1e293b;
        }
        body { 
            margin: 0; overflow: hidden; background: var(--bg); 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif; 
            touch-action: none; /* Critical for pinch zoom */
            user-select: none;
        }
        #app { display: flex; flex-direction: column; height: 100vh; }
        
        /* Header */
        header {
            height: 60px; background: var(--panel); border-bottom: 1px solid var(--border);
            display: flex; gap: 10px; align-items: center; padding: 0 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05); z-index: 10;
        }
        
        .toolbar { display: flex; gap: 5px; background: #f1f5f9; padding: 4px; border-radius: 10px; }
        
        button {
            width: 44px; height: 44px; border: none; background: transparent; border-radius: 8px;
            cursor: pointer; color: #64748b; display: flex; align-items: center; justify-content: center;
        }
        button.active { background: white; color: var(--primary); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        button svg { width: 24px; height: 24px; fill: currentColor; }

        .color-well {
            width: 44px; height: 44px; border-radius: 8px; overflow: hidden; position: relative;
            border: 2px solid white; box-shadow: 0 0 0 1px var(--border);
        }

        /* Canvas */
        #viewport { flex: 1; position: relative; background: radial-gradient(circle at center, #f8fafc, #cbd5e1); overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }

        /* HUD */
        .toast {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.8); color: white; padding: 6px 12px;
            border-radius: 20px; font-size: 0.8rem; pointer-events: none; opacity: 0; transition: opacity 0.2s;
        }
        .toast.show { opacity: 1; }

        /* Menu */
        #menu {
            position: absolute; bottom: 0; left: 0; width: 100%; background: white;
            padding: 20px; border-radius: 20px 20px 0 0; transform: translateY(110%);
            transition: transform 0.2s; box-shadow: 0 -5px 20px rgba(0,0,0,0.1); box-sizing: border-box;
            display: flex; flex-direction: column; gap: 10px; z-index: 20;
        }
        #menu.open { transform: translateY(0); }
        .menu-row { display: flex; gap: 10px; }
        .btn-full { flex: 1; padding: 12px; background: #f8fafc; border: 1px solid var(--border); border-radius: 8px; font-weight: 600; }
        .btn-del { background: #fee2e2; color: #dc2626; border-color: #fecaca; }
    </style>
</head>
<body>

<div id="app">
    <header>
        <div class="color-well" id="cDisp" style="background:#4f46e5">
            <input type="color" oninput="app.setColor(this.value)" value="#4f46e5" style="position:absolute; top:-10px; left:-10px; width:70px; height:70px; opacity:0;">
        </div>
        
        <div class="toolbar">
            <button class="active" onclick="app.setShape('cube')" title="Cube"><svg viewBox="0 0 24 24"><path d="M12 3l8 4.5v9L12 21l-8-4.5v-9L12 3z"/></svg></button>
            <button onclick="app.setShape('slab')" title="Slab"><svg viewBox="0 0 24 24"><path d="M12 13l8 3.5v4l-8 3.5-8-3.5v-4L12 13z"/></svg></button>
            <button onclick="app.setShape('pillar')" title="Pillar"><svg viewBox="0 0 24 24"><rect x="10" y="4" width="4" height="16" rx="1"/></svg></button>
            <button onclick="app.setShape('beam')" title="Beam"><svg viewBox="0 0 24 24"><rect x="4" y="10" width="16" height="4" rx="1"/></svg></button>
        </div>

        <div style="flex:1"></div>

        <div class="toolbar">
            <button onclick="app.save()" title="Save"><svg viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/></svg></button>
            <button onclick="document.getElementById('fileIn').click()" title="Import"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></button>
            <input type="file" id="fileIn" hidden onchange="app.import(this)">
        </div>
    </header>

    <div id="viewport">
        <canvas id="canvas"></canvas>
        <div id="toast" class="toast">Saved</div>
    </div>

    <div id="menu">
        <div class="menu-row" style="justify-content:space-between; font-weight:bold;">
            <span>Edit Block</span> <button onclick="app.closeMenu()" style="width:30px; height:30px;">âœ•</button>
        </div>
        <div class="menu-row">
            <button class="btn-full" onclick="app.setTexture('none')">Smooth</button>
            <button class="btn-full" onclick="app.setTexture('lines')">Lines</button>
            <button class="btn-full" onclick="app.setTexture('grid')">Grid</button>
        </div>
        <button class="btn-full btn-del" onclick="app.deleteBlock()">Delete</button>
    </div>
</div>

<script>
class Engine {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.container = document.getElementById('viewport');
        
        // Base Config
        this.tileW = 60; this.tileH = 30; this.blockH = 40;
        
        // State
        this.blocks = {};
        this.cam = { x: 0, y: 0, zoom: 1 };
        this.tool = { shape: 'cube', color: '#4f46e5' };
        this.cursor = null;
        this.selected = null;
        
        // Input State (The Stable Logic)
        this.isTouch = false;
        this.lastX = 0; this.lastY = 0;
        this.isDragging = false;
        this.pinchDist = 0;

        // Init
        this.resize();
        this.load();
        
        // Listeners
        window.addEventListener('resize', () => this.resize());
        this.setupStableInputs();
        
        requestAnimationFrame(() => this.loop());
    }

    resize() {
        this.canvas.width = this.container.clientWidth;
        this.canvas.height = this.container.clientHeight;
        if(this.cam.x===0) { this.cam.x = this.canvas.width/2; this.cam.y = this.canvas.height/2; }
    }

    // --- The Stable Input Logic (v1.1 Style) ---
    setupStableInputs() {
        const c = this.canvas;
        
        // Touch Handlers
        c.addEventListener('touchstart', e => {
            e.preventDefault(); // Critical: Stops mouse emulation
            this.isTouch = true;
            
            if(e.touches.length === 1) {
                // Pan / Tap Start
                this.isDragging = false;
                this.lastX = e.touches[0].clientX;
                this.lastY = e.touches[0].clientY;
                
                // Long Press Timer
                this.longPressTimer = setTimeout(() => {
                    if(!this.isDragging) this.handleLongPress(this.lastX, this.lastY);
                }, 600);
            } 
            else if(e.touches.length === 2) {
                // Pinch Start
                const t1 = e.touches[0], t2 = e.touches[1];
                this.pinchDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
            }
        }, {passive: false});

        c.addEventListener('touchmove', e => {
            e.preventDefault();
            if(e.touches.length === 1) {
                // Pan
                const x = e.touches[0].clientX;
                const y = e.touches[0].clientY;
                const dx = x - this.lastX;
                const dy = y - this.lastY;
                
                if(Math.hypot(dx, dy) > 5) {
                    this.isDragging = true;
                    clearTimeout(this.longPressTimer);
                    this.cam.x += dx;
                    this.cam.y += dy;
                    this.lastX = x;
                    this.lastY = y;
                }
            } 
            else if(e.touches.length === 2) {
                // Pinch Zoom
                clearTimeout(this.longPressTimer);
                const t1 = e.touches[0], t2 = e.touches[1];
                const dist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                
                const delta = (dist - this.pinchDist) * 0.005;
                this.cam.zoom = Math.max(0.5, Math.min(3, this.cam.zoom + delta));
                this.pinchDist = dist;
            }
        }, {passive: false});

        c.addEventListener('touchend', e => {
            e.preventDefault(); // Prevents "Ghost Mouse Click" (The duplication fix)
            clearTimeout(this.longPressTimer);
            
            if(!this.isDragging && e.changedTouches.length > 0 && e.touches.length === 0) {
                // Clean Tap
                const t = e.changedTouches[0];
                this.handleTap(t.clientX, t.clientY);
            }
        }, {passive: false});

        // Mouse Handlers (Desktop Fallback)
        c.addEventListener('mousedown', e => {
            if(this.isTouch) return;
            this.isDragging = false;
            this.lastX = e.clientX; this.lastY = e.clientY;
            this.longPressTimer = setTimeout(() => {
                if(!this.isDragging) this.handleLongPress(e.clientX, e.clientY);
            }, 600);
        });
        
        window.addEventListener('mousemove', e => {
            // Update Cursor
            const snap = this.getSnap(e.clientX, e.clientY);
            let z = 0; while(this.blocks[`${snap.x},${snap.y},${z}`]) z++;
            this.cursor = { ...snap, z };
            
            if(this.isTouch || e.buttons === 0) return;
            const dx = e.clientX - this.lastX;
            const dy = e.clientY - this.lastY;
            if(Math.hypot(dx,dy) > 5) {
                this.isDragging = true;
                clearTimeout(this.longPressTimer);
                this.cam.x += dx; this.cam.y += dy;
                this.lastX = e.clientX; this.lastY = e.clientY;
            }
        });

        window.addEventListener('mouseup', e => {
            if(this.isTouch) return;
            clearTimeout(this.longPressTimer);
            if(!this.isDragging) this.handleTap(e.clientX, e.clientY);
        });
        
        c.addEventListener('wheel', e => {
            this.cam.zoom = Math.max(0.5, Math.min(3, this.cam.zoom - Math.sign(e.deltaY)*0.1));
        }, {passive:false});
    }

    // --- Logic ---

    getSnap(mx, my) {
        const Z = this.cam.zoom;
        const adjX = (mx - this.cam.x) / Z;
        const adjY = (my - this.cam.y) / Z;
        
        const gy = (adjY / this.tileH - adjX / this.tileW);
        const gx = (adjX / this.tileW + adjY / this.tileH);
        const ix = Math.floor(gx);
        const iy = Math.floor(gy);
        
        // Sub Snap
        let sub = 0;
        const dx = gx - ix; const dy = gy - iy;
        
        if(this.tool.shape === 'pillar') {
            if(dx<0.5 && dy<0.5) sub=0; else if(dx>0.5 && dy<0.5) sub=1;
            else if(dx>0.5 && dy>0.5) sub=2; else sub=3;
        } else if(this.tool.shape === 'beam') {
            const dt=dy, dr=1-dx, db=1-dy, dl=dx;
            const min = Math.min(dt, dr, db, dl);
            if(min===dt) sub=0; else if(min===dr) sub=1; else if(min===db) sub=2; else sub=3;
        }
        return { x: ix, y: iy, sub };
    }

    handleTap(mx, my) {
        if(document.getElementById('menu').classList.contains('open')) {
            this.closeMenu(); return;
        }
        
        const snap = this.getSnap(mx, my);
        let z = 0;
        while(this.blocks[`${snap.x},${snap.y},${z}`]) z++;
        
        this.blocks[`${snap.x},${snap.y},${z}`] = {
            type: this.tool.shape,
            color: this.tool.color,
            sub: snap.sub,
            texture: 'none'
        };
        this.save();
        this.toast(`Placed ${this.tool.shape}`);
    }

    handleLongPress(mx, my) {
        const snap = this.getSnap(mx, my);
        let topZ = -1;
        for(let z=0; z<32; z++) {
            if(this.blocks[`${snap.x},${snap.y},${z}`]) topZ = z;
        }
        if(topZ > -1) {
            this.selected = `${snap.x},${snap.y},${topZ}`;
            document.getElementById('menu').classList.add('open');
        }
    }

    // --- Rendering ---
    
    loop() {
        this.draw();
        requestAnimationFrame(() => this.loop());
    }

    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawGrid();
        
        // List blocks + Ghost
        const list = Object.keys(this.blocks).map(k => {
            const [x,y,z] = k.split(',').map(Number);
            return { x, y, z, ...this.blocks[k], key: k };
        });
        
        if(this.cursor && !this.isDragging && !this.isTouch) {
            list.push({ 
                x: this.cursor.x, y: this.cursor.y, z: this.cursor.z, 
                type: this.tool.shape, color: this.tool.color, sub: this.cursor.sub, 
                ghost: true 
            });
        }

        list.sort((a,b) => (a.z - b.z) || ((a.x+a.y) - (b.x+b.y)) || (a.sub - b.sub));

        list.forEach(b => this.drawBlock(b));
    }

    drawBlock(b) {
        const ctx = this.ctx;
        const Z = this.cam.zoom;
        const pos = this.iso(b.x, b.y, b.z);
        
        let w = this.tileW * Z, d = this.tileH * Z, h = this.blockH * Z;
        let cx = pos.x, cy = pos.y - (b.z * h); // fixed height scaling

        if(b.type === 'slab') h *= 0.2;
        else if(b.type === 'pillar') {
            w *= 0.25; d *= 0.25; h *= 1.2;
            const o = 0.35;
            let sx=0, sy=0;
            // 0=N(-,-), 1=E(+,-), 2=S(+,+), 3=W(-,+)
            if(b.sub===0){sx=-o;sy=-o;} if(b.sub===1){sx=o;sy=-o;}
            if(b.sub===2){sx=o;sy=o;}   if(b.sub===3){sx=-o;sy=o;}
            const off = this.iso(sx, sy, 0);
            cx += off.x - this.cam.x; cy += off.y - this.cam.y; 
        }
        else if(b.type === 'beam') {
            h *= 0.4;
            const full=w, thin=w*0.2;
            let sx=0, sy=0;
            if(b.sub===0 || b.sub===2) { w=full; d=thin; sy = (b.sub===0)?-0.4:0.4; }
            else { w=thin; d=this.tileH*Z; sx = (b.sub===3)?-0.4:0.4; }
            const off = this.iso(sx, sy, 0);
            cx += off.x - this.cam.x; cy += off.y - this.cam.y;
        }

        if(b.ghost) ctx.globalAlpha = 0.5;

        // Draw Prism
        const c1=b.color, c2=this.shade(b.color,-15), c3=this.shade(b.color,-25);
        const hw=w/2, hd=d/2;
        
        // Top
        ctx.beginPath();
        ctx.moveTo(cx, cy-h-hd); ctx.lineTo(cx+hw, cy-h); ctx.lineTo(cx, cy-h+hd); ctx.lineTo(cx-hw, cy-h);
        ctx.closePath(); ctx.fillStyle=c1; ctx.fill();
        
        // Texture
        if(b.texture === 'lines') { ctx.fillStyle='rgba(0,0,0,0.1)'; ctx.fillRect(cx-hw/2, cy-h-hd/2, hw, 2); ctx.fillRect(cx-hw/2, cy-h+hd/4, hw, 2); }
        if(b.texture === 'grid') { ctx.fillStyle='rgba(0,0,0,0.1)'; ctx.fillRect(cx-hw, cy-h, w, 1); ctx.fillRect(cx, cy-h-hd, 1, d); }

        ctx.strokeStyle = (this.selected === b.key) ? 'white' : 'rgba(0,0,0,0.1)';
        ctx.lineWidth = (this.selected === b.key) ? 2 : 0.5;
        ctx.stroke();

        // Right
        ctx.beginPath(); ctx.moveTo(cx, cy-h+hd); ctx.lineTo(cx+hw, cy-h); ctx.lineTo(cx+hw, cy); ctx.lineTo(cx, cy+hd);
        ctx.closePath(); ctx.fillStyle=c2; ctx.fill(); ctx.stroke();

        // Left
        ctx.beginPath(); ctx.moveTo(cx, cy-h+hd); ctx.lineTo(cx-hw, cy-h); ctx.lineTo(cx-hw, cy); ctx.lineTo(cx, cy+hd);
        ctx.closePath(); ctx.fillStyle=c3; ctx.fill(); ctx.stroke();
        
        ctx.globalAlpha = 1.0;
    }

    drawGrid() {
        const ctx = this.ctx;
        ctx.lineWidth = 1; ctx.strokeStyle = '#cbd5e1';
        ctx.beginPath();
        for(let i=-10; i<=10; i++) {
            let p1=this.iso(i,-10,0), p2=this.iso(i,10,0);
            ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
            let p3=this.iso(-10,i,0), p4=this.iso(10,i,0);
            ctx.moveTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y);
        }
        ctx.stroke();
    }

    iso(x, y, z) {
        return {
            x: (x - y) * this.tileW * 0.5 * this.cam.zoom + this.cam.x,
            y: (x + y) * this.tileH * 0.5 * this.cam.zoom - (z * this.blockH * this.cam.zoom) + this.cam.y
        };
    }
    
    shade(c, p) {
        const num = parseInt(c.replace("#",""), 16);
        const amt = Math.round(2.55 * p);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
    }
    
    // UI Helpers
    setShape(s) { this.tool.shape = s; document.querySelectorAll('button').forEach(b=>b.classList.remove('active')); this.toast(s); }
    setColor(c) { this.tool.color = c; document.getElementById('cDisp').style.background = c; }
    setTexture(t) { if(this.selected) { this.blocks[this.selected].texture = t; this.save(); } }
    deleteBlock() { if(this.selected) { delete this.blocks[this.selected]; this.closeMenu(); this.save(); } }
    closeMenu() { document.getElementById('menu').classList.remove('open'); this.selected = null; }
    toast(m) { const t=document.getElementById('toast'); t.innerText=m; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1000); }
    save() { localStorage.setItem('blockRebuilt', JSON.stringify(this.blocks)); }
    load() { const d=localStorage.getItem('blockRebuilt'); if(d) this.blocks = JSON.parse(d); }
    import(el) { const f=el.files[0]; if(f){ const r=new FileReader(); r.onload=e=>{this.blocks=JSON.parse(e.target.result);this.save();}; r.readAsText(f); } }
}

const app = new Engine();
</script>
</body>
</html>