<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BlockBuilder Touch Fixed</title>
    <style>
        :root {
            --bg: #f8fafc;
            --panel: rgba(255, 255, 255, 0.98);
            --border: #e2e8f0;
            --primary: #2563eb;
            --text: #0f172a;
        }
        body { 
            margin: 0; 
            overflow: hidden; 
            background: var(--bg); 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            /* Critical for stopping browser zoom interference */
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
        }
        #app { display: flex; flex-direction: column; height: 100vh; }
        
        /* Header */
        header {
            padding: 0 16px; background: var(--panel); border-bottom: 1px solid var(--border);
            display: flex; gap: 16px; align-items: center; height: 64px;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05); z-index: 10;
        }
        
        .toolbar-group {
            display: flex; background: #f1f5f9; padding: 4px; border-radius: 12px; gap: 4px;
        }
        
        button {
            width: 48px; height: 48px; border: none; background: transparent; border-radius: 8px;
            cursor: pointer; color: #64748b; flex-shrink: 0; display: flex; align-items: center; justify-content: center;
        }
        button.active { background: white; color: var(--primary); box-shadow: 0 2px 5px rgba(0,0,0,0.08); }
        button svg { width: 24px; height: 24px; fill: currentColor; }
        
        .color-well {
            width: 48px; height: 48px; border-radius: 12px; position: relative; overflow: hidden;
            border: 2px solid white; box-shadow: 0 0 0 1px var(--border);
        }
        
        /* Canvas */
        #viewport { flex: 1; position: relative; background: radial-gradient(circle at center, #f8fafc, #cbd5e1); overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; outline: none; }

        /* Toast */
        .toast {
            position: absolute; top: 90px; left: 50%; transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.8); color: white; padding: 8px 16px;
            border-radius: 20px; font-size: 0.85rem; pointer-events: none;
            opacity: 0; transition: opacity 0.2s;
        }
        .toast.show { opacity: 1; }
        
        /* Context Menu */
        #menu {
            position: absolute; bottom: 0; left: 0; width: 100%; background: white;
            border-radius: 24px 24px 0 0; padding: 24px; box-sizing: border-box;
            box-shadow: 0 -10px 40px rgba(0,0,0,0.1); transform: translateY(100%);
            transition: transform 0.25s cubic-bezier(0.32, 0.72, 0, 1); z-index: 100;
            display: flex; flex-direction: column; gap: 16px;
        }
        #menu.open { transform: translateY(0); }
        
        .menu-header { display: flex; justify-content: space-between; align-items: center; font-weight: 700; color: var(--text); }
        .grid-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
        .btn-opt { padding: 12px; background: #f8fafc; border: 1px solid var(--border); border-radius: 8px; font-weight: 600; font-size: 0.9rem; }
        .btn-del { background: #fef2f2; color: #ef4444; border-color: #fee2e2; }
    </style>
</head>
<body>

<div id="app">
    <header>
        <div class="color-well" id="colorDisplay" style="background:#2563eb">
            <input type="color" value="#2563eb" oninput="engine.setColor(this.value)" style="position:absolute; top:-10px; left:-10px; width:80px; height:80px; opacity:0; cursor:pointer;">
        </div>
        
        <div class="toolbar-group">
            <button class="active shape-btn" onclick="engine.setShape('cube')" title="Cube">
                <svg viewBox="0 0 24 24"><path d="M12 3l8 4.5v9L12 21l-8-4.5v-9L12 3z"/></svg>
            </button>
            <button class="shape-btn" onclick="engine.setShape('slab')" title="Slab">
                <svg viewBox="0 0 24 24"><path d="M12 13l8 3.5v4l-8 3.5-8-3.5v-4L12 13z"/></svg>
            </button>
            <button class="shape-btn" onclick="engine.setShape('pillar')" title="Pillar">
                <svg viewBox="0 0 24 24"><rect x="10" y="4" width="4" height="16" rx="1"/></svg>
            </button>
            <button class="shape-btn" onclick="engine.setShape('beam')" title="Beam">
                <svg viewBox="0 0 24 24"><rect x="4" y="10" width="16" height="4" rx="1"/></svg>
            </button>
        </div>

        <div style="flex:1"></div>

        <div class="toolbar-group">
            <button onclick="engine.save()" title="Save">
                <svg viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/></svg>
            </button>
            <button onclick="document.getElementById('fileIn').click()" title="Import">
                <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
            </button>
            <input type="file" id="fileIn" hidden onchange="engine.import(this)">
        </div>
    </header>

    <div id="viewport">
        <canvas id="canvas"></canvas>
        <div id="toast" class="toast">Saved</div>
    </div>

    <div id="menu">
        <div class="menu-header">
            <span>Edit Block</span>
            <button onclick="engine.closeMenu()" style="width:32px; height:32px; background:#f1f5f9;">âœ•</button>
        </div>
        <div class="grid-row">
            <button class="btn-opt" onclick="engine.setTexture('none')">Smooth</button>
            <button class="btn-opt" onclick="engine.setTexture('lines')">Lines</button>
            <button class="btn-opt" onclick="engine.setTexture('grid')">Grid</button>
        </div>
        <button class="btn-opt btn-del" onclick="engine.deleteBlock()">Delete</button>
    </div>
</div>

<script>
class Engine {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Config
        this.tileW = 60;
        this.tileH = 30; 
        this.blockH = 40;
        
        // State
        this.blocks = {};
        this.cam = { x: 0, y: 0, zoom: 1 };
        this.tool = { shape: 'cube', color: '#2563eb' };
        this.cursor = null;
        this.selected = null;

        // Input State
        this.lastTouchTime = 0; // Critical for anti-duplication
        this.touches = {
            active: false,
            moved: false,
            startX: 0, startY: 0,
            lastX: 0, lastY: 0,
            initDist: 0, initZoom: 1
        };

        this.resize();
        this.load();
        
        window.onresize = () => this.resize();
        this.bindEvents();
        this.loop();
    }

    bindEvents() {
        const c = this.canvas;
        
        // Touch Events (Passive: false prevents scrolling)
        c.addEventListener('touchstart', e => this.onTouchStart(e), { passive: false });
        c.addEventListener('touchmove', e => this.onTouchMove(e), { passive: false });
        c.addEventListener('touchend', e => this.onTouchEnd(e), { passive: false });

        // Mouse Events
        c.addEventListener('mousedown', e => this.onMouseDown(e));
        window.addEventListener('mousemove', e => this.onMouseMove(e));
        window.addEventListener('mouseup', e => this.onMouseUp(e));
        c.addEventListener('wheel', e => this.onWheel(e), { passive: false });
    }

    // --- Input Logic ---

    onTouchStart(e) {
        e.preventDefault(); // Stop mouse emulation
        this.lastTouchTime = Date.now();
        
        if (e.touches.length === 1) {
            // Pan / Tap Start
            const t = e.touches[0];
            this.touches.active = true;
            this.touches.moved = false;
            this.touches.startX = t.clientX;
            this.touches.startY = t.clientY;
            this.touches.lastX = t.clientX;
            this.touches.lastY = t.clientY;
            
            // Long Press Timer
            this.longPressTimer = setTimeout(() => {
                if(!this.touches.moved && e.touches.length === 1) {
                    this.handleLongPress(t.clientX, t.clientY);
                }
            }, 600);

        } else if (e.touches.length === 2) {
            // Pinch Start
            this.touches.moved = true; // Pinching is not a tap
            clearTimeout(this.longPressTimer);
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            this.touches.initDist = Math.hypot(dx, dy);
            this.touches.initZoom = this.cam.zoom;
        }
    }

    onTouchMove(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
            const t = e.touches[0];
            const dx = t.clientX - this.touches.lastX;
            const dy = t.clientY - this.touches.lastY;
            
            // Threshold to detect drag vs shaky tap
            if (Math.hypot(t.clientX - this.touches.startX, t.clientY - this.touches.startY) > 8) {
                this.touches.moved = true;
                clearTimeout(this.longPressTimer);
            }
            
            if (this.touches.moved) {
                this.cam.x += dx;
                this.cam.y += dy;
                this.touches.lastX = t.clientX;
                this.touches.lastY = t.clientY;
            }
        } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.hypot(dx, dy);
            
            if (this.touches.initDist > 0) {
                const scale = dist / this.touches.initDist;
                this.cam.zoom = Math.max(0.5, Math.min(3.5, this.touches.initZoom * scale));
            }
        }
    }

    onTouchEnd(e) {
        e.preventDefault(); // Stop mouse click generation
        clearTimeout(this.longPressTimer);
        
        // If 1 finger lift and it wasn't a drag/pinch -> Tap
        if (!this.touches.moved && e.changedTouches.length === 1 && e.touches.length === 0) {
            const t = e.changedTouches[0];
            this.handleTap(t.clientX, t.clientY);
        }
        this.touches.active = false;
    }

    onMouseDown(e) {
        // Gating: If touch happened < 800ms ago, ignore mouse
        if (Date.now() - this.lastTouchTime < 800) return;
        
        this.touches.active = true;
        this.touches.moved = false;
        this.touches.startX = e.clientX;
        this.touches.startY = e.clientY;
        this.touches.lastX = e.clientX;
        this.touches.lastY = e.clientY;
        
        this.longPressTimer = setTimeout(() => {
            if(!this.touches.moved) this.handleLongPress(e.clientX, e.clientY);
        }, 600);
    }

    onMouseMove(e) {
        // Ghost Cursor update
        const snap = this.getSnap(e.clientX, e.clientY);
        let z = 0;
        while(this.blocks[`${snap.x},${snap.y},${z}`]) z++;
        this.cursor = { x: snap.x, y: snap.y, z: z, sub: snap.sub };

        if (!this.touches.active) return;
        
        if (Math.hypot(e.clientX - this.touches.startX, e.clientY - this.touches.startY) > 5) {
            this.touches.moved = true;
            clearTimeout(this.longPressTimer);
        }
        
        if (this.touches.moved) {
            this.cam.x += e.clientX - this.touches.lastX;
            this.cam.y += e.clientY - this.touches.lastY;
            this.touches.lastX = e.clientX;
            this.touches.lastY = e.clientY;
        }
    }

    onMouseUp(e) {
        if (Date.now() - this.lastTouchTime < 800) return;
        clearTimeout(this.longPressTimer);
        if (!this.touches.moved) this.handleTap(e.clientX, e.clientY);
        this.touches.active = false;
    }

    onWheel(e) {
        e.preventDefault();
        this.cam.zoom = Math.max(0.5, Math.min(3.5, this.cam.zoom - Math.sign(e.deltaY) * 0.1));
    }

    // --- App Logic ---

    getSnap(mx, my) {
        const Z = this.cam.zoom;
        const adjX = (mx - this.cam.x) / Z;
        const adjY = (my - this.cam.y) / Z;
        
        const gy = (adjY / this.tileH - adjX / this.tileW);
        const gx = (adjX / this.tileW + adjY / this.tileH);
        const ix = Math.floor(gx);
        const iy = Math.floor(gy);
        
        const dx = gx - ix;
        const dy = gy - iy;
        let sub = 0;

        if (this.tool.shape === 'pillar') {
            // Corners: 0=Top, 1=Right, 2=Bottom, 3=Left
            if (dx<0.5 && dy<0.5) sub=0; else if (dx>0.5 && dy<0.5) sub=1;
            else if (dx>0.5 && dy>0.5) sub=2; else sub=3;
        } else if (this.tool.shape === 'beam') {
            // Edges: 0=Top, 1=Right, 2=Bottom, 3=Left
            const dt=dy, dr=1-dx, db=1-dy, dl=dx;
            const min = Math.min(dt, dr, db, dl);
            if(min===dt) sub=0; else if(min===dr) sub=1; else if(min===db) sub=2; else sub=3;
        }
        return { x: ix, y: iy, sub };
    }

    handleTap(mx, my) {
        if (document.getElementById('menu').classList.contains('open')) {
            this.closeMenu(); return;
        }

        const snap = this.getSnap(mx, my);
        let z = 0;
        // Simple stacking logic
        while(this.blocks[`${snap.x},${snap.y},${z}`]) z++;
        
        this.blocks[`${snap.x},${snap.y},${z}`] = {
            type: this.tool.shape,
            color: this.tool.color,
            sub: snap.sub,
            texture: 'none'
        };
        this.save();
        this.toast(`Placed ${this.tool.shape}`);
    }

    handleLongPress(mx, my) {
        const snap = this.getSnap(mx, my);
        // Find top-most block here
        let topZ = -1;
        for(let z=0; z<32; z++) {
            if(this.blocks[`${snap.x},${snap.y},${z}`]) topZ = z;
        }
        if(topZ > -1) {
            this.selected = `${snap.x},${snap.y},${topZ}`;
            document.getElementById('menu').classList.add('open');
        }
    }

    // --- Rendering ---
    
    resize() {
        this.canvas.width = this.canvas.parentElement.clientWidth;
        this.canvas.height = this.canvas.parentElement.clientHeight;
        if(this.cam.x === 0) { this.cam.x = this.canvas.width/2; this.cam.y = this.canvas.height/2; }
    }

    loop() {
        this.draw();
        requestAnimationFrame(() => this.loop());
    }

    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawGrid();
        
        // Prepare list
        const list = Object.keys(this.blocks).map(k => {
            const [x,y,z] = k.split(',').map(Number);
            return { x, y, z, ...this.blocks[k], key: k };
        });

        // Add Ghost
        if(this.cursor && !this.touches.moved) {
            list.push({ 
                x: this.cursor.x, y: this.cursor.y, z: this.cursor.z, 
                type: this.tool.shape, color: this.tool.color, sub: this.cursor.sub, 
                ghost: true 
            });
        }

        // Sort Z -> Depth -> Sub
        list.sort((a,b) => {
            if(a.z !== b.z) return a.z - b.z;
            const d1 = a.x + a.y; const d2 = b.x + b.y;
            if(d1 !== d2) return d1 - d2;
            return a.sub - b.sub;
        });

        list.forEach(b => this.drawBlock(b));
    }

    drawBlock(b) {
        const ctx = this.ctx;
        const Z = this.cam.zoom;
        const pos = this.iso(b.x, b.y, b.z);
        
        let w = this.tileW * Z, d = this.tileH * Z, h = this.blockH * Z;
        let cx = pos.x, cy = pos.y - (b.z * this.blockH * Z);

        // Geometries
        if(b.type === 'slab') { h *= 0.2; }
        else if(b.type === 'pillar') {
            w *= 0.25; d *= 0.25; h *= 1.2;
            const o = 0.35; // corner offset
            // sub: 0=N, 1=E, 2=S, 3=W. 
            // In iso: N is -x-y, E is +x-y?
            // Simple mapping:
            let sx=0, sy=0;
            if(b.sub===0){sx=-o;sy=-o;} if(b.sub===1){sx=o;sy=-o;}
            if(b.sub===2){sx=o;sy=o;}   if(b.sub===3){sx=-o;sy=o;}
            // Convert grid offset to screen offset
            // x-axis is (1, 0.5), y-axis is (-1, 0.5) roughly
            const off = this.iso(sx, sy, 0);
            cx += off.x - this.cam.x; cy += off.y - this.cam.y; 
        }
        else if(b.type === 'beam') {
            h *= 0.4;
            const full = this.tileW*Z; const thin = full*0.2;
            let sx=0, sy=0;
            // sub: 0=T, 1=R, 2=B, 3=L
            if(b.sub===0 || b.sub===2) { w=full; d=thin; if(b.sub===0)sy=-0.4; else sy=0.4; }
            else { w=thin; d=this.tileH*Z; if(b.sub===1)sx=0.4; else sx=-0.4; }
            const off = this.iso(sx, sy, 0);
            cx += off.x - this.cam.x; cy += off.y - this.cam.y;
        }

        if(b.ghost) ctx.globalAlpha = 0.5;
        
        // Colors
        const c1=b.color, c2=this.shade(b.color,-15), c3=this.shade(b.color,-25);
        const hw=w/2, hd=d/2;

        // Top
        ctx.beginPath();
        ctx.moveTo(cx, cy-h-hd); ctx.lineTo(cx+hw, cy-h); ctx.lineTo(cx, cy-h+hd); ctx.lineTo(cx-hw, cy-h);
        ctx.closePath(); ctx.fillStyle=c1; ctx.fill(); 
        
        // Texture
        if(b.texture==='lines'){ctx.fillStyle='rgba(0,0,0,0.1)'; ctx.fillRect(cx-hw/2, cy-h-hd/2, hw, 2); ctx.fillRect(cx-hw/2, cy-h+hd/4, hw, 2);}
        if(b.texture==='grid'){ctx.fillStyle='rgba(0,0,0,0.1)'; ctx.fillRect(cx-hw, cy-h, w, 1); ctx.fillRect(cx, cy-h-hd, 1, d);}
        
        // Outline
        ctx.lineWidth = (b.key === this.selected) ? 2 : 0.5;
        ctx.strokeStyle = (b.key === this.selected) ? 'white' : 'rgba(0,0,0,0.1)';
        ctx.stroke();

        // Right
        ctx.beginPath();
        ctx.moveTo(cx, cy-h+hd); ctx.lineTo(cx+hw, cy-h); ctx.lineTo(cx+hw, cy); ctx.lineTo(cx, cy+hd);
        ctx.closePath(); ctx.fillStyle=c2; ctx.fill(); ctx.stroke();

        // Left
        ctx.beginPath();
        ctx.moveTo(cx, cy-h+hd); ctx.lineTo(cx-hw, cy-h); ctx.lineTo(cx-hw, cy); ctx.lineTo(cx, cy+hd);
        ctx.closePath(); ctx.fillStyle=c3; ctx.fill(); ctx.stroke();
        
        ctx.globalAlpha = 1.0;
    }

    drawGrid() {
        const ctx = this.ctx;
        ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=-10; i<=10; i++) {
            let p1=this.iso(i,-10,0), p2=this.iso(i,10,0);
            ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
            let p3=this.iso(-10,i,0), p4=this.iso(10,i,0);
            ctx.moveTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y);
        }
        ctx.stroke();
    }

    iso(x,y,z) {
        return {
            x: (x - y) * this.tileW * 0.5 * this.cam.zoom + this.cam.x,
            y: (x + y) * this.tileH * 0.5 * this.cam.zoom - (z * this.blockH * this.cam.zoom) + this.cam.y
        };
    }

    shade(hex, p) {
        const num = parseInt(hex.replace("#",""), 16);
        const amt = Math.round(2.55 * p);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
    }
    
    // UI
    setColor(c) { this.tool.color = c; document.getElementById('colorDisplay').style.background = c; }
    setShape(s) { 
        this.tool.shape = s; 
        document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
        document.querySelector(`button[onclick="engine.setShape('${s}')"]`).classList.add('active');
        this.toast(s + " Mode");
    }
    setTexture(t) { if(this.selected) { this.blocks[this.selected].texture = t; this.save(); } }
    deleteBlock() { if(this.selected) { delete this.blocks[this.selected]; this.closeMenu(); this.save(); } }
    closeMenu() { document.getElementById('menu').classList.remove('open'); this.selected = null; }
    toast(m) { const t=document.getElementById('toast'); t.innerText=m; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), 1000); }
    save() { localStorage.setItem('block5', JSON.stringify(this.blocks)); }
    load() { const d=localStorage.getItem('block5'); if(d) this.blocks = JSON.parse(d); }
    import(el) { const f=el.files[0]; if(f){ const r=new FileReader(); r.onload=e=>{this.blocks=JSON.parse(e.target.result);this.save();}; r.readAsText(f); } }
}

const engine = new Engine();
</script>
</body>
</html>