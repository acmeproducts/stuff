<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BlockBuilder Baseline</title>
    <style>
        :root {
            --bg: #f0f4f8;
            --panel: #ffffff;
            --border: #cbd5e1;
            --primary: #4f46e5;
        }
        body { 
            margin: 0; overflow: hidden; background: var(--bg); 
            font-family: sans-serif; 
            touch-action: none; /* Disables browser zoom/scroll */
            user-select: none;
            -webkit-user-select: none;
        }
        #app { display: flex; flex-direction: column; height: 100vh; }
        
        /* Simple Toolbar */
        header {
            height: 60px; background: var(--panel); border-bottom: 1px solid var(--border);
            display: flex; align-items: center; padding: 0 10px; gap: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05); z-index: 10;
        }
        
        .group { display: flex; background: #f1f5f9; padding: 4px; border-radius: 8px; gap: 4px; }
        
        button {
            width: 44px; height: 44px; border: 1px solid transparent; background: transparent; border-radius: 6px;
            cursor: pointer; display: flex; align-items: center; justify-content: center; color: #64748b;
        }
        button.active { background: white; color: var(--primary); border-color: var(--border); box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        button svg { width: 24px; height: 24px; fill: currentColor; }

        .color-box {
            width: 44px; height: 44px; border-radius: 6px; overflow: hidden; position: relative;
            border: 2px solid white; box-shadow: 0 0 0 1px var(--border);
        }

        /* Canvas */
        #viewport { flex: 1; position: relative; background: radial-gradient(circle at center, #f8fafc, #cbd5e1); overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }

        /* Toast */
        .toast {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); color: white; padding: 6px 12px;
            border-radius: 12px; font-size: 0.8rem; opacity: 0; pointer-events: none; transition: opacity 0.2s;
        }
        .toast.show { opacity: 1; }
    </style>
</head>
<body>

<div id="app">
    <header>
        <div class="color-box" id="cDisp" style="background:#4f46e5">
            <input type="color" value="#4f46e5" oninput="app.setColor(this.value)" style="position:absolute; top:-10px; left:-10px; width:60px; height:60px; opacity:0;">
        </div>
        
        <div class="group">
            <button class="active" onclick="app.setShape('cube')"><svg viewBox="0 0 24 24"><path d="M12 3l8 4.5v9L12 21l-8-4.5v-9L12 3z"/></svg></button>
            <button onclick="app.setShape('slab')"><svg viewBox="0 0 24 24"><path d="M12 13l8 3.5v4l-8 3.5-8-3.5v-4L12 13z"/></svg></button>
            <button onclick="app.setShape('pillar')"><svg viewBox="0 0 24 24"><rect x="10" y="4" width="4" height="16" rx="1"/></svg></button>
            <button onclick="app.setShape('beam')"><svg viewBox="0 0 24 24"><rect x="4" y="10" width="16" height="4" rx="1"/></svg></button>
        </div>

        <div style="flex:1"></div>

        <div class="group">
            <button onclick="app.save()"><svg viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/></svg></button>
            <button onclick="app.clear()"><svg viewBox="0 0 24 24"><path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></button>
        </div>
    </header>

    <div id="viewport">
        <canvas id="canvas"></canvas>
        <div id="toast" class="toast">Action</div>
    </div>
</div>

<script>
class Engine {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.container = document.getElementById('viewport');
        
        // --- BASELINE CONFIG (v1.1) ---
        this.tileW = 60;
        this.tileH = 30;
        this.blockH = 40;
        
        // Data
        this.blocks = {};
        this.cam = { x: 0, y: 0, zoom: 1 };
        this.tool = { shape: 'cube', color: '#4f46e5' };
        
        // Input Vars
        this.touches = []; 
        this.isDragging = false;
        this.lastPos = { x: 0, y: 0 };
        this.pinchStart = 0;
        this.startCamZoom = 1;

        // Init
        this.resize();
        this.load();
        
        // Events
        window.onresize = () => this.resize();
        
        // TOUCH EVENTS (Original Logic)
        this.canvas.addEventListener('touchstart', e => this.onStart(e), {passive: false});
        this.canvas.addEventListener('touchmove', e => this.onMove(e), {passive: false});
        this.canvas.addEventListener('touchend', e => this.onEnd(e), {passive: false});
        
        // MOUSE EVENTS (Desktop Fallback)
        this.canvas.addEventListener('mousedown', e => this.onStart(e));
        window.addEventListener('mousemove', e => this.onMove(e));
        window.addEventListener('mouseup', e => this.onEnd(e));
        this.canvas.addEventListener('wheel', e => {
            this.cam.zoom = Math.max(0.5, Math.min(3, this.cam.zoom - Math.sign(e.deltaY)*0.1));
        });

        this.loop();
    }

    resize() {
        this.canvas.width = this.container.clientWidth;
        this.canvas.height = this.container.clientHeight;
        if(this.cam.x === 0) {
            this.cam.x = this.canvas.width/2;
            this.cam.y = this.canvas.height/2;
        }
    }

    // --- INPUT HANDLER (Reverted to v1.1 Baseline) ---
    
    onStart(e) {
        if(e.type === 'touchstart') {
            e.preventDefault();
            this.touches = e.touches;
            if(e.touches.length === 1) {
                this.isDragging = false;
                this.lastPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                this.startPos = { x: e.touches[0].clientX, y: e.touches[0].clientY }; // For tap detection
            } else if (e.touches.length === 2) {
                this.pinchStart = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                this.startCamZoom = this.cam.zoom;
            }
        } else {
            // Mouse
            this.isDragging = false;
            this.lastPos = { x: e.clientX, y: e.clientY };
            this.startPos = { x: e.clientX, y: e.clientY };
        }
    }

    onMove(e) {
        if(e.type === 'touchmove') {
            e.preventDefault();
            if(e.touches.length === 1) {
                const x = e.touches[0].clientX; 
                const y = e.touches[0].clientY;
                const dx = x - this.lastPos.x;
                const dy = y - this.lastPos.y;
                
                // Drag Threshold
                if(Math.hypot(x - this.startPos.x, y - this.startPos.y) > 5) {
                    this.isDragging = true;
                    this.cam.x += dx;
                    this.cam.y += dy;
                    this.lastPos = {x, y};
                }
            } else if (e.touches.length === 2) {
                const dist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                const scale = dist / this.pinchStart;
                this.cam.zoom = Math.max(0.5, Math.min(3, this.startCamZoom * scale));
            }
        } else if (e.buttons === 1) {
            // Mouse Drag
            const x = e.clientX; const y = e.clientY;
            if(Math.hypot(x - this.startPos.x, y - this.startPos.y) > 5) {
                this.isDragging = true;
                this.cam.x += x - this.lastPos.x;
                this.cam.y += y - this.lastPos.y;
                this.lastPos = {x, y};
            }
        }
    }

    onEnd(e) {
        if(e.type === 'touchend') e.preventDefault();
        
        if(!this.isDragging) {
            // It was a tap
            let x, y;
            if(e.type === 'touchend' && e.changedTouches.length > 0) {
                x = e.changedTouches[0].clientX;
                y = e.changedTouches[0].clientY;
            } else {
                x = e.clientX;
                y = e.clientY;
            }
            if(x !== undefined) this.handleTap(x, y);
        }
    }

    // --- LOGIC ---

    // 100% Deterministic Grid Calculation
    // No sub-pixels. Integer math only.
    getGrid(mx, my) {
        const Z = this.cam.zoom;
        const adjX = (mx - this.cam.x) / Z;
        const adjY = (my - this.cam.y) / Z;

        // Inverse Isometric
        const gy = (adjY / this.tileH - adjX / this.tileW);
        const gx = (adjX / this.tileW + adjY / this.tileH);
        
        return {
            x: Math.floor(gx),
            y: Math.floor(gy)
        };
    }

    handleTap(mx, my) {
        const g = this.getGrid(mx, my);
        
        // Stacking Logic
        // 1. Check if we clicked an existing block (Simple Raycast)
        // We iterate blocks to see if the click hit a "face" higher up
        let hitZ = -1;
        // Simple search: check z=0 to z=20 at this grid x,y
        // Note: true raycasting checks neighbors too, but for baseline, 
        // we assume clicking the tile adds to the stack at that tile.
        
        // Find highest existing block at this X,Y
        let topZ = -1;
        let checkZ = 0;
        while(this.blocks[`${g.x},${g.y},${checkZ}`]) {
            topZ = checkZ;
            checkZ++;
        }
        
        // Place at top + 1
        const newZ = topZ + 1;
        
        this.blocks[`${g.x},${g.y},${newZ}`] = {
            type: this.tool.shape,
            color: this.tool.color
        };
        
        this.save();
        this.toast(`Placed ${this.tool.shape}`);
    }

    // --- DRAWING ---

    loop() {
        this.draw();
        requestAnimationFrame(() => this.loop());
    }

    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.drawGrid();
        
        const list = Object.keys(this.blocks).map(k => {
            const [x,y,z] = k.split(',').map(Number);
            return { x, y, z, ...this.blocks[k] };
        });
        
        // Painter's Algo: Z-Index, then Y-Depth
        list.sort((a,b) => (a.x + a.y) - (b.x + b.y) || a.z - b.z);
        
        list.forEach(b => this.drawBlock(b));
    }
    
    drawBlock(b) {
        const ctx = this.ctx;
        const Z = this.cam.zoom;
        const pos = this.iso(b.x, b.y, b.z);
        
        let w = this.tileW * Z;
        let d = this.tileH * Z;
        let h = this.blockH * Z;
        
        // SHAPE LOGIC (Centered & Simple)
        if(b.type === 'slab') {
            h *= 0.2; // 20% height
        }
        else if(b.type === 'pillar') {
            w *= 0.3; d *= 0.3; h *= 1.2;
            // No offset, strictly centered
        }
        else if(b.type === 'beam') {
            h *= 0.3;
            // No rotation, standard box for consistency
        }
        
        // Draw Prism
        // x,y is bottom center
        const cx = pos.x;
        const cy = pos.y - (b.z * this.blockH * Z); // Stack visual height
        
        const c1 = b.color;
        const c2 = this.shade(b.color, -15);
        const c3 = this.shade(b.color, -25);
        
        const hw = w/2;
        const hd = d/2;

        // Top Face
        ctx.beginPath();
        ctx.moveTo(cx, cy - h - hd);
        ctx.lineTo(cx + hw, cy - h);
        ctx.lineTo(cx, cy - h + hd);
        ctx.lineTo(cx - hw, cy - h);
        ctx.closePath();
        ctx.fillStyle = c1; ctx.fill(); 
        ctx.lineWidth=0.5; ctx.strokeStyle='rgba(0,0,0,0.1)'; ctx.stroke();

        // Right Face
        ctx.beginPath();
        ctx.moveTo(cx, cy - h + hd);
        ctx.lineTo(cx + hw, cy - h);
        ctx.lineTo(cx + hw, cy);
        ctx.lineTo(cx, cy + hd);
        ctx.closePath();
        ctx.fillStyle = c2; ctx.fill(); ctx.stroke();

        // Left Face
        ctx.beginPath();
        ctx.moveTo(cx, cy - h + hd);
        ctx.lineTo(cx - hw, cy - h);
        ctx.lineTo(cx - hw, cy);
        ctx.lineTo(cx, cy + hd);
        ctx.closePath();
        ctx.fillStyle = c3; ctx.fill(); ctx.stroke();
    }
    
    drawGrid() {
        const ctx = this.ctx;
        ctx.lineWidth = 1; ctx.strokeStyle = '#e2e8f0';
        ctx.beginPath();
        for(let i=-10; i<=10; i++) {
            let p1=this.iso(i,-10,0), p2=this.iso(i,10,0);
            ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
            let p3=this.iso(-10,i,0), p4=this.iso(10,i,0);
            ctx.moveTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y);
        }
        ctx.stroke();
    }

    iso(x, y, z) {
        return {
            x: (x - y) * this.tileW * 0.5 * this.cam.zoom + this.cam.x,
            y: (x + y) * this.tileH * 0.5 * this.cam.zoom - (z * this.blockH * this.cam.zoom) + this.cam.y
        };
    }
    
    shade(c, p) {
        const num = parseInt(c.replace("#",""), 16);
        const amt = Math.round(2.55 * p);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
    }
    
    setShape(s) { 
        this.