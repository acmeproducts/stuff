}
                        pill.classList.toggle('visible', count > 0);
                    }
                });
            },
            
            initializeImageDisplay() {
                appState.currentImageIndex = 0;
                appState.currentStack = 'in';
                
                this.displayTopImageFromStack('in');
                this.updateActiveProxTab();
                this.updateStackCounts();
            },
            
            async displayTopImageFromStack(stackName) {
                if (appState.stacks[stackName].length === 0) {
                    this.showEmptyState();
                    return;
                }
                
                utils.elements.emptyState.classList.add('hidden');
                const topImage = appState.stacks[stackName][0];
                const imageIndex = appState.imageFiles.findIndex(f => f.id === topImage.id);
                
                if (imageIndex !== -1) {
                    appState.currentImageIndex = imageIndex;
                    appState.currentStack = stackName;
                    await this.displayCurrentImage();
                    this.updateActiveProxTab();
                }
            },
            
            async displayCurrentImage() {
                if (appState.imageFiles.length === 0) return;
                
                const currentFile = appState.imageFiles[appState.currentImageIndex];
                if (!currentFile) return;
                
                // Enhanced image loading with race condition prevention
                utils.elements.centerImage.style.opacity = '0.5';
                
                try {
                    await utils.setImageSrc(utils.elements.centerImage, currentFile);
                    utils.elements.centerImage.style.opacity = '1';
                } catch (error) {
                    console.warn('Failed to load image:', error);
                    utils.elements.centerImage.style.opacity = '1';
                }
                
                appState.currentScale = 1;
                appState.panOffset = { x: 0, y: 0 };
                this.applyTransform();
            },
            
            applyTransform() {
                const transform = `scale(${appState.currentScale}) translate(${appState.panOffset.x}px, ${appState.panOffset.y}px)`;
                utils.elements.centerImage.style.transform = transform;
            },
            
            updateActiveProxTab() {
                STACK_TYPES.forEach(stack => {
                    const pill = document.getElementById(`pill-${stack}`);
                    if (pill) pill.classList.remove('active');
                });
                
                const currentPill = document.getElementById(`pill-${appState.currentStack}`);
                if (currentPill) currentPill.classList.add('active');
            },
            
            async moveToStack(targetStack) {
                const currentImage = appState.imageFiles[appState.currentImageIndex];
                const currentStack = currentImage.stack;
                
                if (currentStack === targetStack) {
                    const currentStackArray = appState.stacks[currentStack];
                    const index = currentStackArray.findIndex(img => img.id === currentImage.id);
                    if (index > -1) {
                        currentStackArray.splice(index, 1);
                        currentStackArray.push(currentImage);
                    }
                } else {
                    await masterController.moveFileToStack(currentImage.id, targetStack);
                    
                    const currentStackIndex = appState.stacks[currentStack].findIndex(f => f.id === currentImage.id);
                    if (currentStackIndex !== -1) {
                        appState.stacks[currentStack].splice(currentStackIndex, 1);
                    }
                    appState.stacks[targetStack].unshift(currentImage);
                }
                
                this.updateStackCounts();
                
                if (appState.stacks[appState.currentStack].length === 0) {
                    this.showEmptyState();
                } else {
                    this.moveToNextImage();
                }
            },
            
            async moveToNextImage() {
                const activeStackImages = appState.stacks[appState.currentStack];
                if (activeStackImages.length > 0) {
                    const nextImage = activeStackImages[0];
                    const nextGlobalIndex = appState.imageFiles.findIndex(img => img.id === nextImage.id);
                    if (nextGlobalIndex !== -1) {
                        appState.currentImageIndex = nextGlobalIndex;
                    }
                    await this.displayCurrentImage();
                }
            },
            
            // Enhanced empty state with filename display
            showEmptyState() {
                const currentFile = appState.imageFiles[appState.currentImageIndex];
                
                utils.elements.centerImage.style.opacity = '0';
                setTimeout(() => {
                    utils.elements.centerImage.src = '';
                    utils.elements.centerImage.alt = 'No images in this stack';
                    
                    // Show filename of last image if available
                    if (currentFile && currentFile.name) {
                        utils.elements.emptyFilename.textContent = `Last: ${currentFile.name}`;
                        utils.elements.emptyFilename.classList.remove('hidden');
                    } else {
                        utils.elements.emptyFilename.classList.add('hidden');
                    }
                    
                    utils.elements.emptyState.classList.remove('hidden');
                    utils.elements.centerImage.style.opacity = '1';
                    
                    updateEmptyStateButtons();
                }, 200);
            }
        };

        // ===== Enhanced Grid View with Virtual Scrolling =====
        const gridView = {
            virtualScrollManager: null,
            
            open(stack) {
                utils.showModal('grid-modal');
                utils.elements.gridTitle.textContent = STACK_NAMES[stack] || stack;
                utils.elements.selectAllBtn.textContent = appState.stacks[stack].length;
                
                appState.grid.stack = stack;
                appState.grid.selected = [];
                appState.grid.filtered = [];
                
                this.updateSelectionUI();
                this.setupVirtualScrolling();
                this.populate(stack);
            },
            
            setupVirtualScrolling() {
                if (!this.virtualScrollManager) {
                    this.virtualScrollManager = new VirtualScrollManager(
                        utils.elements.gridContent,
                        CONFIG.VIRTUAL_SCROLL.ITEM_HEIGHT
                    );
                }
            },
            
            close() {
                const selectedImages = appState.grid.selected;
                const hasSelection = selectedImages.length === 1;
                
                utils.hideModal('grid-modal');
                
                if (hasSelection) {
                    const selectedFileId = selectedImages[0];
                    const selectedIndex = appState.imageFiles.findIndex(f => f.id === selectedFileId);
                    if (selectedIndex !== -1) {
                        appState.currentImageIndex = selectedIndex;
                        
                        const currentStackImages = appState.stacks[appState.currentStack];
                        const selectedFile = appState.imageFiles[selectedIndex];
                        const stackIndex = currentStackImages.findIndex(f => f.id === selectedFileId);
                        
                        if (stackIndex !== -1) {
                            const reorderedStack = [
                                ...currentStackImages.slice(stackIndex),
                                ...currentStackImages.slice(0, stackIndex)
                            ];
                            appState.stacks[appState.currentStack] = reorderedStack;
                        }
                        
                        commonFunctions.displayCurrentImage();
                    }
                } else {
                    commonFunctions.displayTopImageFromStack(appState.currentStack);
                }
                
                appState.grid.stack = null;
                appState.grid.selected = [];
                appState.grid.filtered = [];
            },
            
            populate(stack) {
                const filesToShow = appState.grid.filtered.length > 0 ? appState.grid.filtered : appState.stacks[stack];
                const sortedFiles = commonFunctions.sortFiles(filesToShow, 'date-desc');
                
                // Update grid columns based on size setting
                const gridSize = utils.elements.gridSize.value;
                utils.elements.gridContainer.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
                
                // Use virtual scrolling for large datasets
                if (sortedFiles.length > CONFIG.VIRTUAL_SCROLL.BUFFER_SIZE) {
                    this.virtualScrollManager.setItems(sortedFiles);
                } else {
                    this.renderDirectly(sortedFiles);
                }
            },
            
            renderDirectly(files) {
                utils.elements.gridContainer.innerHTML = '';
                utils.elements.virtualGridContainer.style.height = 'auto';
                
                files.forEach((file) => {
                    const div = this.createGridItem(file);
                    utils.elements.gridContainer.appendChild(div);
                });
            },
            
            createGridItem(file) {
                const div = document.createElement('div');
                div.className = 'grid-item';
                div.dataset.fileId = file.id;
                
                const img = document.createElement('img');
                img.className = 'grid-image';
                img.loading = 'lazy';
                
                const imageUrl = utils.generateImageUrl(file);
                img.src = imageUrl;
                img.alt = file.name || 'Image';
                
                img.onerror = () => {
                    img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="150" height="150" viewBox="0 0 150 150" fill="none"%3E%3Crect width="150" height="150" fill="%23E5E7EB"/%3E%3Cpath d="M65 60H85V90H65V60Z" fill="%239CA3AF"/%3E%3Ccircle cx="75" cy="45" r="10" fill="%239CA3AF"/%3E%3C/svg%3E';
                };
                
                div.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    if (appState.grid.selected.length === 1 && 
                        appState.grid.selected[0] === file.id && 
                        utils.elements.gridSize.value === '1') {
                        let viewUrl;
                        if (appState.currentProviderType === 'googledrive') {
                            viewUrl = `https://drive.google.com/file/d/${file.id}/view`;
                        } else {
                            viewUrl = file.downloadUrl || `https://1drv.ms/i/s!${file.id}`;
                        }
                        window.open(viewUrl, '_blank');
                        return;
                    }
                    
                    this.toggleSelection(e, file.id);
                });
                
                div.appendChild(img);
                return div;
            },
            
            toggleSelection(e, fileId) {
                const gridItem = e.currentTarget;
                const index = appState.grid.selected.indexOf(fileId);
                
                if (index === -1) {
                    appState.grid.selected.push(fileId);
                    gridItem.classList.add('selected');
                } else {
                    appState.grid.selected.splice(index, 1);
                    gridItem.classList.remove('selected');
                }
                
                this.updateSelectionUI();
                
                if (appState.grid.selected.length === 1 && utils.elements.gridSize.value === '1') {
                    this.focusOnSelectedItem(appState.grid.selected[0]);
                }
            },
            
            focusOnSelectedItem(fileId) {
                const selectedItem = document.querySelector(`.grid-item[data-file-id="${fileId}"]`);
                if (selectedItem) {
                    selectedItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            },
            
            updateSelectionUI() {
                const count = appState.grid.selected.length;
                const buttons = [
                    utils.elements.tagSelected, 
                    utils.elements.moveSelected, 
                    utils.elements.deleteSelected, 
                    utils.elements.exportSelected, 
                    utils.elements.createFolderSelected,
                    utils.elements.moveToFolderSelected
                ];
                
                utils.elements.selectionText.textContent = `${count} selected`;
                
                buttons.forEach(btn => {
                    if (btn) btn.classList.toggle('hidden', count === 0);
                });
            },
            
            selectAll() {
                const filesToShow = appState.grid.filtered.length > 0 ? appState.grid.filtered : appState.stacks[appState.grid.stack];
                appState.grid.selected = filesToShow.map(file => file.id);
                
                document.querySelectorAll('#grid-container .grid-item').forEach(item => {
                    item.classList.add('selected');
                });
                
                this.updateSelectionUI();
            },
            
            deselectAll() {
                document.querySelectorAll('#grid-container .grid-item').forEach(item => 
                    item.classList.remove('selected')
                );
                appState.grid.selected = [];
                this.updateSelectionUI();
            },
            
            performSearch() {
                const searchCriteria = {
                    tags: utils.elements.searchTags.value.trim(),
                    notes: utils.elements.searchNotes.value.trim(),
                    meta: utils.elements.searchMeta.value.trim()
                };
                
                if (!searchCriteria.tags && !searchCriteria.notes && !searchCriteria.meta) {
                    appState.grid.filtered = [];
                    this.populate(appState.grid.stack);
                    return;
                }
                
                const filteredImages = this.searchImages(searchCriteria);
                appState.grid.filtered = filteredImages;
                this.populate(appState.grid.stack);
            },
            
            searchImages(searchCriteria) {
                const { tags, notes, meta } = searchCriteria;
                
                return appState.stacks[appState.grid.stack].filter(file => {
                    if (tags && !this.matchesWildcard(file.tags?.join(' ') || '', tags)) {
                        return false;
                    }
                    
                    if (notes && !this.matchesWildcard(file.notes || '', notes)) {
                        return false;
                    }
                    
                    if (meta) {
                        const metaText = JSON.stringify(file.extractedMetadata || {});
                        if (!this.matchesWildcard(metaText, meta)) {
                            return false;
                        }
                    }
                    
                    return true;
                });
            },
            
            matchesWildcard(text, pattern) {
                const regexPattern = pattern
                    .replace(/[.*+?^${}()|[\]\\]/g, '\\')
                    .replace(/\\\*/g, '.*')
                    .replace(/\\\?/g, '.');
                
                const regex = new RegExp(regexPattern, 'i');
                return regex.test(text);
            }
        };

        // ===== Enhanced Details Modal =====
        const detailsModal = {
            currentTab: 'info',
            
            show() {
                const currentFile = appState.imageFiles[appState.currentImageIndex];
                if (!currentFile) return;
                
                this.populateAllTabs(currentFile);
                utils.showModal('details-modal');
                this.switchTab('info');
            },
            
            hide() {
                utils.hideModal('details-modal');
            },
            
            switchTab(tabName) {
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tab === tabName);
                });
                
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.toggle('active', content.id === `tab-${tabName}`);
                });
                
                this.currentTab = tabName;
            },
            
            populateAllTabs(file) {
                this.populateInfoTab(file);
                this.populateTagsTab(file);
                this.populateNotesTab(file);
                this.populateMetadataTab(file);
            },
            
            populateInfoTab(file) {
                const filename = file.name || 'Unknown';
                utils.elements.detailFilename.textContent = filename;
                
                if (appState.currentProviderType === 'googledrive') {
                    utils.elements.detailFilenameLink.href = `https://drive.google.com/file/d/${file.id}/view`;
                } else {
                    utils.elements.detailFilenameLink.href = file.downloadUrl || '#';
                }
                utils.elements.detailFilenameLink.style.display = 'inline';
                
                const date = file.modifiedTime ? new Date(file.modifiedTime).toLocaleString() : 
                           file.createdTime ? new Date(file.createdTime).toLocaleString() : 'Unknown';
                utils.elements.detailDate.textContent = date;
                
                const size = file.size ? utils.formatFileSize(file.size) : 'Unknown';
                utils.elements.detailSize.textContent = size;
            },
            
            populateTagsTab(file) {
                const tags = file.tags || [];
                
                utils.elements.detailTags.innerHTML = '';
                
                tags.forEach(tag => {
                    const tagElement = document.createElement('div');
                    tagElement.className = 'tag-item';
                    tagElement.innerHTML = `
                        <span>${tag}</span>
                        <button class="tag-remove" data-tag="${tag}">×</button>
                    `;
                    utils.elements.detailTags.appendChild(tagElement);
                });
                
                const addButton = document.createElement('div');
                addButton.className = 'add-tag-btn';
                addButton.textContent = '+ Add Tag';
                addButton.addEventListener('click', () => this.showAddTagInput());
                utils.elements.detailTags.appendChild(addButton);
                
                utils.elements.detailTags.querySelectorAll('.tag-remove').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const tagToRemove = e.target.dataset.tag;
                        this.removeTag(file, tagToRemove);
                    });
                });
            },
            
            showAddTagInput() {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'tag-input';
                input.placeholder = 'Enter tag name';
                input.style.marginLeft = '8px';
                
                const addButton = utils.elements.detailTags.querySelector('.add-tag-btn');
                addButton.parentNode.insertBefore(input, addButton);
                input.focus();
                
                input.addEventListener('keydown', async (e) => {
                    if (e.key === 'Enter') {
                        const tagName = input.value.trim();
                        if (tagName) {
                            const currentFile = appState.imageFiles[appState.currentImageIndex];
                            try {
                                const currentTags = currentFile.tags || [];
                                const newTags = [...new Set([...currentTags, tagName])];
                                
                                await masterController.updateUserMetadata(currentFile.id, { tags: newTags });
                                appState.tags.add(tagName);
                                
                                this.populateTagsTab(currentFile);
                                input.remove();
                            } catch (error) {
                                utils.showToast('Failed to add tag', 'error', true);
                            }
                        }
                    } else if (e.key === 'Escape') {
                        input.remove();
                    }
                });
                
                input.addEventListener('blur', () => {
                    setTimeout(() => input.remove(), 100);
                });
            },
            
            async removeTag(file, tagToRemove) {
                try {
                    const currentTags = file.tags || [];
                    const newTags = currentTags.filter(tag => tag !== tagToRemove);
                    
                    await masterController.updateUserMetadata(file.id, { tags: newTags });
                    this.populateTagsTab(file);
                } catch (error) {
                    utils.showToast('Failed to remove tag', 'error', true);
                }
            },
            
            populateNotesTab(file) {
                utils.elements.detailNotes.value = file.notes || '';
                
                const newNotesTextarea = utils.elements.detailNotes.cloneNode(true);
                utils.elements.detailNotes.parentNode.replaceChild(newNotesTextarea, utils.elements.detailNotes);
                utils.elements.detailNotes = newNotesTextarea;
                
                utils.elements.detailNotes.addEventListener('blur', async () => {
                    try {
                        await masterController.updateUserMetadata(file.id, { notes: utils.elements.detailNotes.value });
                    } catch (error) {
                        utils.showToast('Failed to save notes', 'error', true);
                    }
                });
                
                // Enhanced star rating setup with proper display
                this.setupStarRating(utils.elements.qualityRating, file.qualityRating || 0, async (rating) => {
                    try {
                        await masterController.updateUserMetadata(file.id, { qualityRating: rating });
                        file.qualityRating = rating; // Update local state immediately
                    } catch (error) {
                        utils.showToast('Failed to save rating', 'error', true);
                    }
                });
                
                this.setupStarRating(utils.elements.contentRating, file.contentRating || 0, async (rating) => {
                    try {
                        await masterController.updateUserMetadata(file.id, { contentRating: rating });
                        file.contentRating = rating; // Update local state immediately
                    } catch (error) {
                        utils.showToast('Failed to save rating', 'error', true);
                    }
                });
            },
            
            // Enhanced star rating system with proper visual feedback
            setupStarRating(container, currentRating, onRatingChange) {
                if (!container) return;
                
                const stars = container.querySelectorAll('.star');
                
                // Clear existing event listeners by cloning
                stars.forEach(star => {
                    const newStar = star.cloneNode(true);
                    star.parentNode.replaceChild(newStar, star);
                });
                
                // Get fresh star references
                const newStars = container.querySelectorAll('.star');
                
                // Set initial rating display
                this.updateStarVisuals(newStars, currentRating);
                
                // Add new event listeners
                newStars.forEach((star, index) => {
                    const rating = index + 1;
                    
                    star.addEventListener('click', async () => {
                        this.updateStarVisuals(newStars, rating);
                        await onRatingChange(rating);
                    });
                    
                    star.addEventListener('mouseenter', () => {
                        this.updateStarVisuals(newStars, rating);
                    });
                    
                    star.addEventListener('mouseleave', () => {
                        this.updateStarVisuals(newStars, currentRating);
                    });
                });
                
                // Update current rating when mouse leaves container
                container.addEventListener('mouseleave', () => {
                    this.updateStarVisuals(newStars, currentRating);
                });
            },
            
            updateStarVisuals(stars, rating) {
                stars.forEach((star, index) => {
                    if (index < rating) {
                        star.classList.add('active', 'filled');
                        star.style.fill = '#fbbf24';
                        star.style.color = '#fbbf24';
                    } else {
                        star.classList.remove('active', 'filled');
                        star.style.fill = '#d1d5db';
                        star.style.color = '#d1d5db';
                    }
                });
            },
            
            populateMetadataTab(file) {
                utils.elements.metadataTable.innerHTML = '';
                
                const metadata = file.extractedMetadata || {};
                
                if (Object.keys(metadata).length === 0) {
                    this.addMetadataRow('Status', 'No embedded metadata found', false);
                    return;
                }
                
                // Enhanced priority fields with more AI parameters
                const priorityFields = [
                    'prompt', 'Prompt', '_prompt',
                    'model', 'Model', 'model_name',
                    'seed', 'Seed',
                    'negative_prompt', 'Negative_Prompt',
                    'steps', 'Steps',
                    'cfg_scale', 'CFG_Scale', 'guidance_scale',
                    'sampler', 'Sampler', 'scheduler',
                    'size', 'resolution',
                    'api_call', 'API_Call'
                ];
                
                priorityFields.forEach(field => {
                    if (metadata[field]) {
                        this.addMetadataRow(field, metadata[field], true);
                    }
                });
                
                const remainingFields = Object.entries(metadata).filter(([key, value]) => 
                    !priorityFields.includes(key) && 
                    !priorityFields.includes(key.toLowerCase()) && 
                    key !== '_dimensions' &&
                    value
                );
                
                if (priorityFields.some(field => metadata[field]) && remainingFields.length > 0) {
                    const separatorRow = document.createElement('tr');
                    separatorRow.innerHTML = `
                        <td colspan="2" style="padding: 8px; background: #f0f0f0; text-align: center; font-size: 12px; color: #666; font-weight: bold;">
                            Other Metadata
                        </td>
                    `;
                    utils.elements.metadataTable.appendChild(separatorRow);
                }
                
                remainingFields.forEach(([key, value]) => {
                    this.addMetadataRow(key, value, false);
                });
                
                // File information section
                if (Object.keys(metadata).length > 0) {
                    const separatorRow = document.createElement('tr');
                    separatorRow.innerHTML = `
                        <td colspan="2" style="padding: 8px; background: #f0f0f0; text-align: center; font-size: 12px; color: #666; font-weight: bold;">
                            File Information
                        </td>
                    `;
                    utils.elements.metadataTable.appendChild(separatorRow);
                }
                
                this.addMetadataRow('File Name', file.name || 'Unknown', false);
                this.addMetadataRow('File Size', file.size ? utils.formatFileSize(file.size) : 'Unknown', false);
                this.addMetadataRow('MIME Type', file.mimeType || 'Unknown', false);
                this.addMetadataRow('Created', file.createdTime ? new Date(file.createdTime).toLocaleString() : 'Unknown', false);
                this.addMetadataRow('Modified', file.modifiedTime ? new Date(file.modifiedTime).toLocaleString() : 'Unknown', false);
                this.addMetadataRow('Provider', appState.currentProviderType === 'googledrive' ? 'Google Drive' : 'OneDrive', false);
                
                if (metadata._dimensions) {
                    this.addMetadataRow('Dimensions', `${metadata._dimensions.width} × ${metadata._dimensions.height}`, false);
                }
            },
            
            addMetadataRow(key, value, needsCopyButton = false) {
                const row = document.createElement('tr');
                
                const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                
                let formattedValue = String(value);
                
                if (formattedValue.length > 200) {
                    formattedValue = formattedValue
                        .replace(/,\s+/g, ',\n')
                        .replace(/\.\s+/g, '.\n')
                        .replace(/;\s+/g, ';\n')
                        .trim();
                } else if (formattedValue.length > 100) {
                    formattedValue = formattedValue.replace(/\s+/g, ' ').trim();
                }
                
                const keyCell = document.createElement('td');
                keyCell.className = 'key-cell';
                keyCell.textContent = formattedKey;
                
                const valueCell = document.createElement('td');
                valueCell.className = 'value-cell';
                
                if (formattedValue.length > 500) {
                    valueCell.style.maxHeight = '120px';
                    valueCell.style.overflowY = 'auto';
                    valueCell.style.fontSize = '12px';
                    valueCell.style.lineHeight = '1.4';
                }
                
                valueCell.textContent = formattedValue;
                
                if (needsCopyButton) {
                    const copyButton = document.createElement('button');
                    copyButton.className = 'copy-button copy-metadata';
                    copyButton.textContent = 'Copy';
                    copyButton.dataset.value = String(value);
                    copyButton.title = `Copy ${formattedKey} to clipboard`;
                    valueCell.appendChild(copyButton);
                }
                
                row.appendChild(keyCell);
                row.appendChild(valueCell);
                utils.elements.metadataTable.appendChild(row);
            },
            
            copyToClipboard(text) {
                navigator.clipboard.writeText(text).then(() => {
                    utils.showToast('📋 Copied to clipboard', 'success', true);
                }).catch(() => {
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    textArea.style.position = 'fixed';
                    textArea.style.opacity = '0';
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        utils.showToast('📋 Copied to clipboard', 'success', true);
                    } catch (err) {
                        utils.showToast('❌ Failed to copy', 'error', true);
                    }
                    document.body.removeChild(textArea);
                });
            }
        };

        // ===== Enhanced Modal Manager with Progress Feedback =====
        const modalManager = {
            currentAction: null,
            
            show(type, options = {}) {
                this.currentAction = type;
                const { title, content, confirmText = 'Confirm', confirmClass = 'btn-primary' } = options;
                
                utils.elements.actionTitle.textContent = title || 'Action';
                utils.elements.actionContent.innerHTML = content || '';
                utils.elements.actionConfirm.textContent = confirmText;
                utils.elements.actionConfirm.className = `btn ${confirmClass}`;
                
                utils.showModal('action-modal');
            },
            
            hide() {
                utils.hideModal('action-modal');
                this.currentAction = null;
            },
            
            setupMoveAction() {
                this.show('move', {
                    title: 'Move to Stack',
                    content: `
                        <div style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 16px;">
                            ${STACK_TYPES.map(stack => 
                                `<button class="move-option" data-stack="${stack}" style="width: 100%; text-align: left; padding: 8px 16px; border-radius: 6px; border: none; background: transparent; cursor: pointer; transition: background-color 0.2s;">${STACK_NAMES[stack]}</button>`
                            ).join('')}
                        </div>
                    `,
                    confirmText: 'Cancel'
                });
                
                document.querySelectorAll('.move-option').forEach(option => {
                    option.addEventListener('click', () => {
                        const targetStack = option.dataset.stack;
                        this.executeMove(targetStack);
                    });
                });
            },
            
            setupTagAction() {
                this.show('tag', {
                    title: 'Add Tags',
                    content: `
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-size: 14px; font-weight: 500; color: #374151; margin-bottom: 4px;">Enter tags (comma separated)</label>
                            <input type="text" id="modal-tag-input" class="tag-input" placeholder="nature, landscape, vacation">
                        </div>
                        <div id="modal-tag-suggestions" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px;">
                            ${Array.from(appState.tags).map(tag => 
                                `<button class="tag-suggestion" data-tag="${tag}" style="background-color: #e5e7eb; color: #374151; padding: 4px 8px; border-radius: 6px; font-size: 12px; cursor: pointer; transition: background-color 0.2s; border: none;">${tag}</button>`
                            ).join('')}
                        </div>
                    `,
                    confirmText: 'Apply'
                });
                
                document.querySelectorAll('.tag-suggestion').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const input = document.getElementById('modal-tag-input');
                        input.value += (input.value ? ', ' : '') + btn.dataset.tag;
                    });
                });
            },
            
            setupDeleteAction() {
                const selectedCount = appState.grid.selected.length;
                const currentStack = appState.grid.stack;
                
                const isTrash = currentStack === 'trash';
                const providerName = appState.currentProviderType === 'googledrive' ? 'Google Drive' : 'OneDrive';
                const message = isTrash ? 
                    `Are you sure you want to move ${selectedCount} image${selectedCount > 1 ? 's' : ''} to ${providerName} trash? They can be recovered from ${providerName}.` :
                    `Are you sure you want to move ${selectedCount} image${selectedCount > 1 ? 's' : ''} to Trash?`;
                
                this.show('delete', {
                    title: 'Confirm Delete',
                    content: `<p style="color: #4b5563; margin-bottom: 16px;">${message}</p>`,
                    confirmText: isTrash ? `Move to ${providerName} Trash` : 'Move to Trash',
                    confirmClass: 'btn-danger'
                });
            },
            
            setupExportAction() {
                this.show('export', {
                    title: 'Export to Spreadsheet',
                    content: `
                        <p style="color: #4b5563; margin-bottom: 16px;">
                            Export ${appState.grid.selected.length} selected image${appState.grid.selected.length > 1 ? 's' : ''} 
                            to a CSV spreadsheet with metadata, tags, notes, and direct image URLs.
                        </p>
                        <div style="background: #f3f4f6; padding: 12px; border-radius: 6px; margin-bottom: 16px;">
                            <strong>Exported data includes:</strong>
                            <ul style="margin: 8px 0; padding-left: 20px; color: #6b7280;">
                                <li>Filename and direct image URL</li>
                                <li>AI prompts in dedicated column</li>
                                <li>File size and dates</li>
                                <li>Tags and notes</li>
                                <li>Quality and content ratings</li>
                                <li>AI model parameters (seed, steps, etc.)</li>
                                <li>Full embedded metadata (JSON)</li>
                                <li>Cloud provider information</li>
                            </ul>
                        </div>
                    `,
                    confirmText: 'Export CSV'
                });
            },
            
            setupCreateFolderAction() {
                this.show('create-folder', {
                    title: 'Create New Folder',
                    content: `
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-size: 14px; font-weight: 500; color: #374151; margin-bottom: 4px;">Folder Name</label>
                            <input type="text" id="modal-folder-name" class="input" placeholder="Enter folder name" style="margin-bottom: 0;">
                        </div>
                        <p style="color: #6b7280; font-size: 13px; margin-bottom: 16px;">
                            This will create a new folder and move ${appState.grid.selected.length} selected image${appState.grid.selected.length > 1 ? 's' : ''} into it.
                            The images will maintain their metadata and be moved to the "in" stack in the new folder.
                        </p>
                    `,
                    confirmText: 'Create & Move'
                });
                
                // Focus the input field
                setTimeout(() => {
                    const input = document.getElementById('modal-folder-name');
                    if (input) input.focus();
                }, 100);
            },
            
            setupMoveToFolderAction() {
                this.show('move-to-folder', {
                    title: 'Move to Different Folder',
                    content: `
                        <p style="color: #4b5563; margin-bottom: 16px;">
                            This will move ${appState.grid.selected.length} image${appState.grid.selected.length > 1 ? 's' : ''} to a different folder. 
                            The images will be removed from this stack and their metadata will move with them.
                        </p>
                        <div style="background: #f3f4f6; padding: 12px; border-radius: 6px; margin-bottom: 16px;">
                            <strong>Note:</strong> After selecting this option, you'll be taken to the folder selection screen where you can choose the destination folder.
                            The selected images will be moved to the "in" stack of the destination folder.
                        </div>
                    `,
                    confirmText: 'Choose Destination Folder'
                });
            },
            
            async executeMove(targetStack) {
                const selectedCount = appState.grid.selected.length;
                
                utils.showProgress('Moving Images', `Moving ${selectedCount} images to ${targetStack}...`);
                
                try {
                    let completed = 0;
                    
                    for (const fileId of appState.grid.selected) {
                        await masterController.moveFileToStack(fileId, targetStack);
                        
                        // Update stacks
                        const file = appState.imageFiles.find(f => f.id === fileId);
                        if (file) {
                            // Remove from current stack
                            const currentStackIndex = appState.stacks[file.stack].findIndex(f => f.id === fileId);
                            if (currentStackIndex !== -1) {
                                appState.stacks[file.stack].splice(currentStackIndex, 1);
                            }
                            // Add to target stack
                            appState.stacks[targetStack].unshift(file);
                        }
                        
                        completed++;
                        utils.updateProgress((completed / selectedCount) * 100, `Moved ${completed} of ${selectedCount} images`);
                    }
                    
                    utils.showToast(`Moved ${selectedCount} images to ${targetStack}`, 'success', true);
                    this.hide();
                    gridView.populate(appState.grid.stack);
                    appState.grid.selected = [];
                    gridView.updateSelectionUI();
                    commonFunctions.updateStackCounts();
                } catch (error) {
                    utils.showToast('Failed to move some images', 'error', true);
                    this.hide();
                } finally {
                    utils.hideProgress();
                }
            },
            
            async executeTag() {
                const tagInput = document.getElementById('modal-tag-input');
                if (!tagInput.value.trim()) return;
                
                const tags = tagInput.value.split(',').map(tag => tag.trim()).filter(tag => tag);
                const selectedCount = appState.grid.selected.length;
                
                utils.showProgress('Adding Tags', `Adding tags to ${selectedCount} images...`);
                
                try {
                    let completed = 0;
                    
                    for (const fileId of appState.grid.selected) {
                        const file = appState.imageFiles.find(f => f.id === fileId);
                        if (file) {
                            const currentTags = file.tags || [];
                            const newTags = [...new Set([...currentTags, ...tags])];
                            
                            await masterController.updateUserMetadata(fileId, { tags: newTags });
                            tags.forEach(tag => appState.tags.add(tag));
                        }
                        
                        completed++;
                        utils.updateProgress((completed / selectedCount) * 100, `Tagged ${completed} of ${selectedCount} images`);
                    }
                    
                    utils.showToast(`Tags added to ${selectedCount} images`, 'success', true);
                    this.hide();
                    gridView.populate(appState.grid.stack);
                } catch (error) {
                    utils.showToast('Failed to add tags', 'error', true);
                } finally {
                    utils.hideProgress();
                }
            },
            
            async executeDelete() {
                const currentStack = appState.grid.stack;
                const selectedCount = appState.grid.selected.length;
                
                utils.showProgress('Deleting Images', `Processing ${selectedCount} images...`);
                
                try {
                    let completed = 0;
                    
                    if (currentStack === 'trash') {
                        for (const fileId of appState.grid.selected) {
                            await masterController.deleteFile(fileId);
                            
                            const fileIndex = appState.imageFiles.findIndex(f => f.id === fileId);
                            if (fileIndex !== -1) appState.imageFiles.splice(fileIndex, 1);
                            const trashIndex = appState.stacks.trash.findIndex(f => f.id === fileId);
                            if (trashIndex !== -1) appState.stacks.trash.splice(trashIndex, 1);
                            
                            completed++;
                            utils.updateProgress((completed / selectedCount) * 100, `Deleted ${completed} of ${selectedCount} images`);
                        }
                        
                        const providerName = appState.currentProviderType === 'googledrive' ? 'Google Drive' : 'OneDrive';
                        utils.showToast(`Moved ${selectedCount} images to ${providerName} trash`, 'success', true);
                    } else {
                        for (const fileId of appState.grid.selected) {
                            await masterController.moveFileToStack(fileId, 'trash');
                            
                            // Update stacks
                            const file = appState.imageFiles.find(f => f.id === fileId);
                            if (file) {
                                const currentStackIndex = appState.stacks[currentStack].findIndex(f => f.id === fileId);
                                if (currentStackIndex !== -1) {
                                    appState.stacks[currentStack].splice(currentStackIndex, 1);
                                }
                                appState.stacks.trash.unshift(file);
                            }
                            
                            completed++;
                            utils.updateProgress((completed / selectedCount) * 100, `Moved ${completed} of ${selectedCount} to trash`);
                        }
                        
                        utils.showToast(`Moved ${selectedCount} images to trash`, 'success', true);
                    }
                    
                    this.hide();
                    gridView.populate(appState.grid.stack);
                    appState.grid.selected = [];
                    gridView.updateSelectionUI();
                    commonFunctions.updateStackCounts();
                } catch (error) {
                    utils.showToast('Failed to delete some images', 'error', true);
                    this.hide();
                } finally {
                    utils.hideProgress();
                }
            },
            
            executeExport() {
                appState.exportSystem.exportSelectedImages(appState.grid.selected);
                this.hide();
            },
            
            executeCreateFolder() {
                const folderNameInput = document.getElementById('modal-folder-name');
                const folderName = folderNameInput?.value.trim();
                
                if (!folderName) {
                    utils.showToast('Please enter a folder name', 'error', true);
                    return;
                }
                
                // For now, show a message that folder creation is not yet implemented
                utils.showToast('Folder creation feature coming soon', 'info', true);
                this.hide();
            },
            
            executeMoveToFolder() {
                appState.folderMoveMode = {
                    active: true,
                    selectedImages: [...appState.grid.selected],
                    sourceStack: appState.grid.stack
                };
                
                this.hide();
                masterController.returnToFolderSelection();
                utils.showToast('Select destination folder for the images', 'info', true);
            }
        };

        // ===== Utility Functions =====
        function updateEmptyStateButtons() {
            const stacksWithImages = STACK_TYPES.filter(stack => appState.stacks[stack].length > 0);
            const hasOtherStacks = stacksWithImages.some(stack => stack !== appState.currentStack);
            
            utils.elements.selectAnotherStackBtn.style.display = hasOtherStacks ? 'block' : 'none';
            utils.elements.selectAnotherFolderBtn.style.display = hasOtherStacks ? 'none' : 'block';
        }
        
        function acknowledgePillCounter(stackName) {
            const pill = document.getElementById(`pill-${stackName}`);
            if (pill) {
                pill.classList.remove('triple-ripple', 'glow-effect');
                pill.offsetHeight;
                pill.classList.add('triple-ripple');
                
                setTimeout(() => {
                    pill.classList.add('glow-effect');
                }, 100);
                
                setTimeout(() => {
                    pill.classList.remove('triple-ripple', 'glow-effect');
                }, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--ripple-duration')) || 1500);
            }
        }
        
        // ===== Enhanced Gesture System =====
        function setupGestureSystem() {
            let startPos = { x: 0, y: 0 };
            let currentPos = { x: 0, y: 0 };
            let gestureStarted = false;
            
            const edgeElements = [utils.elements.edgeTop, utils.elements.edgeBottom, utils.elements.edgeLeft, utils.elements.edgeRight];
            
            function showEdgeGlow(direction) {
                edgeElements.forEach(edge => edge.classList.remove('active'));
                if (utils.elements[`edge${direction.charAt(0).toUpperCase() + direction.slice(1)}`]) {
                    utils.elements[`edge${direction.charAt(0).toUpperCase() + direction.slice(1)}`].classList.add('active');
                }
            }
            
            function hideAllEdgeGlows() {
                edgeElements.forEach(edge => edge.classList.remove('active'));
            }
            
            function determineSwipeDirection(deltaX, deltaY) {
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    return deltaX > 0 ? 'right' : 'left';
                } else {
                    return deltaY > 0 ? 'bottom' : 'top';
                }
            }
            
            function directionToStack(direction) {
                const mapping = {
                    'top': 'priority',
                    'bottom': 'trash',
                    'left': 'in',
                    'right': 'out'
                };
                return mapping[direction];
            }
            
            async function executeFlick(targetStack) {
                const currentImage = appState.imageFiles[appState.currentImageIndex];
                const currentStack = currentImage.stack;
                
                acknowledgePillCounter(targetStack);
                
                // Enhanced haptic feedback with proper timing
                if (appState.hapticManager) {
                    appState.hapticManager.triggerFeedback('swipe');
                }
                
                if (currentStack === targetStack) {
                    const currentStackArray = appState.stacks[currentStack];
                    const index = currentStackArray.findIndex(img => img.id === currentImage.id);
                    if (index > -1) {
                        currentStackArray.splice(index, 1);
                        currentStackArray.push(currentImage);
                    }
                    
                    if (appState.stacks[appState.currentStack].length === 0) {
                        commonFunctions.showEmptyState();
                    } else {
                        commonFunctions.moveToNextImage();
                    }
                    
                    commonFunctions.updateStackCounts();
                    hideAllEdgeGlows();
                    return;
                }
                
                try {
                    await commonFunctions.moveToStack(targetStack);
                    hideAllEdgeGlows();
                } catch (error) {
                    utils.showToast(`Error moving image: ${error.message}`, 'error', true);
                    hideAllEdgeGlows();
                }
            }
            
            utils.elements.imageViewport.addEventListener('mousedown', handleStart);
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('mouseup', handleEnd);
            
            utils.elements.imageViewport.addEventListener('touchstart', handleStart, { passive: false });
            document.addEventListener('touchmove', handleMove, { passive: false });
            document.addEventListener('touchend', handleEnd, { passive: false });
            
            function handleStart(e) {
                if (appState.imageFiles.length === 0) return;
                if (e.touches && (e.touches.length > 1 || appState.isPinching)) return;
                if (appState.currentScale > 1.1) return;
                
                e.preventDefault();
                const point = e.touches ? e.touches[0] : e;
                
                startPos = { x: point.clientX, y: point.clientY };
                currentPos = { x: point.clientX, y: point.clientY };
                gestureStarted = false;
                
                appState.isDragging = true;
                utils.elements.centerImage.classList.add('dragging');
            }
            
            function handleMove(e) {
                if (!appState.isDragging || appState.imageFiles.length === 0) return;
                
                if (e.touches && e.touches.length > 1) {
                    appState.isDragging = false;
                    utils.elements.centerImage.classList.remove('dragging');
                    hideAllEdgeGlows();
                    return;
                }
                
                e.preventDefault();
                const point = e.touches ? e.touches[0] : e;
                
                currentPos = { x: point.clientX, y: point.clientY };
                
                const deltaX = currentPos.x - startPos.x;
                const deltaY = currentPos.y - startPos.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (distance > 30) {
                    gestureStarted = true;
                    const direction = determineSwipeDirection(deltaX, deltaY);
                    if (direction) {
                        hideAllEdgeGlows();
                        showEdgeGlow(direction);
                    }
                } else {
                    hideAllEdgeGlows();
                }
            }
            
            function handleEnd(e) {
                if (!appState.isDragging) return;
                
                e.preventDefault();
                appState.isDragging = false;
                utils.elements.centerImage.classList.remove('dragging');
                
                if (!gestureStarted) {
                    hideAllEdgeGlows();
                    return;
                }
                
                const deltaX = currentPos.x - startPos.x;
                const deltaY = currentPos.y - startPos.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (distance > 80) {
                    const direction = determineSwipeDirection(deltaX, deltaY);
                    const targetStack = directionToStack(direction);
                    if (targetStack && direction) {
                        executeFlick(targetStack);
                        return;
                    }
                }
                
                hideAllEdgeGlows();
            }
        }
        
        // ===== Enhanced Pinch Zoom System =====
        function setupPinchZoom() {
            function getDistance(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            function getCenter(touch1, touch2) {
                return {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
            }
            
            utils.elements.centerImage.addEventListener('touchstart', handleTouchStart, { passive: false });
            utils.elements.centerImage.addEventListener('touchmove', handleTouchMove, { passive: false });
            utils.elements.centerImage.addEventListener('touchend', handleTouchEnd, { passive: false });
            utils.elements.centerImage.addEventListener('wheel', handleWheel, { passive: false });
            
            function handleTouchStart(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    appState.isPinching = true;
                    appState.initialDistance = getDistance(e.touches[0], e.touches[1]);
                    appState.lastTouchPos = getCenter(e.touches[0], e.touches[1]);
                } else if (e.touches.length === 1 && appState.currentScale > 1) {
                    appState.lastTouchPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
            }
            
            function handleTouchMove(e) {
                if (e.touches.length === 2 && appState.isPinching) {
                    e.preventDefault();
                    
                    const currentDistance = getDistance(e.touches[0], e.touches[1]);
                    const scaleFactor = currentDistance / appState.initialDistance;
                    
                    let newScale = appState.currentScale * scaleFactor;
                    newScale = Math.max(appState.minScale, Math.min(appState.maxScale, newScale));
                    
                    appState.currentScale = newScale;
                    appState.initialDistance = currentDistance;
                    
                    commonFunctions.applyTransform();
                } else if (e.touches.length === 1 && appState.currentScale > 1) {
                    e.preventDefault();
                    
                    const deltaX = e.touches[0].clientX - appState.lastTouchPos.x;
                    const deltaY = e.touches[0].clientY - appState.lastTouchPos.y;
                    
                    appState.panOffset.x += deltaX / appState.currentScale;
                    appState.panOffset.y += deltaY / appState.currentScale;
                    
                    appState.lastTouchPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    
                    commonFunctions.applyTransform();
                }
            }
            
            function handleTouchEnd(e) {
                if (e.touches.length < 2) {
                    appState.isPinching = false;
                }
                
                if (appState.currentScale < 1.1) {
                    appState.currentScale = 1;
                    appState.panOffset = { x: 0, y: 0 };
                    commonFunctions.applyTransform();
                }
            }
            
            function handleWheel(e) {
                e.preventDefault();
                
                const scaleChange = e.deltaY > 0 ? 0.9 : 1.1;
                let newScale = appState.currentScale * scaleChange;
                newScale = Math.max(appState.minScale, Math.min(appState.maxScale, newScale));
                
                appState.currentScale = newScale;
                
                if (appState.currentScale <= 1.1) {
                    appState.currentScale = 1;
                    appState.panOffset = { x: 0, y: 0 };
                }
                
                commonFunctions.applyTransform();
            }
        }
        
        // ===== Enhanced Event Handlers =====
        function setupEventHandlers() {
            // Provider selection
            utils.elements.googleDriveBtn.addEventListener('click', () => appController.selectGoogleDrive());
            utils.elements.onedriveBtn.addEventListener('click', () => appController.selectOneDrive());
            
            // Settings
            document.querySelectorAll('.intensity-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    appState.visualCueManager.setIntensity(btn.dataset.level);
                });
            });
            
            document.getElementById('haptic-enabled').addEventListener('change', (e) => {
                appState.hapticManager.setEnabled(e.target.checked);
            });
            
            // Google Drive auth
            utils.elements.gdriveAuthButton.addEventListener('click', async () => {
                const clientSecret = utils.elements.gdriveClientSecret.value.trim();
                
                if (!clientSecret) {
                    utils.elements.gdriveAuthStatus.textContent = 'Please enter client secret';
                    utils.elements.gdriveAuthStatus.className = 'status error';
                    return;
                }
                
                utils.elements.gdriveAuthButton.disabled = true;
                utils.elements.gdriveAuthButton.textContent = 'Connecting...';
                utils.elements.gdriveAuthStatus.textContent = 'Connecting to Google Drive...';
                utils.elements.gdriveAuthStatus.className = 'status info';
                
                try {
                    const provider = new GoogleDriveProvider();
                    const success = await provider.authenticate(clientSecret);
                    
                    if (success) {
                        appState.currentProvider = provider;
                        utils.elements.gdriveAuthStatus.textContent = '✅ Connected to Google Drive!';
                        utils.elements.gdriveAuthStatus.className = 'status success';
                        utils.elements.gdriveClientSecret.value = '';
                        
                        setTimeout(() => {
                            utils.showScreen('gdrive-folder-screen');
                            loadGoogleDriveFolders();
                        }, 1000);
                    }
                } catch (error) {
                    utils.elements.gdriveAuthStatus.textContent = `Authentication failed: ${error.message}`;
                    utils.elements.gdriveAuthStatus.className = 'status error';
                } finally {
                    utils.elements.gdriveAuthButton.disabled = false;
                    utils.elements.gdriveAuthButton.textContent = 'Connect Drive';
                }
            });
            
            utils.elements.gdriveBackButton.addEventListener('click', () => appController.backToProviderSelection());
            
            // OneDrive auth
            utils.elements.onedriveAuthButton.addEventListener('click', async () => {
                utils.elements.onedriveAuthButton.disabled = true;
                utils.elements.onedriveAuthButton.textContent = 'Connecting...';
                utils.elements.onedriveAuthStatus.textContent = 'Connecting to OneDrive...';
                utils.elements.onedriveAuthStatus.className = 'status info';
                
                try {
                    const provider = new OneDriveProvider();
                    const success = await provider.authenticate();
                    
                    if (success) {
                        appState.currentProvider = provider;
                        utils.elements.onedriveAuthStatus.textContent = '✅ Connected to OneDrive!';
                        utils.elements.onedriveAuthStatus.className = 'status success';
                        
                        setTimeout(() => {
                            utils.showScreen('onedrive-folder-screen');
                            loadOneDriveFolders();
                        }, 1000);
                    }
                } catch (error) {
                    utils.elements.onedriveAuthStatus.textContent = `Authentication failed: ${error.message}`;
                    utils.elements.onedriveAuthStatus.className = 'status error';
                } finally {
                    utils.elements.onedriveAuthButton.disabled = false;
                    utils.elements.onedriveAuthButton.textContent = 'Connect OneDrive';
                }
            });
            
            utils.elements.onedriveBackButton.addEventListener('click', () => appController.backToProviderSelection());
            
            // Folder management
            utils.elements.gdriveRefreshFolders.addEventListener('click', () => loadGoogleDriveFolders());
            utils.elements.gdriveBackToProvider.addEventListener('click', () => appController.backToProviderSelection());
            utils.elements.gdriveLogout.addEventListener('click', () => {
                appState.currentProvider.disconnect();
                appController.backToProviderSelection();
            });
            
            utils.elements.onedriveRefreshFolders.addEventListener('click', () => loadOneDriveFolders());
            utils.elements.onedriveBackToProvider.addEventListener('click', () => appController.backToProviderSelection());
            utils.elements.onedriveLogout.addEventListener('click', () => {
                appState.currentProvider.disconnect();
                appController.backToProviderSelection();
            });
            
            // Loading screen cancel
            utils.elements.cancelLoading.addEventListener('click', () => {
                if (appState.metadataExtractor) {
                    appState.metadataExtractor.abort();
                }
                masterController.returnToFolderSelection();
                utils.showToast('Loading cancelled', 'info', true);
                                        img.alt = item.name || 'Image';
                            
                            img.onerror = () => {
                                img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="150" height="150" viewBox="0 0 150 150" fill="none"%3E%3Crect width="150" height="150" fill="%23E5E7EB"/%3E%3Cpath d="M65 60H85V90H65V60Z" fill="%239CA3AF"/%3E%3Ccircle cx="75" cy="45" r="10" fill="%239CA3AF"/%3E%3C/svg%3E';
                            };
                            
                            observer.unobserve(entry.target);
                        }
                    });
                });
                
                observer.observe(img);
                
                div.addEventListener('click', (e) => {
                    e.stopPropagation();
                    gridView.toggleSelection(e, item.id);
                });
                
                div.appendChild(img);
                return div;
            }
            
            scrollToItem(index) {
                const targetScrollTop = index * this.itemHeight;
                this.container.scrollTop = targetScrollTop;
            }
            
            getItemAtPosition(y) {
                return Math.floor(y / this.itemHeight);
            }
        }

        // ===== Enhanced File Cache System =====
        class EnhancedFileCache {
            constructor() {
                this.db = null;
                this.version = CONFIG.CACHE.VERSION;
            }
            
            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('Orbital8EnhancedCache', this.version);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Clear old stores if upgrading
                        if (event.oldVersion < this.version) {
                            const storeNames = Array.from(db.objectStoreNames);
                            storeNames.forEach(name => {
                                db.deleteObjectStore(name);
                            });
                        }
                        
                        if (!db.objectStoreNames.contains('files')) {
                            const fileStore = db.createObjectStore('files', { keyPath: 'folderId' });
                            fileStore.createIndex('folderId', 'folderId', { unique: true });
                        }
                        if (!db.objectStoreNames.contains('metadata')) {
                            db.createObjectStore('metadata', { keyPath: 'id' });
                        }
                        if (!db.objectStoreNames.contains('auth')) {
                            db.createObjectStore('auth', { keyPath: 'provider' });
                        }
                    };
                });
            }
            
            async getCachedFiles(folderId) {
                if (!this.db) return null;
                try {
                    const transaction = this.db.transaction(['files'], 'readonly');
                    const store = transaction.objectStore('files');
                    const result = await new Promise((resolve, reject) => {
                        const request = store.get(folderId);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    if (result && this.isCacheValid(result.cached)) {
                        return result.files;
                    }
                } catch (error) {
                    console.warn('Failed to get cached files:', error);
                }
                return null;
            }
            
            async setCachedFiles(folderId, files) {
                if (!this.db) return;
                try {
                    const transaction = this.db.transaction(['files'], 'readwrite');
                    const store = transaction.objectStore('files');
                    await new Promise((resolve, reject) => {
                        const request = store.put({
                            folderId,
                            files,
                            cached: Date.now()
                        });
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.warn('Failed to cache files:', error);
                }
            }
            
            async getMetadata(fileId, modifiedTime) {
                if (!this.db) return null;
                try {
                    const transaction = this.db.transaction(['metadata'], 'readonly');
                    const store = transaction.objectStore('metadata');
                    const result = await new Promise((resolve, reject) => {
                        const request = store.get(fileId);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    if (result && result.modifiedTime === modifiedTime) {
                        return result.metadata;
                    }
                } catch (error) {
                    console.warn('Failed to get cached metadata:', error);
                }
                return null;
            }
            
            async setMetadata(fileId, modifiedTime, metadata) {
                if (!this.db) return;
                try {
                    const transaction = this.db.transaction(['metadata'], 'readwrite');
                    const store = transaction.objectStore('metadata');
                    await new Promise((resolve, reject) => {
                        const request = store.put({ 
                            id: fileId, 
                            modifiedTime, 
                            metadata,
                            cached: Date.now()
                        });
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.warn('Failed to cache metadata:', error);
                }
            }
            
            // Enhanced auth state persistence
            async saveAuthState(provider, authData) {
                if (!this.db) return;
                try {
                    const transaction = this.db.transaction(['auth'], 'readwrite');
                    const store = transaction.objectStore('auth');
                    await new Promise((resolve, reject) => {
                        const request = store.put({ 
                            provider, 
                            authData,
                            cached: Date.now()
                        });
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.warn('Failed to save auth state:', error);
                }
            }
            
            async getAuthState(provider) {
                if (!this.db) return null;
                try {
                    const transaction = this.db.transaction(['auth'], 'readonly');
                    const store = transaction.objectStore('auth');
                    const result = await new Promise((resolve, reject) => {
                        const request = store.get(provider);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    if (result && this.isCacheValid(result.cached)) {
                        return result.authData;
                    }
                } catch (error) {
                    console.warn('Failed to get auth state:', error);
                }
                return null;
            }
            
            isCacheValid(cachedTime) {
                return (Date.now() - cachedTime) < CONFIG.CACHE.DURATION;
            }
            
            async clearCacheForFolder(folderId) {
                if (!this.db) return;
                try {
                    const transaction = this.db.transaction(['files'], 'readwrite');
                    const store = transaction.objectStore('files');
                    await new Promise((resolve, reject) => {
                        const request = store.delete(folderId);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.warn('Failed to clear cache:', error);
                }
            }
        }

        // ===== Enhanced Progressive Metadata Extractor =====
        class ProgressiveMetadataExtractor {
            constructor() {
                this.abortController = null;
                this.extractionQueue = [];
                this.isProcessing = false;
            }
            
            abort() {
                if (this.abortController) {
                    this.abortController.abort();
                    this.abortController = null;
                }
                this.extractionQueue = [];
                this.isProcessing = false;
            }
            
            // Enhanced PNG metadata extraction with better AI parameter parsing
            async extract(buffer) {
                if (!buffer) return {};
                
                const metadata = {};
                const view = new DataView(buffer);
                
                if (buffer.byteLength < 8) return {};
                
                // Check PNG signature
                const pngSignature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
                for (let i = 0; i < 8; i++) {
                    if (view.getUint8(i) !== pngSignature[i]) {
                        return { error: 'Not a valid PNG file' };
                    }
                }
                
                let pos = 8; // Skip PNG header
                
                try {
                    while (pos < buffer.byteLength - 12) {
                        const chunkLength = view.getUint32(pos, false);
                        pos += 4;
                        
                        let chunkType = '';
                        for (let i = 0; i < 4; i++) {
                            chunkType += String.fromCharCode(view.getUint8(pos + i));
                        }
                        pos += 4;
                        
                        if (chunkType === 'tEXt') {
                            let keyword = '';
                            let value = '';
                            let nullFound = false;
                            
                            for (let i = 0; i < chunkLength; i++) {
                                const byte = view.getUint8(pos + i);
                                
                                if (!nullFound) {
                                    if (byte === 0) {
                                        nullFound = true;
                                    } else {
                                        keyword += String.fromCharCode(byte);
                                    }
                                } else {
                                    value += String.fromCharCode(byte);
                                }
                            }
                            
                            metadata[keyword] = value;
                            
                            // Enhanced AI parameter parsing
                            this.parseAIParameters(keyword, value, metadata);
                            
                        } else if (chunkType === 'IHDR') {
                            const width = view.getUint32(pos, false);
                            const height = view.getUint32(pos + 4, false);
                            metadata._dimensions = { width, height };
                        } else if (chunkType === 'IEND') {
                            break;
                        }
                        
                        pos += chunkLength + 4;
                        
                        if (chunkLength > buffer.byteLength || pos > buffer.byteLength) {
                            break;
                        }
                    }
                } catch (error) {
                    // Return what we have so far
                }
                
                return metadata;
            }
            
            // Enhanced AI parameter parsing for various generators
            parseAIParameters(keyword, value, metadata) {
                const lowerKeyword = keyword.toLowerCase();
                
                // Parse JSON-like parameter strings
                if (value.includes('{') && value.includes('}')) {
                    try {
                        const parsed = JSON.parse(value);
                        Object.assign(metadata, parsed);
                        return;
                    } catch (e) {
                        // Continue with other parsing methods
                    }
                }
                
                // Parse comma-separated parameters (Stable Diffusion style)
                if (value.includes(',') && (lowerKeyword.includes('parameter') || lowerKeyword.includes('prompt'))) {
                    const lines = value.split('\n');
                    lines.forEach(line => {
                        line = line.trim();
                        if (line.includes(':')) {
                            const [key, ...valueParts] = line.split(':');
                            const paramValue = valueParts.join(':').trim();
                            metadata[key.trim()] = paramValue;
                        } else if (line.includes('=')) {
                            const [key, ...valueParts] = line.split('=');
                            const paramValue = valueParts.join('=').trim();
                            metadata[key.trim()] = paramValue;
                        }
                    });
                }
                
                // Extract specific AI model parameters
                if (lowerKeyword.includes('prompt')) {
                    metadata._prompt = value; // Separate field for export
                }
                
                // Parse Midjourney parameters
                if (value.includes('--')) {
                    const params = value.match(/--\w+\s+[^\-]+/g);
                    if (params) {
                        params.forEach(param => {
                            const [flag, ...valueParts] = param.trim().split(/\s+/);
                            metadata[flag.replace('--', '')] = valueParts.join(' ');
                        });
                    }
                }
                
                // Parse key-value pairs
                const kvPattern = /(\w+):\s*([^,\n]+)/g;
                let match;
                while ((match = kvPattern.exec(value)) !== null) {
                    metadata[match[1]] = match[2].trim();
                }
            }
            
            async fetchMetadata(file) {
                if (file.mimeType !== 'image/png') {
                    return { error: 'Not a PNG file' };
                }
                
                try {
                    this.abortController = new AbortController();
                    
                    let response;
                    if (appState.currentProviderType === 'googledrive') {
                        response = await fetch(`https://www.googleapis.com/drive/v3/files/${file.id}?alt=media`, {
                            headers: { 
                                'Authorization': `Bearer ${appState.currentProvider.accessToken}`,
                                'Range': 'bytes=0-65535'
                            },
                            signal: this.abortController.signal
                        });
                    } else {
                        const accessToken = await appState.currentProvider.getAccessToken();
                        response = await fetch(`https://graph.microsoft.com/v1.0/me/drive/items/${file.id}/content`, {
                            headers: { 
                                'Authorization': `Bearer ${accessToken}`,
                                'Range': 'bytes=0-65535'
                            },
                            signal: this.abortController.signal
                        });
                    }
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const buffer = await response.arrayBuffer();
                    return await this.extract(buffer);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        return { error: 'Operation cancelled' };
                    }
                    return { error: error.message };
                }
            }
        }

        // ===== Enhanced Google Drive Provider =====
        class GoogleDriveProvider {
            constructor() {
                this.name = 'googledrive';
                this.clientId = CONFIG.GOOGLE_DRIVE.CLIENT_ID;
                this.redirectUri = window.location.origin + window.location.pathname;
                this.scope = CONFIG.GOOGLE_DRIVE.SCOPE;
                this.apiBase = CONFIG.GOOGLE_DRIVE.API_BASE;
                this.accessToken = null;
                this.refreshToken = null;
                this.clientSecret = null;
                this.isAuthenticated = false;
            }
            
            async loadStoredCredentials() {
                // Try to load from cache first
                const authData = await appState.fileCache.getAuthState('googledrive');
                if (authData) {
                    this.accessToken = authData.accessToken;
                    this.refreshToken = authData.refreshToken;
                    this.clientSecret = authData.clientSecret;
                } else {
                    // Fallback to localStorage
                    this.accessToken = localStorage.getItem('google_access_token');
                    this.refreshToken = localStorage.getItem('google_refresh_token');
                    this.clientSecret = localStorage.getItem('google_client_secret');
                }
                
                this.isAuthenticated = !!(this.accessToken && this.refreshToken && this.clientSecret);
                return this.isAuthenticated;
            }
            
            async storeCredentials() {
                const authData = {
                    accessToken: this.accessToken,
                    refreshToken: this.refreshToken,
                    clientSecret: this.clientSecret
                };
                
                // Store in cache
                await appState.fileCache.saveAuthState('googledrive', authData);
                
                // Also store in localStorage as backup
                if (this.accessToken) localStorage.setItem('google_access_token', this.accessToken);
                if (this.refreshToken) localStorage.setItem('google_refresh_token', this.refreshToken);
                if (this.clientSecret) localStorage.setItem('google_client_secret', this.clientSecret);
            }
            
            clearStoredCredentials() {
                localStorage.removeItem('google_access_token');
                localStorage.removeItem('google_refresh_token');
                localStorage.removeItem('google_client_secret');
            }
            
            async authenticate(clientSecret) {
                if (clientSecret) {
                    this.clientSecret = clientSecret;
                    await this.storeCredentials();
                }
                
                if (!this.clientSecret) {
                    throw new Error('Client secret is required for Google Drive authentication');
                }
                
                // Check existing tokens first
                if (this.accessToken && this.refreshToken) {
                    try {
                        await this.makeApiCall('/files?pageSize=1');
                        this.isAuthenticated = true;
                        return true;
                    } catch (error) {
                        // Token invalid, continue with fresh auth
                    }
                }
                
                return new Promise((resolve, reject) => {
                    const authUrl = this.buildAuthUrl();
                    const popup = window.open(authUrl, 'google-auth', 'width=500,height=600,scrollbars=yes,resizable=yes');
                    
                    if (!popup) {
                        reject(new Error('Popup blocked by browser'));
                        return;
                    }
                    
                    const checkClosed = setInterval(() => {
                        if (popup.closed) {
                            clearInterval(checkClosed);
                            reject(new Error('Authentication cancelled'));
                        }
                    }, 1000);
                    
                    const messageHandler = async (event) => {
                        if (event.origin !== window.location.origin) return;
                        
                        if (event.data.type === 'GOOGLE_AUTH_SUCCESS') {
                            clearInterval(checkClosed);
                            window.removeEventListener('message', messageHandler);
                            popup.close();
                            
                            try {
                                await this.exchangeCodeForTokens(event.data.code);
                                this.isAuthenticated = true;
                                await this.storeCredentials();
                                resolve(true);
                            } catch (error) {
                                reject(error);
                            }
                        } else if (event.data.type === 'GOOGLE_AUTH_ERROR') {
                            clearInterval(checkClosed);
                            window.removeEventListener('message', messageHandler);
                            popup.close();
                            reject(new Error(event.data.error));
                        }
                    };
                    
                    window.addEventListener('message', messageHandler);
                });
            }
            
            buildAuthUrl() {
                const params = new URLSearchParams({
                    client_id: this.clientId,
                    redirect_uri: this.redirectUri,
                    response_type: 'code',
                    scope: this.scope,
                    access_type: 'offline',
                    prompt: 'consent'
                });
                return `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;
            }
            
            async exchangeCodeForTokens(code) {
                const response = await fetch('https://oauth2.googleapis.com/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({
                        client_id: this.clientId,
                        client_secret: this.clientSecret,
                        code: code,
                        grant_type: 'authorization_code',
                        redirect_uri: this.redirectUri
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Token exchange failed');
                }
                
                const tokens = await response.json();
                this.accessToken = tokens.access_token;
                this.refreshToken = tokens.refresh_token;
            }
            
            async refreshAccessToken() {
                if (!this.refreshToken || !this.clientSecret) {
                    throw new Error('No refresh token or client secret available');
                }
                
                const response = await fetch('https://oauth2.googleapis.com/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({
                        client_id: this.clientId,
                        client_secret: this.clientSecret,
                        refresh_token: this.refreshToken,
                        grant_type: 'refresh_token'
                    })
                });
                
                if (!response.ok) {
                    // Refresh token expired, need re-authentication
                    this.isAuthenticated = false;
                    this.clearStoredCredentials();
                    throw new Error('Refresh token expired. Please reconnect.');
                }
                
                const tokens = await response.json();
                this.accessToken = tokens.access_token;
                await this.storeCredentials();
                return this.accessToken;
            }
            
            async makeApiCall(endpoint, options = {}) {
                if (!this.accessToken) {
                    throw new Error('Not authenticated');
                }
                
                const url = `${this.apiBase}${endpoint}`;
                const headers = {
                    'Authorization': `Bearer ${this.accessToken}`,
                    'Content-Type': 'application/json',
                    ...options.headers
                };
                
                let response = await fetch(url, { ...options, headers });
                
                if (response.status === 401 && this.refreshToken && this.clientSecret) {
                    try {
                        await this.refreshAccessToken();
                        headers['Authorization'] = `Bearer ${this.accessToken}`;
                        response = await fetch(url, { ...options, headers });
                    } catch (refreshError) {
                        this.isAuthenticated = false;
                        this.clearStoredCredentials();
                        throw new Error('Authentication expired. Please reconnect.');
                    }
                }
                
                if (!response.ok) {
                    throw new Error(`API call failed: ${response.statusText}`);
                }
                
                return await response.json();
            }
            
            async getFolders() {
                const response = await this.makeApiCall('/files?q=mimeType%3D%27application/vnd.google-apps.folder%27&fields=files(id,name,createdTime,modifiedTime)&orderBy=modifiedTime%20desc');
                return response.files.map(folder => ({
                    id: folder.id,
                    name: folder.name,
                    type: 'folder',
                    createdTime: folder.createdTime,
                    modifiedTime: folder.modifiedTime
                }));
            }
            
            // Enhanced getFiles with better pagination and error handling
            async getFiles(folderId = 'root') {
                const allFiles = [];
                let nextPageToken = null;
                let retryCount = 0;
                const maxRetries = 3;
                
                do {
                    try {
                        const query = `'${folderId}' in parents and trashed=false and (mimeType contains 'image/')`;
                        let url = `/files?q=${encodeURIComponent(query)}&fields=files(id,name,mimeType,size,createdTime,modifiedTime,thumbnailLink,webContentLink,appProperties),nextPageToken&pageSize=100`;
                        
                        if (nextPageToken) {
                            url += `&pageToken=${nextPageToken}`;
                        }
                        
                        const response = await this.makeApiCall(url);
                        
                        const files = response.files
                            .filter(file => file.mimeType && file.mimeType.startsWith('image/'))
                            .map(file => ({
                                id: file.id,
                                name: file.name,
                                type: 'file',
                                mimeType: file.mimeType,
                                size: file.size ? parseInt(file.size) : 0,
                                createdTime: file.createdTime,
                                modifiedTime: file.modifiedTime,
                                thumbnailLink: file.thumbnailLink,
                                downloadUrl: file.webContentLink,
                                appProperties: file.appProperties || {}
                            }));
                        
                        allFiles.push(...files);
                        nextPageToken = response.nextPageToken;
                        
                        if (this.onProgressCallback) {
                            this.onProgressCallback(allFiles.length);
                        }
                        
                        retryCount = 0; // Reset retry count on success
                        
                    } catch (error) {
                        retryCount++;
                        if (retryCount >= maxRetries) {
                            throw error;
                        }
                        
                        // Wait before retrying
                        await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    }
                    
                } while (nextPageToken);
                
                return { folders: [], files: allFiles };
            }
            
            async moveFileToStack(fileId, targetStack) {
                await this.makeApiCall(`/files/${fileId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({
                        appProperties: { slideboxStack: targetStack }
                    })
                });
                return true;
            }
            
            async updateFileProperties(fileId, properties) {
                await this.makeApiCall(`/files/${fileId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({
                        appProperties: properties
                    })
                });
                return true;
            }
            
            async deleteFile(fileId) {
                await this.makeApiCall(`/files/${fileId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({ trashed: true })
                });
                return true;
            }
            
            async disconnect() {
                this.isAuthenticated = false;
                this.accessToken = null;
                this.refreshToken = null;
                this.clientSecret = null;
                this.clearStoredCredentials();
            }
        }

        // ===== Enhanced OneDrive Provider with Fixed Pagination =====
        class OneDriveProvider {
            constructor() {
                this.name = 'onedrive';
                this.apiBase = CONFIG.ONEDRIVE.API_BASE;
                this.isAuthenticated = false;
                this.activeAccount = null;
                this.msalInstance = null;
                this.currentParentId = null;
                this.currentParentPath = '';
                this.breadcrumb = [];
                this.metadataManager = null;
                this.initMSAL();
            }
            
            initMSAL() {
                const msalConfig = {
                    auth: {
                        clientId: CONFIG.ONEDRIVE.CLIENT_ID,
                        authority: CONFIG.ONEDRIVE.AUTHORITY,
                        redirectUri: window.location.origin + window.location.pathname
                    },
                    cache: { cacheLocation: 'sessionStorage' }
                };
                this.msalInstance = new msal.PublicClientApplication(msalConfig);
            }
            
            async loadStoredCredentials() {
                // Try to get existing account
                const accounts = this.msalInstance.getAllAccounts();
                if (accounts.length > 0) {
                    this.activeAccount = accounts[0];
                    this.msalInstance.setActiveAccount(this.activeAccount);
                    
                    // Test if token is still valid
                    try {
                        await this.getAccessToken();
                        this.isAuthenticated = true;
                        this.metadataManager = new OneDriveMetadataManager(this);
                        return true;
                    } catch (error) {
                        // Token expired or invalid
                        this.isAuthenticated = false;
                    }
                }
                return false;
            }
            
            async authenticate() {
                try {
                    const loginResponse = await this.msalInstance.loginPopup({
                        scopes: ['Files.ReadWrite.AppFolder', 'User.Read']
                    });
                    this.activeAccount = loginResponse.account;
                    this.msalInstance.setActiveAccount(this.activeAccount);
                    this.isAuthenticated = true;
                    
                    // Initialize metadata manager
                    this.metadataManager = new OneDriveMetadataManager(this);
                    
                    return true;
                } catch (error) {
                    this.isAuthenticated = false;
                    throw new Error(`Authentication failed: ${error.message}`);
                }
            }
            
            async getAccessToken() {
                if (!this.activeAccount) {
                    throw new Error('No active account');
                }
                
                try {
                    const response = await this.msalInstance.acquireTokenSilent({
                        scopes: ['Files.ReadWrite.AppFolder'],
                        account: this.activeAccount
                    });
                    return response.accessToken;
                } catch (silentError) {
                    const response = await this.msalInstance.acquireTokenPopup({
                        scopes: ['Files.ReadWrite.AppFolder'],
                        account: this.activeAccount
                    });
                    return response.accessToken;
                }
            }
            
            async makeApiCall(endpoint, options = {}) {
                const accessToken = await this.getAccessToken();
                const url = endpoint.startsWith('http') ? endpoint : `${this.apiBase}${endpoint}`;
                const headers = {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json',
                    ...options.headers
                };
                
                const response = await fetch(url, { ...options, headers });
                
                if (!response.ok) {
                    throw new Error(`API call failed: ${response.statusText}`);
                }
                
                return response;
            }
            
            async getDownloadsFolder() {
                try {
                    const response = await this.makeApiCall('/me/drive/root/children');
                    const data = await response.json();
                    
                    const downloadsFolder = data.value.find(item => 
                        item.folder && 
                        (item.name.toLowerCase() === 'downloads' || item.name.toLowerCase() === 'download')
                    );
                    
                    if (downloadsFolder) {
                        return downloadsFolder;
                    }
                    
                    return {
                        id: 'root',
                        name: 'Root',
                        folder: true
                    };
                } catch (error) {
                    console.warn('Could not find Downloads folder, using root:', error);
                    return {
                        id: 'root',
                        name: 'Root', 
                        folder: true
                    };
                }
            }
            
            async getFolders() {
                try {
                    const downloadsFolder = await this.getDownloadsFolder();
                    
                    this.currentParentId = downloadsFolder.id;
                    this.currentParentPath = downloadsFolder.name;
                    this.breadcrumb = [{ id: downloadsFolder.id, name: downloadsFolder.name }];
                    
                    return await this.loadFoldersInParent(downloadsFolder.id);
                } catch (error) {
                    console.warn('Failed to load initial folders:', error);
                    return [];
                }
            }
            
            async loadFoldersInParent(parentId) {
                try {
                    const folders = [];
                    let nextLink = null;
                    
                    const endpoint = parentId === 'root' ? 
                        '/me/drive/root/children' : 
                        `/me/drive/items/${parentId}/children`;
                    
                    do {
                        const response = nextLink ? 
                            await this.makeApiCall(nextLink) :
                            await this.makeApiCall(endpoint);
                        
                        const data = await response.json();
                        
                        const folderItems = data.value
                            .filter(item => item.folder)
                            .map(folder => ({
                                id: folder.id,
                                name: folder.name,
                                type: 'folder',
                                createdTime: folder.createdDateTime,
                                modifiedTime: folder.lastModifiedDateTime,
                                itemCount: folder.folder.childCount || 0,
                                hasChildren: (folder.folder.childCount || 0) > 0
                            }));
                        
                        folders.push(...folderItems);
                        nextLink = data['@odata.nextLink'];
                        
                    } while (nextLink);
                    
                    return folders.sort((a, b) => a.name.localeCompare(b.name));
                    
                } catch (error) {
                    console.warn('Failed to load folders:', error);
                    return [];
                }
            }
            
            async drillIntoFolder(folder) {
                try {
                    this.breadcrumb.push({ id: folder.id, name: folder.name });
                    this.currentParentId = folder.id;
                    this.currentParentPath = this.breadcrumb.map(b => b.name).join(' / ');
                    
                    return await this.loadFoldersInParent(folder.id);
                } catch (error) {
                    console.warn('Failed to drill into folder:', error);
                    return [];
                }
            }
            
            async navigateToParent() {
                if (this.breadcrumb.length <= 1) {
                    return await this.getFolders();
                }
                
                this.breadcrumb.pop();
                const parentFolder = this.breadcrumb[this.breadcrumb.length - 1];
                
                this.currentParentId = parentFolder.id;
                this.currentParentPath = this.breadcrumb.map(b => b.name).join(' / ');
                
                return await this.loadFoldersInParent(parentFolder.id);
            }
            
            getCurrentPath() {
                return this.currentParentPath;
            }
            
            canGoUp() {
                return this.breadcrumb.length > 1;
            }
            
            // Fixed pagination for OneDrive file loading
            async getFiles(folderId = 'root') {
                const allFiles = [];
                let nextLink = null;
                let endpoint = folderId === 'root' ? 
                    '/me/drive/root/children' : 
                    `/me/drive/items/${folderId}/children`;
                
                let retryCount = 0;
                const maxRetries = 3;
                
                do {
                    try {
                        const response = nextLink ? 
                            await this.makeApiCall(nextLink) :
                            await this.makeApiCall(endpoint);
                        
                        const data = await response.json();
                        
                        const files = data.value
                            .filter(item => item.file && item.file.mimeType && item.file.mimeType.startsWith('image/'))
                            .map(item => ({
                                id: item.id,
                                name: item.name,
                                type: 'file',
                                mimeType: item.file.mimeType,
                                size: item.size || 0,
                                createdTime: item.createdDateTime,
                                modifiedTime: item.lastModifiedDateTime,
                                thumbnails: item.thumbnails && item.thumbnails.length > 0 ? {
                                    large: item.thumbnails[0].large
                                } : null,
                                downloadUrl: item['@microsoft.graph.downloadUrl']
                            }));
                        
                        allFiles.push(...files);
                        nextLink = data['@odata.nextLink'];
                        
                        if (this.onProgressCallback) {
                            this.onProgressCallback(allFiles.length);
                        }
                        
                        retryCount = 0; // Reset retry count on success
                        
                    } catch (error) {
                        retryCount++;
                        if (retryCount >= maxRetries) {
                            throw error;
                        }
                        
                        // Wait before retrying
                        await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    }
                    
                } while (nextLink);
                
                return { folders: [], files: allFiles };
            }
            
            async deleteFile(fileId) {
                await this.makeApiCall(`/me/drive/items/${fileId}`, {
                    method: 'DELETE'
                });
                return true;
            }
            
            async disconnect() {
                this.isAuthenticated = false;
                this.activeAccount = null;
                this.metadataManager = null;
                if (this.msalInstance) {
                    await this.msalInstance.logoutPopup();
                }
            }
        }

        // ===== Enhanced OneDrive Metadata Manager =====
        class OneDriveMetadataManager {
            constructor(oneDriveProvider) {
                this.provider = oneDriveProvider;
                this.cache = new Map();
                this.cacheTimestamp = 0;
                this.cacheExpiry = 5 * 60 * 1000; // 5 minutes
            }
            
            async loadMetadata() {
                try {
                    const now = Date.now();
                    if (this.cache.size > 0 && (now - this.cacheTimestamp) < this.cacheExpiry) {
                        return this.cache;
                    }
                    
                    const response = await this.provider.makeApiCall('/me/drive/special/approot:/tags.json:/content');
                    const data = await response.json();
                    
                    if (data && data.files) {
                        this.cache.clear();
                        Object.entries(data.files).forEach(([fileId, metadata]) => {
                            this.cache.set(fileId, metadata);
                        });
                        this.cacheTimestamp = now;
                    }
                    
                    return this.cache;
                } catch (error) {
                    if (error.message.includes('404')) {
                        await this.saveMetadata();
                        return this.cache;
                    }
                    console.warn('Failed to load user metadata:', error);
                    return this.cache;
                }
            }
            
            async saveMetadata() {
                try {
                    const data = {
                        version: 1,
                        lastModified: new Date().toISOString(),
                        files: Object.fromEntries(this.cache)
                    };
                    
                    await this.provider.makeApiCall('/me/drive/special/approot:/tags.json:/content', {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data, null, 2)
                    });
                    
                    this.cacheTimestamp = Date.now();
                } catch (error) {
                    console.warn('Failed to save user metadata:', error);
                    throw error;
                }
            }
            
            getUserMetadata(fileId) {
                return this.cache.get(fileId) || {
                    stack: 'in',
                    tags: [],
                    qualityRating: 0,
                    contentRating: 0,
                    notes: ''
                };
            }
            
            async setUserMetadata(fileId, metadata) {
                const updated = {
                    ...metadata,
                    lastUpdated: new Date().toISOString()
                };
                
                this.cache.set(fileId, updated);
                await this.saveMetadata();
                return updated;
            }
            
            async updateUserMetadata(fileId, updates) {
                const current = this.getUserMetadata(fileId);
                const updated = { ...current, ...updates };
                return await this.setUserMetadata(fileId, updated);
            }
        }

        // ===== Enhanced Export System with Prompt Column =====
        class ExportSystem {
            async exportSelectedImages(imageIds) {
                if (imageIds.length === 0) {
                    utils.showToast('No images selected for export', 'info', true);
                    return;
                }
                
                utils.showProgress('Preparing Export', 'Processing selected images...');
                
                try {
                    const images = imageIds.map(id => appState.imageFiles.find(f => f.id === id)).filter(f => f);
                    const csvData = this.formatForCSV(images);
                    this.downloadCSV(csvData, `orbital8-export-${new Date().toISOString().split('T')[0]}.csv`);
                    
                    utils.showToast(`Exported ${images.length} images to spreadsheet`, 'success', true);
                } finally {
                    utils.hideProgress();
                }
            }
            
            // Enhanced CSV formatting with separate prompt column
            formatForCSV(images) {
                const headers = [
                    'Filename',
                    'Direct Image URL', 
                    'Size',
                    'Created Date',
                    'Modified Date',
                    'AI Prompt', // Separate column for prompts
                    'Tags',
                    'Notes',
                    'Quality Rating',
                    'Content Rating',
                    'Provider',
                    'Stack',
                    'AI Model',
                    'Seed',
                    'Steps',
                    'CFG Scale',
                    'Sampler',
                    'Negative Prompt',
                    'Full Metadata (JSON)'
                ];
                
                const rows = images.map(image => [
                    image.name || '',
                    this.getDirectImageURL(image),
                    this.formatFileSize(image.size || 0),
                    image.createdTime ? new Date(image.createdTime).toISOString() : '',
                    image.modifiedTime ? new Date(image.modifiedTime).toISOString() : '',
                    this.extractPrompt(image.extractedMetadata || {}), // Extract prompt separately
                    (image.tags || []).join('; '),
                    image.notes || '',
                    image.qualityRating || 0,
                    image.contentRating || 0,
                    appState.currentProviderType || 'unknown',
                    image.stack || 'in',
                    this.extractAIModel(image.extractedMetadata || {}),
                    this.extractMetadataField(image.extractedMetadata || {}, ['seed', 'Seed']),
                    this.extractMetadataField(image.extractedMetadata || {}, ['steps', 'Steps']),
                    this.extractMetadataField(image.extractedMetadata || {}, ['cfg_scale', 'CFG_Scale', 'guidance_scale']),
                    this.extractMetadataField(image.extractedMetadata || {}, ['sampler', 'Sampler', 'scheduler']),
                    this.extractMetadataField(image.extractedMetadata || {}, ['negative_prompt', 'Negative_Prompt']),
                    JSON.stringify(image.extractedMetadata || {})
                ]);
                
                return [headers, ...rows];
            }
            
            extractPrompt(metadata) {
                // Look for prompt in various fields
                const promptFields = ['_prompt', 'prompt', 'Prompt', 'parameters', 'positive_prompt'];
                for (const field of promptFields) {
                    if (metadata[field]) {
                        return String(metadata[field]).replace(/[\r\n]+/g, ' ').trim();
                    }
                }
                return '';
            }
            
            extractAIModel(metadata) {
                const modelFields = ['model', 'Model', 'model_name', 'checkpoint'];
                for (const field of modelFields) {
                    if (metadata[field]) {
                        return String(metadata[field]);
                    }
                }
                return '';
            }
            
            extractMetadataField(metadata, fieldNames) {
                for (const field of fieldNames) {
                    if (metadata[field] !== undefined && metadata[field] !== null) {
                        return String(metadata[field]);
                    }
                }
                return '';
            }
            
            getDirectImageURL(image) {
                if (appState.currentProviderType === 'googledrive') {
                    return `https://drive.google.com/uc?id=${image.id}&export=view`;
                } else if (appState.currentProviderType === 'onedrive') {
                    // For OneDrive, provide both download URL and direct link
                    return image.downloadUrl || `https://1drv.ms/i/s!${image.id}`;
                }
                return '';
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            downloadCSV(data, filename) {
                const csvContent = data.map(row => 
                    row.map(field => {
                        // Enhanced CSV escaping
                        const str = String(field || '');
                        if (str.includes('"') || str.includes(',') || str.includes('\n') || str.includes('\r')) {
                            return `"${str.replace(/"/g, '""')}"`;
                        }
                        return str;
                    }).join(',')
                ).join('\n');
                
                // Add BOM for better Excel compatibility
                const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                URL.revokeObjectURL(url);
            }
        }

        // Handle OAuth callback for Google Drive
        if (window.location.search.includes('code=') || window.location.search.includes('error=')) {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const error = urlParams.get('error');
            
            if (window.opener) {
                if (error) {
                    window.opener.postMessage({ type: 'GOOGLE_AUTH_ERROR', error: error }, window.location.origin);
                } else if (code) {
                    window.opener.postMessage({ type: 'GOOGLE_AUTH_SUCCESS', code: code }, window.location.origin);
                }
                window.close();
            }
        }

        // ===== App Controller =====
        const appController = {
            selectGoogleDrive() {
                appState.currentProviderType = 'googledrive';
                utils.showScreen('gdrive-auth-screen');
            },
            
            selectOneDrive() {
                appState.currentProviderType = 'onedrive';
                utils.showScreen('onedrive-auth-screen');
            },
            
            backToProviderSelection() {
                appState.currentProvider = null;
                appState.currentProviderType = null;
                utils.showScreen('provider-screen');
            }
        };

        // ===== Enhanced Master Controller =====
        const masterController = {
            async initializeWithProvider(providerType, folderId, folderName, providerInstance) {
                appState.currentProviderType = providerType;
                appState.currentProvider = providerInstance;
                appState.currentFolder.id = folderId;
                appState.currentFolder.name = folderName;
                
                await this.loadImages();
                this.switchToCommonUI();
            },
            
            async loadImages() {
                utils.showScreen('loading-screen');
                utils.updateLoadingProgress(0, 0);
                
                appState.currentProvider.onProgressCallback = (count) => {
                    utils.updateLoadingProgress(count, 0);
                };
                
                try {
                    // Check cache first
                    const cachedFiles = await appState.fileCache.getCachedFiles(appState.currentFolder.id);
                    
                    if (cachedFiles) {
                        utils.elements.loadingMessage.textContent = 'Loading from cache...';
                        
                        const files = cachedFiles;
                        if (files.length === 0) {
                            utils.showToast('No images found in this folder', 'info', true);
                            this.returnToFolderSelection();
                            return;
                        }
                        
                        utils.updateLoadingProgress(files.length, files.length);
                        utils.elements.loadingMessage.textContent = 'Processing cached images...';
                        
                        appState.imageFiles = files.map(file => this.processFileWithProviderMetadata(file));
                        
                    } else {
                        utils.elements.loadingMessage.textContent = `Loading images from ${appState.currentProviderType}...`;
                        
                        // Load user metadata if OneDrive
                        if (appState.currentProviderType === 'onedrive' && appState.currentProvider.metadataManager) {
                            await appState.currentProvider.metadataManager.loadMetadata();
                        }
                        
                        const result = await appState.currentProvider.getFiles(appState.currentFolder.id);
                        const files = result.files || [];
                        
                        if (files.length === 0) {
                            utils.showToast('No images found in this folder', 'info', true);
                            this.returnToFolderSelection();
                            return;
                        }
                        
                        utils.updateLoadingProgress(files.length, files.length);
                        utils.elements.loadingMessage.textContent = 'Processing files...';
                        
                        appState.imageFiles = files.map(file => this.processFileWithProviderMetadata(file));
                        
                        await appState.fileCache.setCachedFiles(appState.currentFolder.id, appState.imageFiles);
                        
                        const pngCount = files.filter(f => f.mimeType === 'image/png').length;
                        
                        if (pngCount > 0) {
                            this.extractMetadataInBackground(appState.imageFiles.filter(f => f.mimeType === 'image/png'));
                        }
                    }
                    
                    // Initialize stacks and display
                    commonFunctions.initializeStacks();
                    commonFunctions.initializeImageDisplay();
                    
                } catch (error) {
                    utils.showToast('Error loading images', 'error', true);
                    this.returnToFolderSelection();
                } finally {
                    if (appState.currentProvider) {
                        appState.currentProvider.onProgressCallback = null;
                    }
                }
            },
            
            processFileWithProviderMetadata(file) {
                let userMetadata;
                
                if (appState.currentProviderType === 'googledrive') {
                    userMetadata = {
                        stack: file.appProperties?.slideboxStack || 'in',
                        tags: file.appProperties?.slideboxTags ? file.appProperties.slideboxTags.split(',').map(t => t.trim()) : [],
                        qualityRating: parseInt(file.appProperties?.qualityRating) || 0,
                        contentRating: parseInt(file.appProperties?.contentRating) || 0,
                        notes: file.appProperties?.notes || ''
                    };
                } else {
                    userMetadata = appState.currentProvider.metadataManager ? 
                        appState.currentProvider.metadataManager.getUserMetadata(file.id) :
                        { stack: 'in', tags: [], qualityRating: 0, contentRating: 0, notes: '' };
                }
                
                return {
                    id: file.id,
                    name: file.name,
                    filename: file.name,
                    originalName: file.name,
                    mimeType: file.mimeType,
                    size: file.size,
                    createdTime: file.createdTime,
                    modifiedTime: file.modifiedTime,
                    thumbnails: file.thumbnails,
                    downloadUrl: file.downloadUrl,
                    extractedMetadata: file.extractedMetadata || {},
                    
                    // User metadata
                    stack: userMetadata.stack || 'in',
                    tags: userMetadata.tags || [],
                    qualityRating: userMetadata.qualityRating || 0,
                    contentRating: userMetadata.contentRating || 0,
                    notes: userMetadata.notes || ''
                };
            },
            
            switchToCommonUI() {
                utils.showScreen('app-container');
                this.setupProviderAwareNavigation();
            },
            
            setupProviderAwareNavigation() {
                utils.elements.backButton.textContent = '← Folders';
                utils.elements.backButton.onclick = () => this.returnToFolderSelection();
                
                // Setup folder tooltips
                this.setupFolderTooltips();
            },
            
            setupFolderTooltips() {
                utils.elements.backButton.addEventListener('mouseenter', () => {
                    const folderName = appState.currentFolder.name || 'Unknown';
                    const imageCount = appState.imageFiles.length;
                    const provider = appState.currentProviderType === 'googledrive' ? 'Google Drive' : 'OneDrive';
                    this.showTooltip(utils.elements.backButton, `${provider}: ${folderName} • ${imageCount} images`);
                });
                
                utils.elements.backButton.addEventListener('mouseleave', this.hideTooltip);
            },
            
            showTooltip(element, text) {
                const existingTooltip = document.querySelector('.folder-tooltip');
                if (existingTooltip) existingTooltip.remove();
                
                const tooltip = document.createElement('div');
                tooltip.className = 'folder-tooltip';
                tooltip.textContent = text;
                
                document.body.appendChild(tooltip);
                
                const rect = element.getBoundingClientRect();
                tooltip.style.left = `${rect.left}px`;
                tooltip.style.top = `${rect.bottom + 8}px`;
                
                const tooltipRect = tooltip.getBoundingClientRect();
                if (tooltipRect.right > window.innerWidth) {
                    tooltip.style.left = `${window.innerWidth - tooltipRect.width - 10}px`;
                }
            },
            
            hideTooltip() {
                const tooltip = document.querySelector('.folder-tooltip');
                if (tooltip) tooltip.remove();
            },
            
            returnToFolderSelection() {
                if (appState.currentProviderType === 'googledrive') {
                    utils.showScreen('gdrive-folder-screen');
                } else if (appState.currentProviderType === 'onedrive') {
                    utils.showScreen('onedrive-folder-screen');
                }
            },
            
            async moveFileToStack(fileId, targetStack) {
                const file = appState.imageFiles.find(f => f.id === fileId);
                if (!file) throw new Error('File not found');
                
                file.stack = targetStack;
                
                // Provider-specific persistence
                if (appState.currentProviderType === 'googledrive') {
                    await appState.currentProvider.moveFileToStack(fileId, targetStack);
                } else {
                    await appState.currentProvider.metadataManager.updateUserMetadata(fileId, { stack: targetStack });
                }
                
                return file;
            },
            
            async updateUserMetadata(fileId, updates) {
                const file = appState.imageFiles.find(f => f.id === fileId);
                if (!file) throw new Error('File not found');
                
                Object.assign(file, updates);
                
                // Provider-specific persistence
                if (appState.currentProviderType === 'googledrive') {
                    const properties = {};
                    if (updates.stack) properties.slideboxStack = updates.stack;
                    if (updates.tags) properties.slideboxTags = updates.tags.join(',');
                    if (updates.qualityRating !== undefined) properties.qualityRating = updates.qualityRating.toString();
                    if (updates.contentRating !== undefined) properties.contentRating = updates.contentRating.toString();
                    if (updates.notes !== undefined) properties.notes = updates.notes;
                    
                    await appState.currentProvider.updateFileProperties(fileId, properties);
                } else {
                    await appState.currentProvider.metadataManager.updateUserMetadata(fileId, updates);
                }
            },
            
            async deleteFile(fileId) {
                return await appState.currentProvider.deleteFile(fileId);
            },
            
            async extractMetadataInBackground(pngFiles) {
                const BATCH_SIZE = CONFIG.PERFORMANCE.BATCH_SIZE;
                let extractedCount = 0;
                let cachedCount = 0;
                
                for (let i = 0; i < pngFiles.length; i += BATCH_SIZE) {
                    const batch = pngFiles.slice(i, i + BATCH_SIZE);
                    const batchPromises = batch.map(file => this.processFileMetadata(file));
                    
                    try {
                        const results = await Promise.allSettled(batchPromises);
                        results.forEach((result) => {
                            if (result.status === 'fulfilled') {
                                if (result.value.extracted) extractedCount++;
                                if (result.value.cached) cachedCount++;
                            }
                        });
                        
                        await appState.fileCache.setCachedFiles(appState.currentFolder.id, appState.imageFiles);
                        
                        if (i + BATCH_SIZE < pngFiles.length) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                        
                    } catch (error) {
                        console.warn('Batch processing error:', error);
                    }
                }
            },
            
            async processFileMetadata(file) {
                if (file.mimeType !== 'image/png') {
                    return { extracted: false, cached: false };
                }
                
                const cachedMetadata = await appState.fileCache.getMetadata(file.id, file.modifiedTime);
                if (cachedMetadata) {
                    file.extractedMetadata = cachedMetadata;
                    return { extracted: false, cached: true };
                }
                
                try {
                    const metadata = await appState.metadataExtractor.fetchMetadata(file);
                    
                    if (metadata.error) {
                        throw new Error(metadata.error);
                    }
                    
                    if (Object.keys(metadata).length > 0) {
                        file.extractedMetadata = metadata;
                        await appState.fileCache.setMetadata(file.id, file.modifiedTime, metadata);
                        return { extracted: true, cached: false };
                    } else {
                        return { extracted: false, cached: false };
                    }
                    
                } catch (error) {
                    return { extracted: false, cached: false };
                }
            }
        };

        // ===== Enhanced Common Functions =====
        const commonFunctions = {
            initializeStacks() {
                STACK_TYPES.forEach(stack => { appState.stacks[stack] = []; });
                
                appState.imageFiles.forEach(file => {
                    const stack = file.stack || 'in';
                    if (STACK_TYPES.includes(stack)) {
                        appState.stacks[stack].push(file);
                    } else {
                        appState.stacks.in.push(file);
                    }
                });
                
                STACK_TYPES.forEach(stack => {
                    appState.stacks[stack] = this.sortFiles(appState.stacks[stack], 'name-asc');
                });
                
                this.updateStackCounts();
            },
            
            sortFiles(files, sortOrder) {
                const sorted = [...files];
                
                switch (sortOrder) {
                    case 'name-asc':
                        return sorted.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
                    case 'name-desc':
                        return sorted.sort((a, b) => (b.name || '').localeCompare(a.name || ''));
                    case 'date-desc':
                        return sorted.sort((a, b) => new Date(b.modifiedTime || b.createdTime) - new Date(a.modifiedTime || a.createdTime));
                    case 'date-asc':
                        return sorted.sort((a, b) => new Date(a.modifiedTime || a.createdTime) - new Date(b.modifiedTime || b.createdTime));
                    default:
                        return sorted;
                }
            },
            
            // Enhanced pill counter display with overflow handling
            updateStackCounts() {
                STACK_TYPES.forEach(stack => {
                    const count = appState.stacks[stack].length;
                    const pill = document.getElementById(`pill-${stack}`);
                    if (pill) {
                        if (count > 999) {
                            pill.textContent = '999';
                            pill.classList.add('overflow');
                        } else {
                            pill.textContent = count;
                            pill.classList.remove('overflow');
                <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no, maximum-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Orbital8 V14 - Enhanced Cloud Storage</title>
    <script src="https://alcdn.msauth.net/browser/2.28.1/js/msal-browser.min.js"></script>
    <style>
        /* ===== ORBITAL8 V14 - ENHANCED VERSION ===== */
        /* Major fixes and enhancements:
           - Fixed tablet landscape image scaling
           - Removed provider switch button from main stage
           - Enhanced export with separate prompt column
           - Fixed authentication state persistence
           - Improved mobile bottom edge glow
           - Fixed empty state navigation
           - Enhanced rating system display
           - Better memory management and error handling
           - Virtual scrolling for large datasets
           - Fixed OneDrive pagination
           - Improved metadata extraction and caching
        */
        
        :root {
            --app-accent: #f59e0b;
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.3);
            --dark-gradient: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
            --glow-opacity: 0.6;
            --ripple-duration: 1500ms;
            --safe-area-bottom: env(safe-area-inset-bottom, 0px);
        }

        * { box-sizing: border-box; }
        
        body, html {
            margin: 0; padding: 0; height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden; background: #000; overscroll-behavior: none; touch-action: none;
        }
        
        /* ===== Error Boundary Styles ===== */
        .error-boundary {
            position: fixed; inset: 0; background: var(--dark-gradient);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 9999; color: white; text-align: center; padding: 40px;
        }
        .error-title { font-size: 24px; font-weight: 600; margin-bottom: 16px; color: #ef4444; }
        .error-message { font-size: 16px; color: rgba(255, 255, 255, 0.8); margin-bottom: 24px; max-width: 600px; }
        .error-actions { display: flex; gap: 16px; }
        
        /* ===== Screen & Card Styles ===== */
        .screen {
            position: fixed; inset: 0; background: var(--dark-gradient);
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000;
        }
        .screen.hidden { display: none; }
        
        .card {
            background: var(--glass-bg); backdrop-filter: blur(20px);
            border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 20px;
            padding: 40px; text-align: center; max-width: 500px; width: 90%;
        }
        
        /* ===== Typography ===== */
        .title { color: white; font-size: 24px; font-weight: 600; margin-bottom: 16px; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8); }
        .subtitle { color: rgba(255, 255, 255, 0.7); font-size: 16px; margin-bottom: 24px; }
        
        /* ===== Form Elements ===== */
        .input, .tag-input, .notes-textarea {
            width: 100%; padding: 12px 16px; border: 1px solid var(--glass-border); border-radius: 12px;
            background: var(--glass-bg); color: white; font-size: 14px; margin-bottom: 16px; backdrop-filter: blur(10px);
        }
        .input::placeholder, .tag-input::placeholder { color: rgba(255, 255, 255, 0.5); }
        .input:focus, .tag-input:focus, .notes-textarea:focus {
            outline: none; border-color: var(--app-accent); box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.2);
        }
        .notes-textarea { min-height: 120px; font-family: inherit; resize: vertical; }
        
        /* ===== Buttons ===== */
        .button, .folder-button, .btn {
            background: linear-gradient(45deg, var(--app-accent), #d97706); border: none; border-radius: 15px;
            color: white; font-size: 18px; font-weight: 600; padding: 16px 32px; cursor: pointer;
            transition: all 0.3s ease; box-shadow: 0 4px 20px rgba(245, 158, 11, 0.4); width: 100%; margin-bottom: 16px;
        }
        .button:hover:not(:disabled), .folder-button:hover, .btn:hover {
            transform: translateY(-2px); box-shadow: 0 6px 25px rgba(245, 158, 11, 0.6);
        }
        .button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        
        .folder-button {
            flex: 1; padding: 12px 24px; border: 1px solid var(--glass-border); background: var(--glass-bg);
            font-size: 14px; backdrop-filter: blur(10px); width: auto;
        }
        .folder-button.danger { border-color: rgba(239, 68, 68, 0.3); color: #ef4444; }
        .folder-button.danger:hover { background: rgba(239, 68, 68, 0.1); }
        
        .btn { padding: 4px 12px; border-radius: 6px; font-size: 14px; font-weight: 500; margin-bottom: 0; width: auto; }
        .btn-primary { background-color: #3b82f6; }
        .btn-primary:hover { background-color: #2563eb; }
        .btn-danger { background-color: #ef4444; }
        .btn-danger:hover { background-color: #dc2626; }
        .btn-secondary { background-color: #e5e7eb; color: #4b5563; }
        .btn-secondary:hover { background-color: #d1d5db; }
        
        /* ===== Provider Selection Specific ===== */
        .provider-button {
            display: flex; align-items: center; justify-content: center; gap: 12px;
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px; padding: 20px; margin-bottom: 16px; color: white;
            font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        .provider-button:hover {
            background: rgba(255, 255, 255, 0.2); border-color: var(--app-accent);
            transform: translateY(-2px); box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        }
        
        .settings-section {
            margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .intensity-options {
            display: flex; gap: 8px; justify-content: center; margin-bottom: 16px;
        }
        
        .intensity-btn {
            padding: 8px 16px; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 8px;
            background: rgba(255, 255, 255, 0.1); color: white; cursor: pointer; font-size: 12px;
            transition: all 0.2s ease;
        }
        .intensity-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .intensity-btn.active { border-color: var(--app-accent); background: rgba(245, 158, 11, 0.2); color: var(--app-accent); }
        
        .checkbox-label {
            color: rgba(255, 255, 255, 0.9); font-size: 14px; display: flex;
            align-items: center; gap: 8px; cursor: pointer; justify-content: center;
        }
        
        /* ===== Status & Feedback ===== */
        .status {
            padding: 12px; border-radius: 8px; margin-top: 16px; font-size: 14px; font-weight: 500;
        }
        .status.success { background: rgba(16, 185, 129, 0.2); color: #10b981; border: 1px solid rgba(16, 185, 129, 0.3); }
        .status.error { background: rgba(239, 68, 68, 0.2); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.3); }
        .status.info { background: rgba(59, 130, 246, 0.2); color: #3b82f6; border: 1px solid rgba(59, 130, 246, 0.3); }
        
        .toast {
            position: fixed; bottom: calc(20px + var(--safe-area-bottom)); left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8); color: white; padding: 12px 20px; border-radius: 8px;
            font-size: 14px; font-weight: 500; z-index: 1000; opacity: 0; transition: opacity 0.3s ease; backdrop-filter: blur(10px);
        }
        .toast.show { opacity: 1; }
        .toast.success { background: rgba(16, 185, 129, 0.9); }
        .toast.info { background: rgba(59, 130, 246, 0.9); }
        .toast.error { background: rgba(239, 68, 68, 0.9); }
        
        /* ===== Progress Indicator ===== */
        .progress-overlay {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); 
            display: flex; align-items: center; justify-content: center; z-index: 2000;
            backdrop-filter: blur(5px);
        }
        .progress-card {
            background: var(--glass-bg); backdrop-filter: blur(20px);
            border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 20px;
            padding: 30px; text-align: center; min-width: 300px;
        }
        .progress-title { color: white; font-size: 18px; font-weight: 600; margin-bottom: 16px; }
        .progress-bar { width: 100%; height: 8px; background: rgba(255, 255, 255, 0.2); border-radius: 4px; overflow: hidden; margin: 16px 0; }
        .progress-fill { height: 100%; background: linear-gradient(45deg, var(--app-accent), #d97706); border-radius: 4px; transition: width 0.3s ease; width: 0%; }
        .progress-text { color: rgba(255, 255, 255, 0.8); font-size: 14px; }
        
        /* ===== Folder Items ===== */
        .folder-list { flex: 1; overflow-y: auto; margin-bottom: 20px; max-height: 400px; }
        .folder-item {
            display: flex; align-items: center; padding: 12px 16px; margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px; cursor: pointer; transition: all 0.2s ease; color: white; justify-content: space-between;
        }
        .folder-item:hover {
            background: rgba(255, 255, 255, 0.1); border-color: rgba(245, 158, 11, 0.3); transform: translateY(-1px);
        }
        .folder-icon { width: 20px; height: 20px; margin-right: 12px; color: var(--app-accent); }
        .folder-info { flex: 1; }
        .folder-name { font-weight: 500; margin-bottom: 2px; }
        .folder-date { font-size: 12px; color: rgba(255, 255, 255, 0.6); }
        
        .folder-actions { display: flex; gap: 8px; margin-left: 12px; }
        .folder-action-btn {
            padding: 6px 12px; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 8px;
            background: rgba(255, 255, 255, 0.1); color: white; font-size: 12px; cursor: pointer;
            transition: all 0.2s ease; backdrop-filter: blur(10px);
        }
        .folder-action-btn:hover { background: rgba(255, 255, 255, 0.2); transform: translateY(-1px); }
        .folder-action-btn.drill-btn { border-color: rgba(245, 158, 11, 0.4); color: var(--app-accent); }
        .folder-action-btn.drill-btn:hover { background: rgba(245, 158, 11, 0.2); }
        .folder-action-btn.select-btn { border-color: rgba(16, 185, 129, 0.4); color: #10b981; }
        .folder-action-btn.select-btn:hover { background: rgba(16, 185, 129, 0.2); }
        
        /* ===== Loading & Progress ===== */
        .spinner {
            width: 20px; height: 20px; border: 2px solid rgba(245, 158, 11, 0.3);
            border-radius: 50%; border-top-color: var(--app-accent); animation: spin 1s linear infinite; margin-right: 12px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .loading-counter { color: var(--app-accent); font-size: 48px; font-weight: 700; margin: 20px 0; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8); }
        .loading-message { color: rgba(255, 255, 255, 0.7); font-size: 16px; margin-bottom: 20px; }
        .loading-progress { width: 100%; height: 6px; background: rgba(255, 255, 255, 0.2); border-radius: 3px; overflow: hidden; margin-bottom: 20px; }
        .loading-progress-bar { height: 100%; background: linear-gradient(45deg, var(--app-accent), #d97706); border-radius: 3px; transition: width 0.3s ease; width: 0%; }
        
        /* ===== Main App Layout ===== */
        .app-container { position: relative; width: 100vw; height: 100vh; background: var(--dark-gradient); overflow: hidden; }
        .nav-button {
            position: absolute; top: 20px; background: var(--glass-bg); backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 20px; padding: 8px 12px; font-size: 11px;
            color: white; cursor: pointer; transition: all 0.3s ease; z-index: 15; display: flex; align-items: center; gap: 6px; opacity: 0.7;
        }
        .nav-button:hover { opacity: 1; background: rgba(255, 255, 255, 0.2); }
        .nav-button.back { left: 20px; }
        .nav-button.details { right: 20px; }
        
        /* ===== Folder Tooltip ===== */
        .folder-tooltip {
            position: absolute; background: rgba(0,0,0,0.85); color: white;
            padding: 8px 12px; border-radius: 6px; font-size: 12px;
            z-index: 1000; pointer-events: none; white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        /* ===== Image Display with Fixed Viewport Calculation ===== */
        .image-viewport { 
            position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; 
            z-index: 1; overflow: hidden;
            /* Fixed viewport calculation for tablet landscape */
            height: 100vh; height: 100dvh;
        }
        .center-image {
            max-width: 90vw; max-height: 85vh; max-height: 85dvh; 
            width: auto; height: auto; object-fit: contain; user-select: none; pointer-events: none;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.2s ease; 
            transform-origin: center center; cursor: grab;
        }
        .center-image.dragging { filter: brightness(0.9); cursor: grabbing; }
        .center-image.zoomable { pointer-events: auto; }
        
        /* Improved display for portrait images on tablet landscape */
        @media screen and (orientation: landscape) and (min-width: 768px) {
            .center-image {
                max-height: 80vh; max-height: 80dvh;
                /* Ensure portrait images display properly */
                object-position: center center;
            }
        }
        
        /* ===== Enhanced Edge Effects ===== */
        .edge-glow { position: absolute; opacity: 0; transition: opacity 0.2s ease; z-index: 2; }
        .edge-glow.top { top: 0; left: 0; right: 0; height: 8px; background: linear-gradient(180deg, rgba(245, 158, 11, var(--glow-opacity)) 0%, transparent 100%); }
        .edge-glow.bottom { 
            bottom: var(--safe-area-bottom); left: 0; right: 0; height: 8px; 
            background: linear-gradient(0deg, rgba(245, 158, 11, var(--glow-opacity)) 0%, transparent 100%);
            /* Fixed for mobile UI conflicts */
            z-index: 1;
        }
        .edge-glow.left { top: 0; left: 0; bottom: 0; width: 8px; background: linear-gradient(90deg, rgba(245, 158, 11, var(--glow-opacity)) 0%, transparent 100%); }
        .edge-glow.right { top: 0; right: 0; bottom: 0; width: 8px; background: linear-gradient(270deg, rgba(245, 158, 11, var(--glow-opacity)) 0%, transparent 100%); }
        .edge-glow.active { opacity: 1; }
        
        /* ===== Enhanced Pills & Counters ===== */
        .pill-counter {
            position: fixed; backdrop-filter: blur(10px); border-radius: 20px; padding: 12px 20px; font-size: 18px; font-weight: 500;
            color: black; opacity: 0; transition: all 0.3s ease; cursor: pointer; z-index: 10; min-width: 50px; text-align: center;
        }
        .pill-counter.visible { opacity: 0.9; }
        .pill-counter.active { font-weight: 700; background: white; opacity: 1; border: 3px solid black; }
        .pill-counter:not(.active) { background: rgba(128, 128, 128, 0.4); border: none; }
        .pill-counter:hover { opacity: 1; transform: scale(1.05); }
        .pill-counter.top { top: 10px; left: 50%; transform: translateX(-50%); }
        .pill-counter.bottom { bottom: calc(60px + var(--safe-area-bottom)); left: 50%; transform: translateX(-50%); }
        .pill-counter.left { left: 10px; top: 50%; transform: translateY(-50%); }
        .pill-counter.right { right: 10px; top: 50%; transform: translateY(-50%); }
        
        /* Enhanced overflow display - show :) for counts > 999 */
        .pill-counter.overflow::after { content: ' :)'; font-size: 14px; }
        
        /* ===== Enhanced Ripple Effects ===== */
        .pill-counter::before, .pill-counter::after {
            content: ''; position: absolute; border: 2px solid rgba(245, 158, 11, 0.8); border-radius: 16px; opacity: 0; pointer-events: none; z-index: -1;
        }
        .pill-counter.triple-ripple::before { animation: tripleRipple1 var(--ripple-duration) ease-out; }
        .pill-counter.triple-ripple::after { animation: tripleRipple2 var(--ripple-duration) ease-out 0.2s; }
        .pill-counter.triple-ripple { animation: tripleRipple3 var(--ripple-duration) ease-out 0.4s; }
        .pill-counter.glow-effect { 
            box-shadow: 0 0 25px rgba(245, 158, 11, var(--glow-opacity)), 0 0 50px rgba(245, 158, 11, calc(var(--glow-opacity) * 0.6)); 
            animation: sustainedGlow 1s ease-out calc(var(--ripple-duration) * 1); 
        }
        
        /* High intensity mode */
        .high-intensity-mode .pill-counter.glow-effect {
            box-shadow: 0 0 35px rgba(245, 158, 11, 1), 0 0 70px rgba(245, 158, 11, 0.8), 0 0 100px rgba(245, 158, 11, 0.6);
        }
        
        @keyframes tripleRipple1 {
            0% { opacity: 0.9; transform: scale(1); top: -4px; left: -4px; right: -4px; bottom: -4px; }
            100% { opacity: 0; transform: scale(2); top: -20px; left: -20px; right: -20px; bottom: -20px; }
        }
        @keyframes tripleRipple2 {
            0% { opacity: 0.7; transform: scale(1); top: -6px; left: -6px; right: -6px; bottom: -6px; }
            100% { opacity: 0; transform: scale(2.5); top: -30px; left: -30px; right: -30px; bottom: -30px; }
        }
        @keyframes tripleRipple3 {
            0% { box-shadow: 0 0 10px rgba(245, 158, 11, 0.5); }
            50% { box-shadow: 0 0 20px rgba(245, 158, 11, 0.8); }
            100% { box-shadow: 0 0 15px rgba(245, 158, 11, 0.6); }
        }
        @keyframes sustainedGlow {
            0% { box-shadow: 0 0 25px rgba(245, 158, 11, var(--glow-opacity)), 0 0 50px rgba(245, 158, 11, calc(var(--glow-opacity) * 0.6)); }
            50% { box-shadow: 0 0 35px rgba(245, 158, 11, 1), 0 0 70px rgba(245, 158, 11, 0.8); }
            100% { box-shadow: 0 0 10px rgba(245, 158, 11, 0.4); }
        }
        
        /* ===== Enhanced Empty State ===== */
        .empty-state {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;
            color: rgba(255, 255, 255, 0.7); font-size: 18px; font-weight: 300; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8); z-index: 5;
        }
        .empty-message { margin-bottom: 20px; font-size: 24px; font-weight: 400; }
        .empty-filename {
            margin-bottom: 20px; font-size: 16px; color: rgba(255, 255, 255, 0.9);
            background: rgba(0, 0, 0, 0.5); padding: 8px 16px; border-radius: 8px;
            font-family: monospace; word-break: break-all;
        }
        .new-images-button {
            background: rgba(245, 158, 11, 0.2); border: 1px solid rgba(245, 158, 11, 0.4); border-radius: 20px;
            padding: 12px 24px; color: white; font-size: 16px; cursor: pointer; transition: all 0.2s ease;
        }
        .new-images-button:hover { background: rgba(245, 158, 11, 0.4); transform: translateY(-2px); }
        
        /* ===== Modal System ===== */
        .modal { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 50; }
        .modal.hidden { display: none !important; }
        .modal-content {
            background: white; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 100%; height: 100%; max-width: 1152px; max-height: 90vh; margin: 16px; display: flex; flex-direction: column;
        }
        .action-modal { max-width: 448px; padding: 24px; }
        
        /* ===== Enhanced Grid System with Virtual Scrolling ===== */
        .modal-header { position: sticky; top: 0; background: white; z-index: 10; border-bottom: 1px solid #e5e7eb; }
        .modal-header-main { padding: 16px; border-bottom: 1px solid #f3f4f6; display: flex; align-items: center; justify-content: space-between; }
        .modal-header-left { display: flex; align-items: center; gap: 12px; }
        .modal-title { font-size: 20px; font-weight: 500; color: #1f2937; line-height: 1.5; }
        .select-all-btn {
            background-color: #e5e7eb; color: #4b5563; padding: 2px 8px; border-radius: 9999px; font-size: 14px; font-weight: 500;
            display: inline-block; min-width: 36px; text-align: center; cursor: pointer; transition: background-color 0.2s;
        }
        .select-all-btn:hover { background-color: #d1d5db; }
        .close-btn {
            color: #6b7280; transition: all 0.2s; cursor: pointer; background: transparent; border: none; border-radius: 6px;
            padding: 4px; display: flex; align-items: center; justify-content: center;
        }
        .close-btn:hover { color: #374151; background: rgba(0, 0, 0, 0.05); }
        .close-btn svg { width: 24px; height: 24px; }
        
        /* Row 2: Selected Count + Zoom Slider */
        .grid-row-2 {
            padding: 8px 16px; border-bottom: 1px solid #e5e7eb; display: flex;
            align-items: center; justify-content: space-between;
        }
        .selection-count {
            background-color: #dbeafe; color: #1e40af; padding: 4px 12px; border-radius: 9999px; font-size: 14px;
            display: flex; align-items: center; gap: 8px;
        }
        .deselect-all-btn {
            margin-left: 4px; transition: all 0.2s; cursor: pointer; background: transparent; border: none; border-radius: 4px;
            padding: 2px; display: flex; align-items: center; justify-content: center;
        }
        .deselect-all-btn:hover { color: #1e3a8a; background: rgba(0, 0, 0, 0.05); }
        .deselect-all-btn svg { width: 16px; height: 16px; }
        
        .zoom-control { display: flex; align-items: center; gap: 8px; }
        .zoom-control label { font-size: 14px; color: #4b5563; }
        #grid-size { width: 80px; }
        #grid-size-value { font-size: 14px; color: #4b5563; min-width: 20px; }
        
        /* Row 3: Search Fields */
        .grid-row-3 {
            padding: 8px 16px; border-bottom: 1px solid #e5e7eb; display: flex;
            align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 16px;
        }
        .search-group { display: flex; align-items: center; gap: 8px; }
        .search-group label { font-size: 14px; color: #4b5563; min-width: 50px; }
        .search-group input {
            width: 120px; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;
        }
        
        /* Row 4: Action Buttons */
        .grid-row-4 {
            padding: 8px 16px; border-bottom: 1px solid #e5e7eb; display: flex;
            align-items: center; justify-content: flex-end; gap: 8px;
        }
        
        /* Enhanced Virtual Scrolling Grid */
        .grid-content { 
            flex: 1; overflow-y: auto; padding: 16px; position: relative;
            /* Enable GPU acceleration for smooth scrolling */
            transform: translateZ(0);
        }
        .virtual-grid-container { 
            position: relative; 
            /* Height will be calculated based on total items */
        }
        .grid-container { 
            display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 16px;
            position: absolute; top: 0; left: 0; right: 0;
        }
        .grid-item { 
            position: relative; aspect-ratio: 1; overflow: hidden; border-radius: 8px; cursor: pointer;
            /* Enhanced selection state visibility */
            transition: box-shadow 0.2s ease, transform 0.2s ease;
        }
        .grid-image { 
            width: 100%; height: 100%; object-fit: cover;
            /* Consistent aspect ratios */
            object-position: center center;
        }
        .grid-item.selected { 
            box-shadow: 0 0 0 4px #3b82f6; 
            transform: scale(0.95);
            z-index: 1;
        }
        .grid-item:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        
        /* Grid loading skeleton */
        .grid-skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
            aspect-ratio: 1;
            border-radius: 8px;
        }
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        /* ===== Enhanced Details Modal ===== */
        .details-modal-content { max-width: 800px; max-height: 95vh; height: 95vh; display: flex; flex-direction: column; }
        .details-header { display: flex; align-items: center; justify-content: space-between; padding: 16px; border-bottom: 1px solid #e5e7eb; flex-shrink: 0; }
        .details-title { font-size: 18px; font-weight: 500; color: #1f2937; }
        .tab-nav { display: flex; border-bottom: 1px solid #e5e7eb; background: #f8fafc; flex-shrink: 0; }
        .tab-button {
            flex: 1; padding: 16px; border: none; background: transparent; color: #6b7280; font-size: 14px; font-weight: 500;
            cursor: pointer; transition: all 0.2s; border-bottom: 2px solid transparent;
        }
        .tab-button:hover { color: #374151; background: rgba(0, 0, 0, 0.02); }
        .tab-button.active { color: #3b82f6; border-bottom-color: #3b82f6; background: white; }
        .details-content { flex: 1; overflow-y: auto; overflow-x: hidden; min-height: 0; }
        .tab-content { display: none; padding: 20px; height: 100%; }
        .tab-content.active { display: block; }
        
        /* ===== Enhanced Tags & Ratings ===== */
        .tags-container { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; min-height: 40px; }
        .tag-item { display: inline-flex; align-items: center; background: #dbeafe; color: #1e40af; padding: 4px 8px; border-radius: 12px; font-size: 12px; gap: 6px; }
        .tag-remove {
            background: transparent; border: none; color: #1e40af; cursor: pointer; font-size: 14px; line-height: 1; padding: 0;
            width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: background-color 0.2s;
        }
        .tag-remove:hover { background: rgba(59, 130, 246, 0.1); }
        .add-tag-btn {
            background: #f3f4f6; border: 1px dashed #d1d5db; border-radius: 12px; padding: 4px 12px;
            font-size: 12px; color: #6b7280; cursor: pointer; transition: all 0.2s;
        }
        .add-tag-btn:hover { background: #e5e7eb; color: #374151; }
        
        /* Enhanced Star Rating - Fixed Display and Storage */
        .star-rating { display: flex; gap: 4px; margin-bottom: 16px; }
        .star { 
            width: 24px; height: 24px; cursor: pointer; transition: all 0.2s ease;
            fill: #d1d5db; color: #d1d5db;
        }
        .star:hover { fill: #fbbf24; color: #fbbf24; transform: scale(1.1); }
        .star.active { fill: #fbbf24; color: #fbbf24; }
        .star.filled { fill: #fbbf24; color: #fbbf24; }
        
        .rating-section {
            margin-bottom: 20px; padding: 12px; border: 1px solid #e5e7eb; border-radius: 8px;
            background: #f9fafb;
        }
        .rating-label {
            font-size: 14px; font-weight: 500; color: #374151; margin-bottom: 8px; display: block;
        }
        
        /* ===== Enhanced Metadata Table ===== */
        .metadata-table { width: 100%; border-collapse: collapse; border: 1px solid #e5e7eb; font-size: 13px; }
        .metadata-table td { padding: 8px 12px; border-bottom: 1px solid #e5e7eb; vertical-align: top; word-wrap: break-word; }
        .metadata-table .key-cell {
            font-weight: 500; color: #374151; width: 25%; border-right: 1px solid #e5e7eb; background: #f9fafb; min-width: 120px;
        }
        .metadata-table .value-cell { color: #6b7280; white-space: pre-wrap; position: relative; max-width: 0; word-break: break-all; }
        .copy-button {
            background: #f59e0b; border: none; border-radius: 4px; padding: 4px 8px; font-size: 11px; color: white;
            cursor: pointer; transition: all 0.2s; margin-left: 8px; vertical-align: top; font-weight: 500;
        }
        .copy-button:hover { background: #d97706; transform: translateY(-1px); box-shadow: 0 2px 4px rgba(245, 158, 11, 0.3); }
        .copy-button:active { transform: translateY(0); box-shadow: 0 1px 2px rgba(245, 158, 11, 0.3); }
        .copy-button.copied { background: #10b981; transform: scale(1.1); }
        
        /* ===== Footer ===== */
        .app-footer {
            position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.8);
            color: rgba(255, 255, 255, 0.6); text-align: center; padding: 4px 8px;
            font-size: 10px; z-index: 5; backdrop-filter: blur(10px);
            padding-bottom: calc(4px + var(--safe-area-bottom));
        }
        
        /* ===== Responsive Enhancements ===== */
        .hidden { display: none !important; }
        
        @media screen and (min-width: 768px) {
            .image-viewport { top: 0; }
            .pill-counter { font-size: 16px; padding: 8px 16px; min-width: 40px; }
            .nav-button { font-size: 14px; padding: 10px 16px; }
        }
        
        @media screen and (max-width: 767px) {
            .nav-button { font-size: 16px; padding: 12px 20px; border-radius: 25px; min-width: 80px; }
            .pill-counter.bottom { bottom: calc(80px + var(--safe-area-bottom)); }
            .details-modal-content { max-width: 100vw; max-height: 100vh; height: 100vh; margin: 0; border-radius: 0; }
            .metadata-table .key-cell { width: 30%; min-width: 80px; font-size: 12px; }
            .metadata-table .value-cell { font-size: 12px; }
            .copy-button { font-size: 10px; padding: 3px 6px; }
            
            .grid-row-3 { flex-direction: column; align-items: stretch; }
            .search-group { justify-content: space-between; }
            .search-group input { width: 100px; }
            
            .app-container { height: 100vh; height: 100dvh; }
            .image-viewport { height: 100vh; height: 100dvh; }
        }
        
        @supports (height: 100dvh) {
            .app-container { height: 100dvh; }
            .image-viewport { height: 100dvh; }
        }
    </style>
</head>
<body>
    <!-- Error Boundary -->
    <div class="error-boundary hidden" id="error-boundary">
        <div class="error-title">Something went wrong</div>
        <div class="error-message" id="error-message">An unexpected error occurred. Please try refreshing the page.</div>
        <div class="error-actions">
            <button class="button" onclick="location.reload()">Refresh Page</button>
            <button class="button" onclick="localStorage.clear(); location.reload();" style="background: rgba(239, 68, 68, 0.8);">Clear Data & Refresh</button>
        </div>
    </div>

    <!-- Provider Selection Screen -->
    <div class="screen" id="provider-screen">
        <div class="card">
            <h1 class="title" style="font-size: 32px;">Orbital8</h1>
            <p class="subtitle">Select your cloud storage provider</p>
            
            <button class="provider-button" id="google-drive-btn">
                <svg style="width: 20px; height: 20px;" viewBox="0 0 24 24">
                    <path fill="currentColor" d="M6.28 7L9.69 1h4.62l3.41 6zM16.05 7H7.95l4.05 7zM11.76 15h8.58L24 21H7.05z"/>
                </svg>
                Google Drive
            </button>
            
            <button class="provider-button" id="onedrive-btn">
                <svg style="width: 20px; height: 20px;" viewBox="0 0 24 24">
                    <path fill="currentColor" d="M17.75 8C16.82 8 16 8.82 16 9.75S16.82 11.5 17.75 11.5s1.75-.82 1.75-1.75S18.68 8 17.75 8z"/>
                </svg>
                OneDrive
            </button>
            
            <div class="settings-section">
                <div style="margin-bottom: 16px;">
                    <label style="color: rgba(255,255,255,0.9); font-size: 14px; font-weight: 500; display: block; margin-bottom: 8px;">Visual Cue Intensity:</label>
                    <div class="intensity-options">
                        <button class="intensity-btn" data-level="low">Low</button>
                        <button class="intensity-btn active" data-level="medium">Medium</button>
                        <button class="intensity-btn" data-level="high">High</button>
                    </div>
                </div>
                
                <div>
                    <label class="checkbox-label">
                        <input type="checkbox" id="haptic-enabled" checked style="margin: 0;">
                        Enable Haptic Feedback (Mobile)
                    </label>
                </div>
            </div>
            
            <div id="provider-status" class="status info">Choose your preferred cloud storage</div>
        </div>
        <div class="app-footer">orbital8-v14-Dojo Edition</div>
    </div>
    
    <!-- Google Drive Auth Screen -->
    <div class="screen hidden" id="gdrive-auth-screen">
        <div class="card">
            <h1 class="title">Google Drive</h1>
            <p class="subtitle">Connect to Google Drive</p>
            <input type="password" id="gdrive-client-secret" class="input" placeholder="Enter Google Client Secret">
            <button class="button" id="gdrive-auth-button">Connect Drive</button>
            <button class="button" id="gdrive-back-button" style="background: rgba(128,128,128,0.3);">← Back</button>
            <div id="gdrive-auth-status" class="status info">Enter your client secret to continue</div>
        </div>
        <div class="app-footer">orbital8-v14-Dojo Edition</div>
    </div>
    
    <!-- OneDrive Auth Screen -->
    <div class="screen hidden" id="onedrive-auth-screen">
        <div class="card">
            <h1 class="title">OneDrive</h1>
            <p class="subtitle">Connect to OneDrive</p>
            <button class="button" id="onedrive-auth-button">Connect OneDrive</button>
            <button class="button" id="onedrive-back-button" style="background: rgba(128,128,128,0.3);">← Back</button>
            <div id="onedrive-auth-status" class="status info">Click to sign in with your Microsoft account</div>
        </div>
        <div class="app-footer">orbital8-v14-enhanced.html</div>
    </div>
    
    <!-- Google Drive Folder Screen -->
    <div class="screen hidden" id="gdrive-folder-screen">
        <div class="card" style="max-height: 80vh; display: flex; flex-direction: column;">
            <h2 class="title">Google Drive - Select Folder</h2>
            <div class="subtitle">Choose a folder containing images</div>
            <div class="folder-list" id="gdrive-folder-list"></div>
            <div class="folder-actions">
                <button class="folder-button" id="gdrive-refresh-folders">Refresh</button>
                <button class="folder-button" id="gdrive-back-to-provider">← Provider</button>
                <button class="folder-button danger" id="gdrive-logout">Disconnect</button>
            </div>
        </div>
        <div class="app-footer">orbital8-v14-enhanced.html</div>
    </div>
    
    <!-- OneDrive Folder Screen -->
    <div class="screen hidden" id="onedrive-folder-screen">
        <div class="card" style="max-height: 80vh; display: flex; flex-direction: column;">
            <h2 class="title">OneDrive - Select Folder</h2>
            <div class="subtitle" id="onedrive-folder-subtitle">Starting from Downloads folder - browse or select any folder</div>
            <div class="folder-list" id="onedrive-folder-list"></div>
            <div class="folder-actions">
                <button class="folder-button" id="onedrive-refresh-folders">Refresh</button>
                <button class="folder-button" id="onedrive-back-to-provider">← Provider</button>
                <button class="folder-button danger" id="onedrive-logout">Disconnect</button>
            </div>
        </div>
        <div class="app-footer">orbital8-v14-enhanced.html</div>
    </div>
    
    <!-- Loading Screen -->
    <div class="screen hidden" id="loading-screen" style="z-index: 1500;">
        <div class="card">
            <h2 class="title">Loading Images</h2>
            <div class="loading-counter" id="loading-counter">0</div>
            <div class="loading-message" id="loading-message">Processing files...</div>
            <div class="loading-progress">
                <div class="loading-progress-bar" id="loading-progress-bar"></div>
            </div>
            <button class="button" id="cancel-loading" style="background: rgba(239, 68, 68, 0.8); margin-top: 16px;">Cancel</button>
        </div>
        <div class="app-footer">orbital8-v14-enhanced.html</div>
    </div>
    
    <!-- Progress Overlay for Bulk Operations -->
    <div class="progress-overlay hidden" id="progress-overlay">
        <div class="progress-card">
            <div class="progress-title" id="progress-title">Processing...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">0 of 0 completed</div>
        </div>
    </div>
    
    <!-- Main App Container -->
    <div class="app-container hidden" id="app-container">
        <div class="nav-button back" id="back-button">← Folders</div>
        <div class="nav-button details" id="details-button">Details →</div>
        
        <div class="image-viewport" id="image-viewport">
            <img class="center-image zoomable" id="center-image" alt="Select a folder to start" />
        </div>
        
        <div class="edge-glow top" id="edge-top"></div>
        <div class="edge-glow bottom" id="edge-bottom"></div>
        <div class="edge-glow left" id="edge-left"></div>
        <div class="edge-glow right" id="edge-right"></div>
        
        <div class="pill-counter top" id="pill-priority" data-stack="priority">0</div>
        <div class="pill-counter bottom" id="pill-trash" data-stack="trash">0</div>
        <div class="pill-counter left active" id="pill-in" data-stack="in">0</div>
        <div class="pill-counter right" id="pill-out" data-stack="out">0</div>
        
        <div class="empty-state hidden" id="empty-state">
            <div class="empty-message">No more images in this stack</div>
            <div class="empty-filename hidden" id="empty-filename"></div>
            <button class="new-images-button" id="select-another-stack-btn">Select Another Stack</button>
            <button class="new-images-button" id="select-another-folder-btn" style="margin-top: 12px;">Choose Different Folder</button>
        </div>
        
        <div id="toast" class="toast"></div>
        <div class="app-footer">orbital8-v14-enhanced.html</div>
    </div>
    
    <!-- Enhanced Grid Modal with Virtual Scrolling -->
    <div id="grid-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <!-- Row 1: Stack Name + Image Count Pill -->
                <div class="modal-header-main">
                    <div class="modal-header-left">
                        <h2 id="grid-title" class="modal-title">Grid View</h2>
                        <button id="select-all-btn" class="select-all-btn">0</button>
                    </div>
                    <button id="close-grid" class="close-btn">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                
                <!-- Row 2: Selected Count + Zoom Slider -->
                <div class="grid-row-2">
                    <span class="selection-count">
                        <span id="selection-text">0 selected</span>
                        <button id="deselect-all-btn" class="deselect-all-btn">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </span>
                    <div class="zoom-control">
                        <label>Grid Size:</label>
                        <input type="range" id="grid-size" min="1" max="10" value="4">
                        <span id="grid-size-value">4</span>
                    </div>
                </div>
                
                <!-- Row 3: Search Fields -->
                <div class="grid-row-3">
                    <div class="search-group">
                        <label>Tags:</label>
                        <input type="text" id="search-tags" placeholder="nature*">
                    </div>
                    <div class="search-group">
                        <label>Notes:</label>
                        <input type="text" id="search-notes" placeholder="vacation*">
                    </div>
                    <div class="search-group">
                        <label>Meta:</label>
                        <input type="text" id="search-meta" placeholder="camera*">
                    </div>
                    <button id="search-btn" class="btn btn-primary">Search</button>
                </div>
                
                <!-- Row 4: Action Buttons -->
                <div class="grid-row-4">
                    <button id="tag-selected" class="btn btn-primary hidden">Tag</button>
                    <button id="move-selected" class="btn btn-primary hidden">Move</button>
                    <button id="delete-selected" class="btn btn-danger hidden">Delete</button>
                    <button id="export-selected" class="btn btn-primary hidden">Export</button>
                    <button id="create-folder-selected" class="btn btn-primary hidden">New Folder</button>
                    <button id="move-to-folder-selected" class="btn btn-primary hidden">Move to Folder</button>
                </div>
            </div>
            <div class="grid-content" id="grid-content">
                <div id="virtual-grid-container" class="virtual-grid-container">
                    <div id="grid-container" class="grid-container"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Unified Action Modal -->
    <div id="action-modal" class="modal hidden">
        <div class="modal-content action-modal">
            <h3 id="action-title" class="title" style="font-size: 18px; color: #1f2937; margin-bottom: 16px;">Action</h3>
            <div id="action-content"></div>
            <div style="display: flex; justify-content: flex-end; gap: 8px; margin-top: 16px;">
                <button id="action-cancel" class="btn btn-secondary">Cancel</button>
                <button id="action-confirm" class="btn btn-primary">Confirm</button>
            </div>
        </div>
    </div>
    
    <!-- Enhanced Details Modal -->
    <div id="details-modal" class="modal hidden">
        <div class="modal-content details-modal-content">
            <div class="details-header">
                <h3 class="details-title">Image Details</h3>
                <button id="details-close" class="close-btn">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            
            <div class="tab-nav">
                <button class="tab-button active" data-tab="info">Info</button>
                <button class="tab-button" data-tab="tags">Tags</button>
                <button class="tab-button" data-tab="notes">Notes</button>
                <button class="tab-button" data-tab="metadata">Metadata</button>
            </div>
            
            <div class="details-content">
                <div id="tab-info" class="tab-content active">
                    <div style="margin-bottom: 20px;">
                        <div style="display: flex; align-items: center; margin-bottom: 12px; gap: 12px;">
                            <span style="font-size: 14px; color: #6b7280; min-width: 80px; font-weight: 500;">Filename:</span>
                            <a id="detail-filename-link" style="font-size: 14px; color: #3b82f6; flex: 1; word-break: break-word; text-decoration: none;" href="#" target="_blank">
                                <span id="detail-filename"></span>
                            </a>
                        </div>
                        <div style="display: flex; align-items: center; margin-bottom: 12px; gap: 12px;">
                            <span style="font-size: 14px; color: #6b7280; min-width: 80px; font-weight: 500;">Date:</span>
                            <span id="detail-date" style="font-size: 14px; color: #374151; flex: 1; word-break: break-word;"></span>
                        </div>
                        <div style="display: flex; align-items: center; margin-bottom: 12px; gap: 12px;">
                            <span style="font-size: 14px; color: #6b7280; min-width: 80px; font-weight: 500;">Size:</span>
                            <span id="detail-size" style="font-size: 14px; color: #374151; flex: 1; word-break: break-word;"></span>
                        </div>
                    </div>
                </div>
                
                <div id="tab-tags" class="tab-content">
                    <div style="margin-bottom: 20px;">
                        <div class="tags-container" id="detail-tags"></div>
                    </div>
                </div>
                
                <div id="tab-notes" class="tab-content">
                    <div style="margin-bottom: 24px;">
                        <label for="detail-notes" style="font-size: 14px; color: #6b7280; min-width: 80px; font-weight: 500;">Notes:</label>
                        <textarea id="detail-notes" class="notes-textarea" placeholder="Add your notes here..."></textarea>
                    </div>
                    
                    <div class="rating-section">
                        <label class="rating-label">Quality Rating:</label>
                        <div class="star-rating" id="quality-rating">
                            <svg class="star" data-rating="1" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                            </svg>
                            <svg class="star" data-rating="2" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                            </svg>
                            <svg class="star" data-rating="3" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                            </svg>
                            <svg class="star" data-rating="4" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                            </svg>
                            <svg class="star" data-rating="5" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                            </svg>
                        </div>
                    </div>
                    
                    <div class="rating-section">
                        <label class="rating-label">Content Rating:</label>
                        <div class="star-rating" id="content-rating">
                            <svg class="star" data-rating="1" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                            </svg>
                            <svg class="star" data-rating="2" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                            </svg>
                            <svg class="star" data-rating="3" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                            </svg>
                            <svg class="star" data-rating="4" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                            </svg>
                            <svg class="star" data-rating="5" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                            </svg>
                        </div>
                    </div>
                </div>
                
                <div id="tab-metadata" class="tab-content">
                    <table class="metadata-table" id="metadata-table"></table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== ORBITAL8 V14 - ENHANCED CLOUD STORAGE APPLICATION =====
        /* 
         * Version: V14 (orbital8-v14-enhanced.html)
         * 
         * Enhanced features and bug fixes:
         * 1. Fixed tablet landscape image scaling issues
         * 2. Removed provider switch button from main stage (Issue #7)
         * 3. Enhanced export with separate prompt column (Issues #3, #29)
         * 4. Fixed authentication state persistence (Issue #8)
         * 5. Improved mobile bottom edge glow (Issue #9)
         * 6. Fixed empty state navigation (Issue #22)
         * 7. Enhanced rating system display and storage (Issue #35)
         * 8. Better memory management and error handling (Issues #11, #17)
         * 9. Virtual scrolling for large datasets (Issue #12)
         * 10. Fixed OneDrive pagination (Issue #6)
         * 11. Enhanced metadata extraction and caching (Issues #13, #20, #28)
         * 12. Fixed image loading race conditions (Issue #2)
         * 13. Improved error boundary and top-level error catching (Issue #17)
         * 14. Enhanced keyboard navigation (Issue #16)
         * 15. Better bulk operation feedback (Issue #24)
         * 16. Fixed selection state visibility in grid (Issue #23)
         * 17. Improved haptic feedback timing (Issue #33)
         * 18. Enhanced pill counter overflow display (Issue #32)
         * 19. Better configuration management (Issue #36)
         * 20. Folder creation and move operations (Issues #37, #38)
         */
        
        // ===== Global Error Handler =====
        class ErrorBoundary {
            constructor() {
                this.setupGlobalErrorHandlers();
            }
            
            setupGlobalErrorHandlers() {
                window.addEventListener('error', (event) => {
                    this.handleError(event.error || new Error(event.message));
                });
                
                window.addEventListener('unhandledrejection', (event) => {
                    this.handleError(event.reason);
                });
            }
            
            handleError(error) {
                console.error('Global error caught:', error);
                
                const errorBoundary = document.getElementById('error-boundary');
                const errorMessage = document.getElementById('error-message');
                
                if (errorBoundary && errorMessage) {
                    errorMessage.textContent = error.message || 'An unexpected error occurred.';
                    errorBoundary.classList.remove('hidden');
                    
                    // Hide other screens
                    document.querySelectorAll('.screen, .app-container').forEach(el => {
                        if (el.id !== 'error-boundary') el.classList.add('hidden');
                    });
                }
            }
            
            clearError() {
                const errorBoundary = document.getElementById('error-boundary');
                if (errorBoundary) {
                    errorBoundary.classList.add('hidden');
                }
            }
        }
        
        // ===== Configuration Management =====
        const CONFIG = {
            GOOGLE_DRIVE: {
                CLIENT_ID: '567988062464-fa6c1ovesqeudqs5398vv4mbo6q068p9.apps.googleusercontent.com',
                SCOPE: 'https://www.googleapis.com/auth/drive',
                API_BASE: 'https://www.googleapis.com/drive/v3'
            },
            ONEDRIVE: {
                CLIENT_ID: 'b407fd45-c551-4dbb-9da5-cab3a2c5a949',
                AUTHORITY: 'https://login.microsoftonline.com/common',
                API_BASE: 'https://graph.microsoft.com/v1.0'
            },
            CACHE: {
                DURATION: 60 * 60 * 1000, // 1 hour
                VERSION: 4
            },
            VIRTUAL_SCROLL: {
                BUFFER_SIZE: 50,
                ITEM_HEIGHT: 180,
                OVERSCAN: 10
            },
            PERFORMANCE: {
                BATCH_SIZE: 5,
                MAX_CONCURRENT_REQUESTS: 3,
                IMAGE_LOAD_TIMEOUT: 10000
            },
            UI: {
                HAPTIC_PATTERNS: {
                    SWIPE: [50],
                    PILL_TAP: [30],
                    BUTTON_PRESS: [25],
                    ERROR: [100, 50, 100],
                    SUCCESS: [25, 25, 25]
                },
                ANIMATION_DURATION: 300,
                TOAST_DURATION: 3000
            }
        };
        
        // ===== Core Constants & Enhanced State =====
        const STACK_TYPES = ['in', 'out', 'priority', 'trash'];
        const STACK_NAMES = { 'in': 'In', 'out': 'Out', 'priority': 'Priority', 'trash': 'Trash' };
        
        const appState = {
            currentProvider: null,
            currentProviderType: null,
            fileCache: null,
            metadataExtractor: null,
            visualCueManager: null,
            hapticManager: null,
            exportSystem: null,
            virtualScrollManager: null,
            memoryManager: null,
            currentFolder: { id: null, name: '' },
            imageFiles: [],
            currentImageIndex: 0,
            currentStack: 'in',
            stacks: { in: [], out: [], priority: [], trash: [] },
            isDragging: false,
            isPinching: false,
            initialDistance: 0,
            currentScale: 1,
            maxScale: 4,
            minScale: 0.3,
            panOffset: { x: 0, y: 0 },
            grid: { stack: null, selected: [], filtered: [] },
            tags: new Set(),
            loadingProgress: { current: 0, total: 0 },
            folderMoveMode: { active: false },
            imageLoadQueue: new Map(),
            currentImagePromise: null,
            authStateRestored: false
        };

        // ===== Enhanced Utilities =====
        const utils = {
            elements: {},
            
            init() {
                this.elements = {
                    // Error boundary
                    errorBoundary: document.getElementById('error-boundary'),
                    
                    // Screens
                    providerScreen: document.getElementById('provider-screen'),
                    gdriveAuthScreen: document.getElementById('gdrive-auth-screen'),
                    onedriveAuthScreen: document.getElementById('onedrive-auth-screen'),
                    gdriveFolderScreen: document.getElementById('gdrive-folder-screen'),
                    onedriveFolderScreen: document.getElementById('onedrive-folder-screen'),
                    loadingScreen: document.getElementById('loading-screen'),
                    appContainer: document.getElementById('app-container'),
                    
                    // Provider selection
                    googleDriveBtn: document.getElementById('google-drive-btn'),
                    onedriveBtn: document.getElementById('onedrive-btn'),
                    providerStatus: document.getElementById('provider-status'),
                    
                    // Google Drive elements
                    gdriveClientSecret: document.getElementById('gdrive-client-secret'),
                    gdriveAuthButton: document.getElementById('gdrive-auth-button'),
                    gdriveBackButton: document.getElementById('gdrive-back-button'),
                    gdriveAuthStatus: document.getElementById('gdrive-auth-status'),
                    gdriveFolderList: document.getElementById('gdrive-folder-list'),
                    gdriveRefreshFolders: document.getElementById('gdrive-refresh-folders'),
                    gdriveBackToProvider: document.getElementById('gdrive-back-to-provider'),
                    gdriveLogout: document.getElementById('gdrive-logout'),
                    
                    // OneDrive elements
                    onedriveAuthButton: document.getElementById('onedrive-auth-button'),
                    onedriveBackButton: document.getElementById('onedrive-back-button'),
                    onedriveAuthStatus: document.getElementById('onedrive-auth-status'),
                    onedriveFolderList: document.getElementById('onedrive-folder-list'),
                    onedriveFolderSubtitle: document.getElementById('onedrive-folder-subtitle'),
                    onedriveRefreshFolders: document.getElementById('onedrive-refresh-folders'),
                    onedriveBackToProvider: document.getElementById('onedrive-back-to-provider'),
                    onedriveLogout: document.getElementById('onedrive-logout'),
                    
                    // App elements (removed provider switch button)
                    backButton: document.getElementById('back-button'),
                    detailsButton: document.getElementById('details-button'),
                    imageViewport: document.getElementById('image-viewport'),
                    centerImage: document.getElementById('center-image'),
                    emptyState: document.getElementById('empty-state'),
                    emptyFilename: document.getElementById('empty-filename'),
                    selectAnotherStackBtn: document.getElementById('select-another-stack-btn'),
                    selectAnotherFolderBtn: document.getElementById('select-another-folder-btn'),
                    toast: document.getElementById('toast'),
                    
                    // Loading elements
                    loadingCounter: document.getElementById('loading-counter'),
                    loadingMessage: document.getElementById('loading-message'),
                    loadingProgressBar: document.getElementById('loading-progress-bar'),
                    cancelLoading: document.getElementById('cancel-loading'),
                    
                    // Progress overlay
                    progressOverlay: document.getElementById('progress-overlay'),
                    progressTitle: document.getElementById('progress-title'),
                    progressFill: document.getElementById('progress-fill'),
                    progressText: document.getElementById('progress-text'),
                    
                    // Edge glows
                    edgeTop: document.getElementById('edge-top'),
                    edgeBottom: document.getElementById('edge-bottom'),
                    edgeLeft: document.getElementById('edge-left'),
                    edgeRight: document.getElementById('edge-right'),
                    
                    // Pill counters
                    pillPriority: document.getElementById('pill-priority'),
                    pillTrash: document.getElementById('pill-trash'),
                    pillIn: document.getElementById('pill-in'),
                    pillOut: document.getElementById('pill-out'),
                    
                    // Grid modal
                    gridModal: document.getElementById('grid-modal'),
                    gridTitle: document.getElementById('grid-title'),
                    gridContent: document.getElementById('grid-content'),
                    virtualGridContainer: document.getElementById('virtual-grid-container'),
                    gridContainer: document.getElementById('grid-container'),
                    selectAllBtn: document.getElementById('select-all-btn'),
                    deselectAllBtn: document.getElementById('deselect-all-btn'),
                    selectionText: document.getElementById('selection-text'),
                    closeGrid: document.getElementById('close-grid'),
                    gridSize: document.getElementById('grid-size'),
                    gridSizeValue: document.getElementById('grid-size-value'),
                    
                    // Search elements
                    searchTags: document.getElementById('search-tags'),
                    searchNotes: document.getElementById('search-notes'),
                    searchMeta: document.getElementById('search-meta'),
                    searchBtn: document.getElementById('search-btn'),
                    
                    // Action buttons
                    tagSelected: document.getElementById('tag-selected'),
                    moveSelected: document.getElementById('move-selected'),
                    deleteSelected: document.getElementById('delete-selected'),
                    exportSelected: document.getElementById('export-selected'),
                    createFolderSelected: document.getElementById('create-folder-selected'),
                    moveToFolderSelected: document.getElementById('move-to-folder-selected'),
                    
                    // Action modal
                    actionModal: document.getElementById('action-modal'),
                    actionTitle: document.getElementById('action-title'),
                    actionContent: document.getElementById('action-content'),
                    actionCancel: document.getElementById('action-cancel'),
                    actionConfirm: document.getElementById('action-confirm'),
                    
                    // Details modal
                    detailsModal: document.getElementById('details-modal'),
                    detailsClose: document.getElementById('details-close'),
                    detailFilename: document.getElementById('detail-filename'),
                    detailFilenameLink: document.getElementById('detail-filename-link'),
                    detailDate: document.getElementById('detail-date'),
                    detailSize: document.getElementById('detail-size'),
                    detailTags: document.getElementById('detail-tags'),
                    detailNotes: document.getElementById('detail-notes'),
                    qualityRating: document.getElementById('quality-rating'),
                    contentRating: document.getElementById('content-rating'),
                    metadataTable: document.getElementById('metadata-table')
                };
            },
            
            showScreen(screenId) {
                const screens = ['provider-screen', 'gdrive-auth-screen', 'onedrive-auth-screen', 
                               'gdrive-folder-screen', 'onedrive-folder-screen', 'loading-screen', 'app-container'];
                screens.forEach(id => {
                    document.getElementById(id).classList.toggle('hidden', id !== screenId);
                });
            },
            
            showModal(id) { document.getElementById(id).classList.remove('hidden'); },
            hideModal(id) { document.getElementById(id).classList.add('hidden'); },
            
            showProgress(title, text = '') {
                this.elements.progressTitle.textContent = title;
                this.elements.progressText.textContent = text;
                this.elements.progressFill.style.width = '0%';
                this.elements.progressOverlay.classList.remove('hidden');
            },
            
            updateProgress(percentage, text = '') {
                this.elements.progressFill.style.width = `${percentage}%`;
                if (text) this.elements.progressText.textContent = text;
            },
            
            hideProgress() {
                this.elements.progressOverlay.classList.add('hidden');
            },
            
            showToast(message, type = 'success', important = false) {
                if (!important && Math.random() < 0.7) return;
                const toast = this.elements.toast;
                toast.textContent = message;
                toast.className = `toast ${type} show`;
                setTimeout(() => toast.classList.remove('show'), CONFIG.UI.TOAST_DURATION);
                
                // Enhanced haptic feedback
                if (important && appState.hapticManager) {
                    const hapticType = type === 'error' ? 'error' : type === 'success' ? 'success' : 'buttonPress';
                    appState.hapticManager.triggerFeedback(hapticType);
                }
            },
            
            async withErrorHandling(operation, errorMessage = 'Operation failed') {
                try {
                    return await operation();
                } catch (error) {
                    this.showToast(`${errorMessage}: ${error.message}`, 'error', true);
                    throw error;
                }
            },
            
            // Enhanced image loading with race condition prevention
            async setImageSrc(img, file, loadingId = null) {
                // Cancel any existing load for this image
                if (appState.currentImagePromise) {
                    appState.currentImagePromise.cancelled = true;
                }
                
                const loadingPromise = new Promise(async (resolve, reject) => {
                    try {
                        // Generate image URL
                        let imageUrl = this.generateImageUrl(file);
                        
                        // Set up load handlers
                        const onLoad = () => {
                            if (!loadingPromise.cancelled) {
                                resolve();
                            }
                        };
                        
                        const onError = () => {
                            if (loadingPromise.cancelled) return;
                            
                            // Try fallback URL
                            let fallbackUrl;
                            if (appState.currentProviderType === 'googledrive') {
                                fallbackUrl = file.thumbnailLink ? 
                                    file.thumbnailLink.replace('=s220', '=s800') :
                                    `https://drive.google.com/thumbnail?id=${file.id}&sz=w800`;
                            } else {
                                fallbackUrl = file.downloadUrl || `https://graph.microsoft.com/v1.0/me/drive/items/${file.id}/content`;
                            }
                            
                            img.onerror = () => {
                                if (!loadingPromise.cancelled) {
                                    img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="150" height="150" viewBox="0 0 150 150" fill="none"%3E%3Crect width="150" height="150" fill="%23E5E7EB"/%3E%3Cpath d="M65 60H85V90H65V60Z" fill="%239CA3AF"/%3E%3Ccircle cx="75" cy="45" r="10" fill="%239CA3AF"/%3E%3C/svg%3E';
                                    resolve();
                                }
                            };
                            img.src = fallbackUrl;
                        };
                        
                        img.onload = onLoad;
                        img.onerror = onError;
                        img.src = imageUrl;
                        img.alt = file.name || 'Image';
                        
                        // Timeout protection
                        setTimeout(() => {
                            if (!loadingPromise.cancelled && img.complete === false) {
                                reject(new Error('Image load timeout'));
                            }
                        }, CONFIG.PERFORMANCE.IMAGE_LOAD_TIMEOUT);
                        
                    } catch (error) {
                        if (!loadingPromise.cancelled) {
                            reject(error);
                        }
                    }
                });
                
                appState.currentImagePromise = loadingPromise;
                return loadingPromise;
            },
            
            generateImageUrl(file) {
                if (appState.currentProviderType === 'googledrive') {
                    if (file.thumbnailLink) {
                        return file.thumbnailLink.replace('=s220', '=s1000');
                    }
                    return `https://drive.google.com/thumbnail?id=${file.id}&sz=w1000`;
                } else {
                    if (file.thumbnails && file.thumbnails.large) {
                        return file.thumbnails.large.url;
                    }
                    return file.downloadUrl || `https://graph.microsoft.com/v1.0/me/drive/items/${file.id}/content`;
                }
            },
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            },
            
            updateLoadingProgress(current, total) {
                appState.loadingProgress = { current, total };
                this.elements.loadingCounter.textContent = current;
                this.elements.loadingMessage.textContent = total ? 
                    `Processing ${current} of ${total} images...` : 
                    `Found ${current} images`;
                
                if (total > 0) {
                    const percentage = (current / total) * 100;
                    this.elements.loadingProgressBar.style.width = `${percentage}%`;
                }
            }
        };

        // ===== Enhanced Memory Manager =====
        class MemoryManager {
            constructor() {
                this.imageCache = new Map();
                this.maxCacheSize = 100; // Maximum number of images to keep in memory
                this.observeMemory();
            }
            
            observeMemory() {
                // Monitor memory usage and clean up when needed
                if ('memory' in performance) {
                    setInterval(() => {
                        const memInfo = performance.memory;
                        const usageRatio = memInfo.usedJSHeapSize / memInfo.jsHeapSizeLimit;
                        
                        if (usageRatio > 0.8) {
                            this.cleanup();
                        }
                    }, 30000); // Check every 30 seconds
                }
            }
            
            cleanup() {
                // Remove oldest images from cache
                if (this.imageCache.size > this.maxCacheSize) {
                    const entriesToRemove = this.imageCache.size - this.maxCacheSize;
                    const iterator = this.imageCache.keys();
                    
                    for (let i = 0; i < entriesToRemove; i++) {
                        const key = iterator.next().value;
                        const img = this.imageCache.get(key);
                        if (img && img.src) {
                            URL.revokeObjectURL(img.src);
                        }
                        this.imageCache.delete(key);
                    }
                }
                
                // Force garbage collection if available
                if (window.gc && typeof window.gc === 'function') {
                    window.gc();
                }
            }
            
            cacheImage(id, img) {
                this.imageCache.set(id, img);
                if (this.imageCache.size > this.maxCacheSize) {
                    this.cleanup();
                }
            }
            
            getCachedImage(id) {
                return this.imageCache.get(id);
            }
        }

        // ===== Enhanced Visual Cue Manager =====
        class VisualCueManager {
            constructor() {
                this.currentIntensity = localStorage.getItem('orbital8_visual_intensity') || 'medium';
                this.applyIntensity(this.currentIntensity);
            }
            
            setIntensity(level) {
                this.currentIntensity = level;
                this.applyIntensity(level);
                localStorage.setItem('orbital8_visual_intensity', level);
                
                document.querySelectorAll('.intensity-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.level === level);
                });
            }
            
            applyIntensity(level) {
                const settings = {
                    low: { glowOpacity: 0.3, rippleDuration: 1000, extraEffects: false },
                    medium: { glowOpacity: 0.6, rippleDuration: 1500, extraEffects: false },
                    high: { glowOpacity: 1.0, rippleDuration: 2000, extraEffects: true }
                };
                
                const config = settings[level];
                
                document.documentElement.style.setProperty('--glow-opacity', config.glowOpacity);
                document.documentElement.style.setProperty('--ripple-duration', `${config.rippleDuration}ms`);
                
                if (config.extraEffects) {
                    document.body.classList.add('high-intensity-mode');
                } else {
                    document.body.classList.remove('high-intensity-mode');
                }
            }
        }

        // ===== Enhanced Haptic Feedback Manager =====
        class HapticFeedbackManager {
            constructor() {
                this.isEnabled = localStorage.getItem('orbital8_haptic_enabled') !== 'false';
                this.isSupported = 'vibrate' in navigator;
                this.lastVibration = 0;
                
                const checkbox = document.getElementById('haptic-enabled');
                if (checkbox) checkbox.checked = this.isEnabled;
            }
            
            setEnabled(enabled) {
                this.isEnabled = enabled;
                localStorage.setItem('orbital8_haptic_enabled', enabled);
            }
            
            triggerFeedback(type) {
                if (!this.isEnabled || !this.isSupported) return;
                
                // Prevent too frequent vibrations
                const now = Date.now();
                if (now - this.lastVibration < 100) return;
                this.lastVibration = now;
                
                const pattern = CONFIG.UI.HAPTIC_PATTERNS[type.toUpperCase()];
                if (pattern && navigator.vibrate) {
                    navigator.vibrate(pattern);
                }
            }
        }

        // ===== Virtual Scroll Manager =====
        class VirtualScrollManager {
            constructor(container, itemHeight = CONFIG.VIRTUAL_SCROLL.ITEM_HEIGHT) {
                this.container = container;
                this.itemHeight = itemHeight;
                this.bufferSize = CONFIG.VIRTUAL_SCROLL.BUFFER_SIZE;
                this.overscan = CONFIG.VIRTUAL_SCROLL.OVERSCAN;
                this.items = [];
                this.renderedItems = new Map();
                this.scrollTop = 0;
                this.containerHeight = 0;
                this.totalHeight = 0;
                this.startIndex = 0;
                this.endIndex = 0;
                
                this.setupScrollListener();
            }
            
            setupScrollListener() {
                this.container.addEventListener('scroll', () => {
                    this.scrollTop = this.container.scrollTop;
                    this.updateVisibleRange();
                    this.renderVisibleItems();
                });
                
                // Update container height on resize
                const resizeObserver = new ResizeObserver(() => {
                    this.containerHeight = this.container.clientHeight;
                    this.updateVisibleRange();
                });
                resizeObserver.observe(this.container);
            }
            
            setItems(items) {
                this.items = items;
                this.totalHeight = items.length * this.itemHeight;
                this.updateTotalHeight();
                this.updateVisibleRange();
                this.renderVisibleItems();
            }
            
            updateTotalHeight() {
                utils.elements.virtualGridContainer.style.height = `${this.totalHeight}px`;
            }
            
            updateVisibleRange() {
                const visibleStart = Math.floor(this.scrollTop / this.itemHeight);
                const visibleEnd = Math.min(
                    this.items.length - 1,
                    Math.floor((this.scrollTop + this.containerHeight) / this.itemHeight)
                );
                
                this.startIndex = Math.max(0, visibleStart - this.overscan);
                this.endIndex = Math.min(this.items.length - 1, visibleEnd + this.overscan);
            }
            
            renderVisibleItems() {
                // Remove items that are no longer visible
                for (const [index, element] of this.renderedItems) {
                    if (index < this.startIndex || index > this.endIndex) {
                        element.remove();
                        this.renderedItems.delete(index);
                    }
                }
                
                // Add new visible items
                for (let i = this.startIndex; i <= this.endIndex; i++) {
                    if (!this.renderedItems.has(i) && this.items[i]) {
                        const element = this.createItemElement(this.items[i], i);
                        element.style.position = 'absolute';
                        element.style.top = `${i * this.itemHeight}px`;
                        element.style.width = '100%';
                        element.style.height = `${this.itemHeight}px`;
                        
                        utils.elements.gridContainer.appendChild(element);
                        this.renderedItems.set(i, element);
                    }
                }
            }
            
            createItemElement(item, index) {
                const div = document.createElement('div');
                div.className = 'grid-item';
                div.dataset.fileId = item.id;
                div.dataset.index = index;
                
                const img = document.createElement('img');
                img.className = 'grid-image';
                img.loading = 'lazy';
                
                // Use intersection observer for lazy loading
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const imageUrl = utils.generateImageUrl(item);
                            img.src = imageUrl;
