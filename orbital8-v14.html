<!-- Orbital8-R-2025-09-18 05:30 AM UTC -->
<!-- Change Log (R @ 2025-09-18 05:30 AM UTC)
     1. Implemented unified three-tier cache orchestration with inline sync worker to keep cloud and IndexedDB metadata aligned (last device wins).
     2. Refreshed focus-mode UI controls so the stack selector remains interactive and always available.
     3. Enlarged favourite heart affordance and hit area to simplify toggling, plus reduced swipe travel for faster stack actions.
     4. Added incremental metadata reconciliation, timestamped footer, and updated version subtitle "unified -3 tier performant - last device wins!".
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no, maximum-scale=1.0">
    <title>Orbital8 Performance R</title>
    <style>
        :root {
            --bg: #05060b;
            --panel: rgba(15, 23, 42, 0.72);
            --accent: #f59e0b;
            --accent-soft: rgba(245, 158, 11, 0.18);
            --border: rgba(148, 163, 184, 0.35);
            --text: #e2e8f0;
            --muted: #94a3b8;
            --danger: #ef4444;
            --success: #22c55e;
            --card-radius: 18px;
            --transition: 180ms ease;
        }

        *, *::before, *::after { box-sizing: border-box; }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: radial-gradient(circle at top, rgba(15, 23, 42, 0.9), #020617 70%);
            color: var(--text);
            overflow: hidden;
        }

        body.focus-mode .sidebar,
        body.focus-mode .viewer-footer,
        body.focus-mode .title-group,
        body.focus-mode .stack-pill-container,
        body.focus-mode .info-panel {
            opacity: 0;
            pointer-events: none;
        }

        body.focus-mode .viewer {
            padding: 32px 48px 48px;
        }

        body.focus-mode #focus-stack-name {
            background: rgba(15, 23, 42, 0.85);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.45);
        }

        .app-shell {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .top-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 24px;
            gap: 16px;
            backdrop-filter: blur(14px);
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.88), rgba(15, 23, 42, 0.6));
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            position: relative;
            z-index: 10;
        }

        .title-group h1 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            letter-spacing: 0.02em;
        }

        .title-group p {
            margin: 2px 0 0;
            font-size: 13px;
            color: var(--muted);
            letter-spacing: 0.04em;
        }

        .stack-selector {
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #focus-stack-name {
            border: 1px solid transparent;
            background: rgba(30, 41, 59, 0.9);
            color: var(--text);
            font-size: 14px;
            padding: 12px 16px;
            border-radius: 999px;
            cursor: pointer;
            transition: transform var(--transition), box-shadow var(--transition), border-color var(--transition);
            box-shadow: 0 8px 24px rgba(15, 23, 42, 0.35);
            min-width: 148px;
            text-align: left;
        }

        #focus-stack-name:hover, #focus-stack-name:focus-visible {
            transform: translateY(-1px);
            border-color: rgba(245, 158, 11, 0.6);
            box-shadow: 0 14px 32px rgba(245, 158, 11, 0.24);
            outline: none;
        }

        .stack-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            background: rgba(15, 23, 42, 0.96);
            border: 1px solid rgba(148, 163, 184, 0.28);
            border-radius: 16px;
            padding: 12px;
            display: none;
            flex-direction: column;
            gap: 8px;
            min-width: 180px;
            box-shadow: 0 18px 40px rgba(15, 23, 42, 0.45);
            z-index: 40;
        }

        .stack-dropdown.open { display: flex; }

        .stack-option {
            padding: 10px 14px;
            border-radius: 12px;
            border: none;
            background: rgba(30, 41, 59, 0.8);
            color: var(--text);
            text-align: left;
            cursor: pointer;
            font-size: 14px;
            transition: background var(--transition), transform var(--transition);
        }

        .stack-option.active {
            background: rgba(245, 158, 11, 0.24);
            color: var(--accent);
        }

        .stack-option:hover { transform: translateX(4px); }

        .status-group {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .status-pill {
            padding: 6px 12px;
            background: rgba(148, 163, 184, 0.16);
            border-radius: 999px;
            font-size: 12px;
            letter-spacing: 0.06em;
            text-transform: uppercase;
        }

        .text-button {
            background: transparent;
            color: var(--muted);
            border: 1px solid rgba(148, 163, 184, 0.25);
            border-radius: 12px;
            padding: 8px 14px;
            font-size: 12px;
            letter-spacing: 0.04em;
            cursor: pointer;
            transition: border-color var(--transition), color var(--transition), transform var(--transition);
        }

        .text-button:hover {
            color: var(--accent);
            border-color: rgba(245, 158, 11, 0.5);
            transform: translateY(-1px);
        }

        main {
            flex: 1;
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 20px;
            padding: 20px 24px;
        }

        .sidebar {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: var(--card-radius);
            padding: 20px 18px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            overflow: hidden;
        }

        .sidebar h2 {
            margin: 0;
            font-size: 15px;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            color: var(--muted);
        }

        .folder-list {
            list-style: none;
            margin: 0;
            padding: 0;
            overflow-y: auto;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .folder-item {
            border: 1px solid transparent;
            border-radius: 14px;
            padding: 12px 14px;
            background: rgba(15, 23, 42, 0.55);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 4px;
            transition: border-color var(--transition), transform var(--transition), background var(--transition);
        }

        .folder-item.active {
            border-color: rgba(245, 158, 11, 0.6);
            background: rgba(245, 158, 11, 0.1);
        }

        .folder-item:hover { transform: translateY(-1px); }

        .folder-name { font-size: 15px; font-weight: 600; }
        .folder-meta { font-size: 12px; color: var(--muted); }

        .viewer {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: var(--card-radius);
            padding: 28px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            position: relative;
            overflow: hidden;
        }

        .image-stage {
            position: relative;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 24px;
            background: radial-gradient(circle at top, rgba(148, 163, 184, 0.08), rgba(15, 23, 42, 0.8));
            border: 1px solid rgba(148, 163, 184, 0.1);
            overflow: hidden;
        }

        #current-image {
            max-width: 100%;
            max-height: 100%;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(15, 23, 42, 0.55);
            transition: transform 220ms ease;
        }

        .image-stage.empty::after {
            content: 'No images available in this stack';
            color: var(--muted);
            font-size: 16px;
        }

        .favorite-toggle {
            position: absolute;
            top: 22px;
            right: 22px;
            background: rgba(15, 23, 42, 0.76);
            border: 1px solid rgba(245, 158, 11, 0.35);
            border-radius: 28px;
            width: 72px;
            height: 72px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 160ms ease, border-color 160ms ease, background 160ms ease;
            box-shadow: 0 14px 32px rgba(15, 23, 42, 0.42);
        }

        .favorite-toggle:hover { transform: scale(1.05); }

        .favorite-toggle.active {
            background: rgba(245, 158, 11, 0.18);
            border-color: rgba(245, 158, 11, 0.8);
        }

        .heart-icon {
            font-size: 36px;
            line-height: 1;
            color: var(--muted);
        }

        .favorite-toggle.active .heart-icon { color: #f43f5e; }

        .stack-pill-container {
            position: absolute;
            left: 24px;
            top: 24px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .stack-pill {
            border: none;
            border-radius: 999px;
            padding: 9px 16px;
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            background: rgba(15, 23, 42, 0.75);
            color: var(--muted);
            cursor: pointer;
            transition: background var(--transition), color var(--transition), transform var(--transition);
        }

        .stack-pill.active {
            background: rgba(245, 158, 11, 0.2);
            color: var(--accent);
            transform: translateX(4px);
        }

        .info-panel {
            background: rgba(15, 23, 42, 0.78);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 16px;
            padding: 18px;
            display: grid;
            gap: 6px;
        }

        .info-panel h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
        }

        .info-panel p {
            margin: 0;
            font-size: 13px;
            color: var(--muted);
        }

        .viewer-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
        }

        .viewer-actions {
            display: flex;
            gap: 12px;
        }

        .pill-button {
            border: 1px solid rgba(148, 163, 184, 0.4);
            border-radius: 999px;
            padding: 10px 18px;
            background: rgba(15, 23, 42, 0.5);
            color: var(--text);
            letter-spacing: 0.05em;
            text-transform: uppercase;
            font-size: 12px;
            cursor: pointer;
            transition: background var(--transition), border-color var(--transition), color var(--transition);
        }

        .pill-button:hover {
            border-color: rgba(245, 158, 11, 0.4);
            color: var(--accent);
        }

        .toast {
            position: fixed;
            bottom: 28px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.92);
            color: var(--text);
            padding: 14px 22px;
            border-radius: 14px;
            border: 1px solid rgba(245, 158, 11, 0.4);
            box-shadow: 0 20px 40px rgba(15, 23, 42, 0.35);
            opacity: 0;
            pointer-events: none;
            transition: opacity 220ms ease;
            z-index: 60;
        }

        .toast.show { opacity: 1; }

        .app-footer {
            padding: 12px 20px;
            border-top: 1px solid rgba(148, 163, 184, 0.16);
            background: rgba(15, 23, 42, 0.82);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--muted);
            display: flex;
            justify-content: center;
        }

        @media (max-width: 1100px) {
            main {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }
            .sidebar { display: none; }
        }
    </style>
</head>
<body>
    <div class="app-shell">
        <header class="top-bar">
            <div class="stack-selector" id="stack-selector">
                <button id="focus-stack-name" aria-haspopup="true" aria-expanded="false">In Stack</button>
                <div class="stack-dropdown" id="stack-dropdown"></div>
            </div>
            <div class="title-group">
                <h1>Orbital8 Performance R</h1>
                <p>unified -3 tier performant - last device wins!</p>
            </div>
            <div class="status-group">
                <span class="status-pill" id="sync-status">Idle</span>
                <button class="text-button" id="simulate-remote">Simulate remote change</button>
                <button class="text-button" id="focus-mode-toggle">Toggle focus</button>
            </div>
        </header>
        <main>
            <aside class="sidebar">
                <h2>Stacks + Folders</h2>
                <ul class="folder-list" id="folder-list"></ul>
            </aside>
            <section class="viewer">
                <div class="image-stage" id="image-stage">
                    <div class="stack-pill-container" id="stack-pill-container"></div>
                    <img id="current-image" alt="Current asset" />
                    <button class="favorite-toggle" id="favorite-toggle" aria-label="Toggle favourite">
                        <span class="heart-icon" aria-hidden="true">&#10084;</span>
                    </button>
                </div>
                <div class="info-panel" id="info-panel">
                    <h3 id="image-name">Select a folder</h3>
                    <p id="image-notes">Metadata synchronizes automatically once IndexedDB initializes.</p>
                </div>
                <footer class="viewer-footer">
                    <div class="viewer-actions">
                        <button class="pill-button" id="prev-button">Previous</button>
                        <button class="pill-button" id="next-button">Next</button>
                    </div>
                    <div class="viewer-actions">
                        <button class="pill-button" id="reset-folder">Reload Folder</button>
                    </div>
                </footer>
            </section>
        </main>
        <footer class="app-footer">Orbital8 Performance Version R • 2025-09-18 05:30 AM UTC</footer>
    </div>
    <div class="toast" id="toast"></div>

    <script>
    // [R-2025-09-18T05:30Z #0] Constants and initial data definitions.
    const VERSION = 'R';
    const BUILD_TIMESTAMP = '2025-09-18T05:30:00Z';
    const FRIENDLY_TIMESTAMP = '2025-09-18 05:30 AM UTC';
    const SWIPE_THRESHOLD = 40; // [R-2025-09-18T05:30Z #3] Reduced swipe travel for faster stack navigation.
    const STACKS = ['in', 'out', 'priority', 'trash'];
    const STACK_LABELS = { in: 'In', out: 'Out', priority: 'Priority', trash: 'Trash' };

    const SAMPLE_FOLDERS = [
        { id: 'folder-aurora', name: 'Aurora Shoots', provider: 'OneDrive' },
        { id: 'folder-coast', name: 'Coast Study', provider: 'Google Drive' },
        { id: 'folder-urban', name: 'Urban Geometry', provider: 'OneDrive' }
    ];

    function deepClone(value) {
        try {
            if (typeof structuredClone === 'function') {
                return structuredClone(value);
            }
        } catch (error) {
            // noop fallback
        }
        return JSON.parse(JSON.stringify(value));
    }

    const INITIAL_CLOUD_STATE = {
        'folder-aurora': {
            id: 'folder-aurora',
            version: 3,
            files: [
                { id: 'aurora-1', name: 'Aurora Rise', stack: 'in', stackSequence: 8, favorite: false, notes: 'Dawn light shimmering.', thumbnail: 'https://picsum.photos/seed/aurora1/900/600', updatedAt: Date.now() - 200000 },
                { id: 'aurora-2', name: 'Aurora Crest', stack: 'priority', stackSequence: 6, favorite: true, notes: 'Peak wave detail.', thumbnail: 'https://picsum.photos/seed/aurora2/900/600', updatedAt: Date.now() - 160000 },
                { id: 'aurora-3', name: 'Aurora Dusk', stack: 'out', stackSequence: 4, favorite: false, notes: 'Evening reflections.', thumbnail: 'https://picsum.photos/seed/aurora3/900/600', updatedAt: Date.now() - 120000 }
            ],
            removed: []
        },
        'folder-coast': {
            id: 'folder-coast',
            version: 2,
            files: [
                { id: 'coast-1', name: 'Coastline North', stack: 'in', stackSequence: 7, favorite: false, notes: 'High tide textures.', thumbnail: 'https://picsum.photos/seed/coast1/900/600', updatedAt: Date.now() - 240000 },
                { id: 'coast-2', name: 'Foam Study', stack: 'in', stackSequence: 5, favorite: false, notes: 'Fast shutter foam.', thumbnail: 'https://picsum.photos/seed/coast2/900/600', updatedAt: Date.now() - 140000 },
                { id: 'coast-3', name: 'Jetty Lines', stack: 'priority', stackSequence: 2, favorite: true, notes: 'Leading lines.', thumbnail: 'https://picsum.photos/seed/coast3/900/600', updatedAt: Date.now() - 100000 }
            ],
            removed: []
        },
        'folder-urban': {
            id: 'folder-urban',
            version: 1,
            files: [
                { id: 'urban-1', name: 'Neon Alley', stack: 'in', stackSequence: 10, favorite: false, notes: 'Rainy reflections.', thumbnail: 'https://picsum.photos/seed/urban1/900/600', updatedAt: Date.now() - 180000 },
                { id: 'urban-2', name: 'Metro Lines', stack: 'out', stackSequence: 3, favorite: false, notes: 'Parallel forms.', thumbnail: 'https://picsum.photos/seed/urban2/900/600', updatedAt: Date.now() - 90000 }
            ],
            removed: []
        }
    };

    const Cloud = (() => {
        const state = deepClone(INITIAL_CLOUD_STATE);
        function listFolders() {
            return SAMPLE_FOLDERS.map(folder => {
                const remote = state[folder.id];
                return {
                    ...folder,
                    version: remote ? remote.version : 0,
                    count: remote ? remote.files.length : 0
                };
            });
        }
        function snapshot(folderId) {
            const remote = state[folderId];
            if (!remote) {
                return { id: folderId, version: 0, files: [], removed: [] };
            }
            return {
                id: remote.id,
                version: remote.version,
                files: remote.files.map(file => ({ ...file })),
                removed: remote.removed ? remote.removed.map(entry => ({ ...entry })) : []
            };
        }
        function applyOperations(folderId, ops) {
            if (!state[folderId]) {
                state[folderId] = { id: folderId, version: 0, files: [], removed: [] };
            }
            const bucket = state[folderId];
            bucket.version = Math.max(bucket.version + 1, ops.version || bucket.version + 1);
            const fileMap = new Map(bucket.files.map(file => [file.id, file]));
            if (Array.isArray(ops.upserts)) {
                ops.upserts.forEach(record => {
                    const normalized = normalizeRecord(record);
                    fileMap.set(normalized.id, normalized);
                });
            }
            if (Array.isArray(ops.deletes)) {
                ops.deletes.forEach(entry => {
                    const fileId = typeof entry === 'string' ? entry : entry.id;
                    fileMap.delete(fileId);
                    bucket.removed = bucket.removed || [];
                    bucket.removed.push({ id: fileId, removedAt: Date.now() });
                });
            }
            bucket.files = Array.from(fileMap.values());
            return snapshot(folderId);
        }
        function simulateChange(folderId) {
            const bucket = state[folderId];
            if (!bucket) return snapshot(folderId);
            const now = Date.now();
            bucket.version += 1;
            if (bucket.files.length > 0) {
                const target = bucket.files[Math.floor(Math.random() * bucket.files.length)];
                target.stack = target.stack === 'priority' ? 'in' : 'priority';
                target.updatedAt = now;
                target.notes = 'Remote update @ ' + new Date(now).toLocaleTimeString();
            } else {
                const newId = `${folderId}-new-${now}`;
                bucket.files.push({
                    id: newId,
                    name: 'Remote Drop ' + now,
                    stack: 'in',
                    stackSequence: 5,
                    favorite: false,
                    notes: 'Added remotely',
                    thumbnail: `https://picsum.photos/seed/${newId}/900/600`,
                    updatedAt: now
                });
            }
            return snapshot(folderId);
        }
        function normalizeRecord(record) {
            return {
                id: record.id,
                name: record.name,
                stack: STACKS.includes(record.stack) ? record.stack : 'in',
                stackSequence: typeof record.stackSequence === 'number' ? record.stackSequence : 0,
                favorite: Boolean(record.favorite),
                notes: record.notes || '',
                thumbnail: record.thumbnail || `https://picsum.photos/seed/${record.id}/900/600`,
                updatedAt: record.updatedAt || Date.now()
            };
        }
        return { listFolders, snapshot, applyOperations, simulateChange };
    })();

    // [R-2025-09-18T05:30Z #1] In-memory LRU cache to represent Tier 1 storage.
    const MemoryCache = (() => {
        const map = new Map();
        const order = [];
        const limit = 3;

        function remember(folder) {
            if (!folder || !folder.id) return;
            map.set(folder.id, deepClone(folder));
            touch(folder.id);
        }

        function touch(folderId) {
            const idx = order.indexOf(folderId);
            if (idx >= 0) order.splice(idx, 1);
            order.unshift(folderId);
            while (order.length > limit) {
                const evicted = order.pop();
                map.delete(evicted);
            }
        }

        function retrieve(folderId) {
            if (!map.has(folderId)) return null;
            touch(folderId);
            return deepClone(map.get(folderId));
        }

        function clear(folderId) {
            if (folderId) {
                map.delete(folderId);
                const idx = order.indexOf(folderId);
                if (idx >= 0) order.splice(idx, 1);
            } else {
                map.clear();
                order.length = 0;
            }
        }

        return { remember, retrieve, clear };
    })();

    // [R-2025-09-18T05:30Z #2] Inline worker to orchestrate IndexedDB (Tier 2) and cloud reconciliation (Tier 3).
    const SyncBridge = (() => {
        const workerSource = `(() => {
            const DB_NAME = 'orbital8-v2';
            const STORE_FOLDERS = 'folders';

            function openDb() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open(DB_NAME, 1);
                    req.onupgradeneeded = () => {
                        const db = req.result;
                        if (!db.objectStoreNames.contains(STORE_FOLDERS)) {
                            db.createObjectStore(STORE_FOLDERS, { keyPath: 'id' });
                        }
                    };
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            }

            function readFolder(db, folderId) {
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(STORE_FOLDERS, 'readonly');
                    const store = tx.objectStore(STORE_FOLDERS);
                    const request = store.get(folderId);
                    request.onsuccess = () => resolve(request.result || null);
                    request.onerror = () => reject(request.error);
                });
            }

            function writeFolder(db, folder) {
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(STORE_FOLDERS, 'readwrite');
                    const store = tx.objectStore(STORE_FOLDERS);
                    const request = store.put(folder);
                    request.onsuccess = () => resolve(folder);
                    request.onerror = () => reject(request.error);
                });
            }

            function normalizeRecord(record) {
                const safeStack = ['in', 'out', 'priority', 'trash'].includes(record.stack) ? record.stack : 'in';
                return {
                    id: record.id,
                    name: record.name || 'Untitled Asset',
                    stack: safeStack,
                    stackSequence: typeof record.stackSequence === 'number' ? record.stackSequence : 0,
                    favorite: Boolean(record.favorite),
                    notes: record.notes || '',
                    thumbnail: record.thumbnail || `https://picsum.photos/seed/${record.id}/900/600`,
                    updatedAt: record.updatedAt || Date.now()
                };
            }

            function mergeFolders(localFolder, cloudSnapshot, folderId) {
                const mergedIds = new Set();
                const cloudOps = { upserts: [], deletes: [] };
                const mergedFiles = [];
                const stats = { added: 0, updated: 0, removed: 0 };
                const localFiles = Array.isArray(localFolder?.files) ? localFolder.files : [];
                const remoteFiles = Array.isArray(cloudSnapshot?.files) ? cloudSnapshot.files : [];
                const remoteRemoved = Array.isArray(cloudSnapshot?.removed) ? cloudSnapshot.removed : [];
                const localMap = new Map(localFiles.map(file => [file.id, file]));
                const remoteMap = new Map(remoteFiles.map(file => [file.id, file]));

                remoteMap.forEach((remoteFile, id) => {
                    const localFile = localMap.get(id);
                    if (!localFile) {
                        mergedFiles.push(normalizeRecord(remoteFile));
                        mergedIds.add(id);
                        stats.added += 1;
                    } else {
                        const localUpdated = localFile.updatedAt || 0;
                        const remoteUpdated = remoteFile.updatedAt || 0;
                        if (remoteUpdated >= localUpdated) {
                            mergedFiles.push(normalizeRecord(remoteFile));
                            if (remoteUpdated > localUpdated) stats.updated += 1;
                        } else {
                            const normalized = normalizeRecord(localFile);
                            mergedFiles.push(normalized);
                            cloudOps.upserts.push(normalized);
                        }
                        mergedIds.add(id);
                        localMap.delete(id);
                    }
                });

                localMap.forEach(localFile => {
                    const removal = remoteRemoved.find(entry => entry.id === localFile.id);
                    if (removal) {
                        const localUpdated = localFile.updatedAt || 0;
                        const remoteRemovedAt = removal.removedAt || 0;
                        if (localUpdated > remoteRemovedAt) {
                            const normalized = normalizeRecord(localFile);
                            mergedFiles.push(normalized);
                            cloudOps.upserts.push(normalized);
                        } else {
                            stats.removed += 1;
                        }
                    } else {
                        const normalized = normalizeRecord(localFile);
                        mergedFiles.push(normalized);
                        cloudOps.upserts.push(normalized);
                    }
                    mergedIds.add(localFile.id);
                });

                if (remoteRemoved.length > 0) {
                    const removalIds = new Set(remoteRemoved.map(entry => entry.id));
                    for (let i = mergedFiles.length - 1; i >= 0; i -= 1) {
                        const fileId = mergedFiles[i].id;
                        if (removalIds.has(fileId)) {
                            const localFile = localFiles.find(file => file.id === fileId);
                            const localUpdated = localFile?.updatedAt || 0;
                            const remoteRemovedAt = remoteRemoved.find(entry => entry.id === fileId)?.removedAt || 0;
                            if (localUpdated > remoteRemovedAt) {
                                cloudOps.upserts.push(mergedFiles[i]);
                            } else {
                                mergedFiles.splice(i, 1);
                                stats.removed += 1;
                            }
                        }
                    }
                }

                const dedupeMap = new Map();
                mergedFiles.forEach(file => { dedupeMap.set(file.id, file); });
                const finalFiles = Array.from(dedupeMap.values());

                const baseVersion = Math.max(localFolder?.version || 0, cloudSnapshot?.version || 0);
                const resultFolder = {
                    id: cloudSnapshot?.id || localFolder?.id || folderId,
                    version: baseVersion + 1,
                    files: finalFiles,
                    lastSyncedAt: Date.now()
                };

                return { folder: resultFolder, cloudOps, stats };
            }

            function applyLocalChange(localFolder, payload) {
                const { folderId, fileId, updates } = payload;
                const files = Array.isArray(localFolder?.files) ? [...localFolder.files] : [];
                const index = files.findIndex(file => file.id === fileId);
                const timestamp = updates.updatedAt || Date.now();
                let updatedRecord;
                if (updates.delete === true) {
                    if (index >= 0) {
                        files.splice(index, 1);
                    }
                    return {
                        folder: {
                            id: localFolder?.id || folderId,
                            version: (localFolder?.version || 0) + 1,
                            files,
                            lastSyncedAt: Date.now()
                        },
                        cloudOps: { upserts: [], deletes: [fileId] },
                        stats: { added: 0, updated: 0, removed: 1 }
                    };
                }
                if (index >= 0) {
                    updatedRecord = { ...files[index], ...updates, updatedAt: timestamp };
                    files[index] = normalizeRecord(updatedRecord);
                } else {
                    updatedRecord = normalizeRecord({ id: fileId, ...updates, updatedAt: timestamp });
                    files.push(updatedRecord);
                }
                return {
                    folder: {
                        id: localFolder?.id || folderId,
                        version: (localFolder?.version || 0) + 1,
                        files,
                        lastSyncedAt: Date.now()
                    },
                    cloudOps: { upserts: [normalizeRecord(updatedRecord)], deletes: [] },
                    stats: { added: index >= 0 ? 0 : 1, updated: index >= 0 ? 1 : 0, removed: 0 }
                };
            }

            self.onmessage = async (event) => {
                const message = event.data || {};
                const { type, id } = message;
                try {
                    const db = await openDb();
                    if (type === 'request-folder') {
                        const folder = await readFolder(db, message.folderId);
                        self.postMessage({ type, id, status: 'success', folder: folder || null });
                    } else if (type === 'sync-folder') {
                        const local = await readFolder(db, message.folderId);
                        const merged = mergeFolders(local, message.cloudSnapshot, message.folderId);
                        await writeFolder(db, merged.folder);
                        self.postMessage({ type, id, status: 'success', folder: merged.folder, cloudOps: merged.cloudOps, stats: merged.stats });
                    } else if (type === 'apply-local') {
                        const local = await readFolder(db, message.folderId);
                        const next = applyLocalChange(local || { id: message.folderId, files: [], version: 0 }, message);
                        await writeFolder(db, next.folder);
                        self.postMessage({ type, id, status: 'success', folder: next.folder, cloudOps: next.cloudOps, stats: next.stats });
                    } else if (type === 'clear-folder') {
                        await writeFolder(db, { id: message.folderId, files: [], version: 0, lastSyncedAt: Date.now() });
                        self.postMessage({ type, id, status: 'success' });
                    } else {
                        self.postMessage({ type, id, status: 'error', message: 'Unknown worker message type' });
                    }
                } catch (error) {
                    self.postMessage({ type, id, status: 'error', message: String(error) });
                }
            };
        })();`;

        const worker = new Worker(URL.createObjectURL(new Blob([workerSource], { type: 'text/javascript' })));
        let counter = 0;
        const pending = new Map();

        worker.onmessage = (event) => {
            const response = event.data || {};
            if (response.id && pending.has(response.id)) {
                const { resolve, reject } = pending.get(response.id);
                pending.delete(response.id);
                if (response.status === 'success') {
                    resolve(response);
                } else {
                    reject(new Error(response.message || 'Worker error'));
                }
            }
        };

        function post(type, payload) {
            const id = ++counter;
            return new Promise((resolve, reject) => {
                pending.set(id, { resolve, reject });
                worker.postMessage({ ...payload, type, id });
                setTimeout(() => {
                    if (pending.has(id)) {
                        pending.delete(id);
                        reject(new Error('Worker timeout'));
                    }
                }, 10000);
            });
        }

        return { post };
    })();

    const state = {
        currentFolderId: null,
        currentStack: 'in',
        currentIndex: 0,
        activeFolder: null,
        isFocusMode: false,
        swipeStartX: null,
        swipeActive: false
    };

    const elements = {
        folderList: document.getElementById('folder-list'),
        stackDropdown: document.getElementById('stack-dropdown'),
        stackButton: document.getElementById('focus-stack-name'),
        stackSelector: document.getElementById('stack-selector'),
        stackPills: document.getElementById('stack-pill-container'),
        status: document.getElementById('sync-status'),
        image: document.getElementById('current-image'),
        imageStage: document.getElementById('image-stage'),
        infoName: document.getElementById('image-name'),
        infoNotes: document.getElementById('image-notes'),
        favoriteToggle: document.getElementById('favorite-toggle'),
        nextButton: document.getElementById('next-button'),
        prevButton: document.getElementById('prev-button'),
        resetButton: document.getElementById('reset-folder'),
        simulateRemote: document.getElementById('simulate-remote'),
        focusToggle: document.getElementById('focus-mode-toggle'),
        toast: document.getElementById('toast')
    };

    function showToast(message) {
        elements.toast.textContent = message;
        elements.toast.classList.add('show');
        setTimeout(() => elements.toast.classList.remove('show'), 2600);
    }

    function setStatus(text, tone) {
        elements.status.textContent = text;
        if (tone === 'success') {
            elements.status.style.color = '#22c55e';
        } else if (tone === 'warn') {
            elements.status.style.color = '#f59e0b';
        } else if (tone === 'error') {
            elements.status.style.color = '#ef4444';
        } else {
            elements.status.style.color = 'var(--muted)';
        }
    }

    function prepareFolder(folder) {
        if (!folder) return null;
        const grouped = { in: [], out: [], priority: [], trash: [] };
        folder.files.forEach(file => {
            const stackName = STACKS.includes(file.stack) ? file.stack : 'in';
            grouped[stackName].push(file);
        });
        STACKS.forEach(stack => {
            grouped[stack].sort((a, b) => (b.stackSequence || 0) - (a.stackSequence || 0));
        });
        folder.grouped = grouped;
        return folder;
    }

    function renderFolderList() {
        elements.folderList.innerHTML = '';
        Cloud.listFolders().forEach(folder => {
            const item = document.createElement('li');
            item.className = 'folder-item' + (folder.id === state.currentFolderId ? ' active' : '');
            item.dataset.id = folder.id;
            const name = document.createElement('div');
            name.className = 'folder-name';
            name.textContent = folder.name;
            const meta = document.createElement('div');
            meta.className = 'folder-meta';
            meta.textContent = `${folder.provider} • ${folder.count} assets • v${folder.version}`;
            item.appendChild(name);
            item.appendChild(meta);
            item.addEventListener('click', () => loadFolder(folder.id));
            elements.folderList.appendChild(item);
        });
    }

    function renderStackDropdown() {
        elements.stackDropdown.innerHTML = '';
        STACKS.forEach(stack => {
            const option = document.createElement('button');
            option.className = 'stack-option' + (stack === state.currentStack ? ' active' : '');
            option.textContent = STACK_LABELS[stack];
            option.dataset.stack = stack;
            option.addEventListener('click', () => {
                closeStackDropdown();
                switchStack(stack);
            });
            elements.stackDropdown.appendChild(option);
        });
    }

    function closeStackDropdown() {
        elements.stackDropdown.classList.remove('open');
        elements.stackButton.setAttribute('aria-expanded', 'false');
    }

    function toggleStackDropdown() {
        const isOpen = elements.stackDropdown.classList.toggle('open');
        elements.stackButton.setAttribute('aria-expanded', String(isOpen));
    }

    function renderStackPills(folder) {
        elements.stackPills.innerHTML = '';
        STACKS.forEach(stack => {
            const pill = document.createElement('button');
            pill.className = 'stack-pill' + (stack === state.currentStack ? ' active' : '');
            const count = folder.grouped?.[stack]?.length || 0;
            pill.textContent = `${STACK_LABELS[stack]} (${count})`;
            pill.dataset.stack = stack;
            pill.addEventListener('click', () => switchStack(stack));
            elements.stackPills.appendChild(pill);
        });
    }

    function refreshStackUI(folder) {
        elements.stackButton.textContent = `${STACK_LABELS[state.currentStack]} Stack`;
        renderStackDropdown();
        renderStackPills(folder);
    }

    function renderCurrentImage() {
        const folder = state.activeFolder;
        if (!folder) return;
        const stackItems = folder.grouped[state.currentStack] || [];
        if (stackItems.length === 0) {
            elements.imageStage.classList.add('empty');
            elements.image.src = '';
            elements.infoName.textContent = 'No images in this stack';
            elements.infoNotes.textContent = 'Use the stack selector to switch or sync to fetch updates.';
            elements.favoriteToggle.classList.remove('active');
            return;
        }
        elements.imageStage.classList.remove('empty');
        if (state.currentIndex >= stackItems.length) {
            state.currentIndex = 0;
        }
        const record = stackItems[state.currentIndex];
        elements.image.src = record.thumbnail;
        elements.infoName.textContent = record.name;
        elements.infoNotes.textContent = record.notes || 'Metadata synced';
        elements.favoriteToggle.classList.toggle('active', Boolean(record.favorite));
        elements.favoriteToggle.dataset.fileId = record.id;
    }

    async function loadFolder(folderId, options = { forceSync: false }) {
        setStatus('Loading…', 'warn');
        state.currentFolderId = folderId;
        state.currentIndex = 0;
        const cached = MemoryCache.retrieve(folderId);
        let folderData = cached;
        if (!folderData || options.forceSync) {
            try {
                const response = await SyncBridge.post('request-folder', { folderId });
                if (response.folder) {
                    folderData = response.folder;
                }
            } catch (error) {
                console.error(error);
            }
        }
        if (!folderData) {
            folderData = Cloud.snapshot(folderId);
        }
        folderData = prepareFolder(folderData);
        state.activeFolder = folderData;
        MemoryCache.remember(folderData);
        renderFolderList();
        refreshStackUI(folderData);
        renderCurrentImage();
        setStatus('Syncing…', 'warn');
        const cloudSnapshot = Cloud.snapshot(folderId);
        try {
            const result = await SyncBridge.post('sync-folder', { folderId, cloudSnapshot });
            const merged = prepareFolder(result.folder);
            state.activeFolder = merged;
            MemoryCache.remember(merged);
            refreshStackUI(merged);
            renderCurrentImage();
            if (result.cloudOps) {
                Cloud.applyOperations(folderId, result.cloudOps);
                renderFolderList();
            }
            const changed = result.stats;
            setStatus(`Synced • +${changed.added} / Δ${changed.updated} / −${changed.removed}`, 'success');
        } catch (error) {
            console.error(error);
            setStatus('Sync failed', 'error');
            showToast('Sync worker error: ' + error.message);
        }
    }

    function switchStack(stack) {
        state.currentStack = stack;
        state.currentIndex = 0;
        refreshStackUI(state.activeFolder);
        renderCurrentImage();
    }

    async function toggleFavorite() {
        if (!state.activeFolder) return;
        const stackItems = state.activeFolder.grouped[state.currentStack] || [];
        if (stackItems.length === 0) return;
        const record = stackItems[state.currentIndex];
        const nextFavorite = !record.favorite;
        record.favorite = nextFavorite;
        record.updatedAt = Date.now();
        renderCurrentImage();
        MemoryCache.remember(state.activeFolder);
        try {
            const result = await SyncBridge.post('apply-local', {
                folderId: state.currentFolderId,
                fileId: record.id,
                updates: { favorite: nextFavorite, updatedAt: record.updatedAt }
            });
            const merged = prepareFolder(result.folder);
            state.activeFolder = merged;
            MemoryCache.remember(merged);
            refreshStackUI(merged);
            renderCurrentImage();
            if (result.cloudOps) {
                Cloud.applyOperations(state.currentFolderId, result.cloudOps);
                renderFolderList();
            }
            setStatus('Favourite updated', 'success');
        } catch (error) {
            console.error(error);
            setStatus('Favourite failed', 'error');
        }
    }

    function nextImage(delta = 1) {
        if (!state.activeFolder) return;
        const stackItems = state.activeFolder.grouped[state.currentStack] || [];
        if (stackItems.length === 0) return;
        state.currentIndex = (state.currentIndex + delta + stackItems.length) % stackItems.length;
        renderCurrentImage();
    }

    function bindSwipe() {
        elements.imageStage.addEventListener('pointerdown', event => {
            state.swipeActive = true;
            state.swipeStartX = event.clientX;
        });
        elements.imageStage.addEventListener('pointerup', event => {
            if (!state.swipeActive) return;
            const delta = event.clientX - state.swipeStartX;
            state.swipeActive = false;
            if (Math.abs(delta) < SWIPE_THRESHOLD) return;
            if (delta < 0) {
                nextImage(1);
            } else {
                nextImage(-1);
            }
        });
        elements.imageStage.addEventListener('pointerleave', () => {
            state.swipeActive = false;
        });
    }

    function toggleFocusMode() {
        state.isFocusMode = !state.isFocusMode;
        document.body.classList.toggle('focus-mode', state.isFocusMode);
        if (state.isFocusMode) {
            showToast('Focus mode enabled');
        } else {
            showToast('Focus mode disabled');
        }
    }

    function setupStackSelector() {
        elements.stackButton.addEventListener('click', event => {
            event.stopPropagation();
            toggleStackDropdown();
        });
        document.addEventListener('click', event => {
            if (!elements.stackSelector.contains(event.target)) {
                closeStackDropdown();
            }
        });
    }

    async function simulateRemoteChange() {
        if (!state.currentFolderId) {
            showToast('Select a folder first');
            return;
        }
        Cloud.simulateChange(state.currentFolderId);
        renderFolderList();
        await loadFolder(state.currentFolderId, { forceSync: true });
        showToast('Remote change applied');
    }

    async function reloadFolder() {
        if (!state.currentFolderId) return;
        MemoryCache.clear(state.currentFolderId);
        await loadFolder(state.currentFolderId, { forceSync: true });
    }

    function registerEvents() {
        elements.favoriteToggle.addEventListener('click', toggleFavorite);
        elements.nextButton.addEventListener('click', () => nextImage(1));
        elements.prevButton.addEventListener('click', () => nextImage(-1));
        elements.resetButton.addEventListener('click', reloadFolder);
        elements.simulateRemote.addEventListener('click', simulateRemoteChange);
        elements.focusToggle.addEventListener('click', toggleFocusMode);
        bindSwipe();
        setupStackSelector();
    }

    async function boot() {
        renderFolderList();
        renderStackDropdown();
        registerEvents();
        setStatus('Ready • ' + FRIENDLY_TIMESTAMP);
        const initialFolder = SAMPLE_FOLDERS[0]?.id;
        if (initialFolder) {
            await loadFolder(initialFolder);
        }
    }

    boot();
    </script>
</body>
</html>
