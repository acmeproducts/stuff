<!-- [AI Jobs Kanban]-v13-2025-11-01 10:20 PM -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>AI Jobs Kanban</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
:root{
  --bg:#f7f7f9;
  --panel:#ffffff;
  --text:#111;
  --muted:#666;
  --accent:#1f6feb;
  --border:#d7d7dc;
  --danger:#b3261e;
  --highlight:#ff7a00;
  --search:#14532d;
  --ok:#166534;
  --err:#7f1d1d;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;font-family:system-ui,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;background:var(--bg);color:var(--text)}
header{position:sticky;top:0;z-index:20;background:var(--panel);border-bottom:1px solid var(--border);}
.toolbar{padding:10px 16px;display:flex;gap:8px;align-items:center;flex-wrap:nowrap;white-space:nowrap;overflow:auto}
.toolbar .btn{flex:0 0 auto}
.searchbar{padding:10px 16px;border-top:1px solid var(--border);display:grid;grid-template-columns:1fr auto auto;gap:8px;align-items:center}
#search{width:100%;padding:10px 12px;border:1px solid var(--border);border-radius:10px;font-size:15px}
#btnClearSearch{padding:8px 10px;border:1px solid var(--border);background:#fff;border-radius:8px;cursor:pointer}
.btn{padding:10px 14px;border:1px solid var(--border);background:var(--panel);border-radius:10px;cursor:pointer;font-weight:600}
.btn.primary{background:var(--accent);color:#fff;border-color:var(--accent)}
.btn.danger{background:var(--danger);color:#fff;border-color:var(--danger)}
.btn.small{padding:6px 8px;font-size:12px}
.btn.icon{padding:4px 8px;font-size:14px;line-height:1}
.btn:disabled{opacity:.6;cursor:not-allowed}
/* Footer updated for centering and required text format */
.footer{
    padding:8px 16px;
    color:var(--muted);
    font-size:12px;
    text-align:center; 
    width: 100%;
    margin-top: 10px;
}

/* Layout */
main#board{padding:16px;gap:16px;align-items:start;}
main#board[data-layout="horizontal"], main#board[data-layout="auto"]{display:grid;grid-template-columns:repeat(auto-fit, minmax(320px,1fr));}
main#board[data-layout="vertical"]{display:flex;flex-direction:column}

/* Orientation-aware overrides when in AUTO layout */
@media (orientation:portrait){
  /* compact toolbar keep on one line */
  .toolbar{gap:6px}
  .btn{padding:8px 10px;font-size:14px}
  main#board[data-layout="auto"]{grid-template-columns:1fr} /* stack lanes in portrait */
}
@media (orientation:landscape){
  main#board[data-layout="auto"]{grid-template-columns:repeat(auto-fit, minmax(300px,1fr))} /* side-by-side lanes in landscape */
}

/* Lanes */
.lane{background:var(--panel);border:1px solid var(--border);border-radius:14px;display:flex;flex-direction:column;min-height:0}
.lane-header{padding:10px 12px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;font-weight:700;gap:8px}
.lane-title{display:flex;align-items:center;gap:8px}
.lane-actions{display:flex;align-items:center;gap:6px}
.lane-body{padding:8px;display:flex;flex-direction:column;gap:8px;min-height:0}
.lane-body.collapsed{display:none}

/* Cards */
.card{
  background:#fff;
  border:2px solid var(--border); /* grey oval border */
  border-radius:14px;
  display:flex;flex-direction:column;gap:6px;
  padding:8px 12px;
  cursor:grab;
  min-height:46px;
  box-shadow:0 1px 0 rgba(0,0,0,.03);
  -webkit-user-drag: element;
  user-select:none;
  position:relative;
  transition:border-color .08s ease, box-shadow .08s ease;
}
.card *{ -webkit-user-drag: none; }
.card.dragging{
  opacity:.92;
  border-color:#000;             /* source card outlined black */
  box-shadow:0 0 0 2px #000 inset;
}
.card.search-hit{border-color:var(--search)}
.card-line{display:flex;align-items:center;gap:10px;flex-wrap:nowrap;width:100%;min-width:0}
.card-title{font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.card-platform{font-size:12px;color:var(--muted);border:1px solid var(--border);padding:2px 8px;border-radius:999px;flex:0 0 auto}
.card-links a{font-size:12px;margin-left:8px;text-decoration:none}
.card-tags{display:flex;gap:6px;flex-wrap:wrap}
.chip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border);border-radius:999px;padding:2px 8px;background:#fff;font-size:12px}
.chip button{border:none;background:transparent;outline:none;padding:0;margin:0;cursor:pointer;font-size:13px;font-weight:800;line-height:1;color:#444}
.chip button:hover{color:#000}
/* Landing target outline (orange) */
.drop-highlight{ border-color:var(--highlight) !important; box-shadow:0 0 0 2px var(--highlight) inset; }

/* Dialogs */
.hidden{display:none}
dialog{border:none;border-radius:14px;padding:0;width:min(900px,96vw)}
.modal{position:relative;padding:16px;background:var(--panel);border:1px solid var(--border);border-radius:14px}
.modal .modal-close{position:absolute;top:10px;right:12px;border:none;background:transparent;font-weight:800;font-size:18px;cursor:pointer;color:#777;line-height:1;padding:2px 6px;border-radius:8px}
.modal .modal-close:hover{color:#000;background:#f2f2f6}
.field{display:flex;flex-direction:column;gap:6px;margin:10px 0}
.field input,.field textarea,.field select{border:1px solid var(--border);border-radius:10px;padding:10px;font-size:14px;width:100%}
.grid-2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}

/* Notes textarea scrollable */
#fNotes{max-height:40vh;overflow:auto;resize:vertical}

/* Search preview */
.results{position:sticky;top:96px;margin:0 16px 8px 16px;background:var(--panel);border:1px solid var(--border);border-radius:10px;max-height:260px;overflow:auto}
.result-item{padding:10px 12px;border-top:1px solid var(--border);cursor:pointer}
.result-item:first-child{border-top:none}
.result-item:hover{background:#f1f5ff}
.muted{color:var(--muted);font-size:12px}
.timepill{font-size:12px;color:#555;border:1px solid var(--border);padding:2px 8px;border-radius:999px;margin-left:8px}

/* Tooltip */
#tooltip{position:fixed;z-index:50;pointer-events:none;background:#fff;color:#111;border:1px solid var(--border);border-radius:12px;box-shadow:0 8px 28px rgba(0,0,0,.12);padding:10px 12px;max-width:360px;display:none}
#tooltip .t-title{font-weight:800;margin-bottom:4px}
#tooltip .t-meta{font-size:12px;color:#888;margin-bottom:4px}
#tooltip .t-tags{font-size:12px;color:#666;margin-bottom:6px}
#tooltip .t-notes{font-size:13px;white-space:pre-wrap;max-height:120px;overflow:auto}
#tooltip .t-notes a{color:#1f6feb;text-decoration:none}
#tooltip .t-notes img{max-width:100%;height:auto;border-radius:8px;margin-top:6px}

/* Toast */
#toast{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);background:#fff;border:1px solid var(--border);box-shadow:0 8px 24px rgba(0,0,0,.18);border-left:6px solid var(--ok);padding:10px 14px;border-radius:12px;display:none;z-index:60;min-width:260px}
#toast.err{border-left-color:var(--err)}
#toast .tmsg{font-weight:700}
#toast .tdesc{font-size:12px;color:#555;margin-top:2px}

/* Responsive tightening */
@media (max-width:900px){
  main#board[data-layout="horizontal"], main#board[data-layout="auto"]{grid-template-columns:1fr}
}

/* New style for emoji picker */
#emojiPicker{
  position:fixed;
  z-index:70;
  background:var(--panel);
  border:1px solid var(--border);
  border-radius:10px;
  box-shadow:0 4px 12px rgba(0,0,0,.15);
  padding:4px;
  max-width:200px;
  display:none;
  cursor:default;
  /* Added for the close button */
  padding-top: 30px;
  position: relative;
}
.emoji-item{
  display:inline-block;
  padding:4px 6px;
  margin:2px;
  cursor:pointer;
  border-radius:6px;
  font-size:18px;
  line-height:1;
  transition:background .1s;
}
.emoji-item:hover{background:#f0f0f0}

/* New style for picker close button */
#emojiPickerClose{
    position: absolute;
    top: 4px;
    right: 6px;
    border: none;
    background: transparent;
    font-weight: 800;
    font-size: 18px;
    cursor: pointer;
    color: #777;
    line-height: 1;
    padding: 2px 6px;
    border-radius: 8px;
}
#emojiPickerClose:hover{
    color: #000;
    background: #f2f2f6;
}
</style>
</head>
<body>
<header>
  <div class="toolbar">
    <button id="btnNew" class="btn">New</button>
    <button id="btnManualSave" class="btn primary">Save Changes</button>
    <button id="btnArchive" class="btn">Archive</button>
    <button id="btnSettings" class="btn">Settings</button>
    <button id="btnExport" class="btn">Export</button>
    <button id="btnImport" class="btn">Import</button>
    <input id="fileImport" type="file" accept="application/json" class="hidden" aria-hidden="true" tabindex="-1" />
  </div>
  <div class="searchbar">
    <input id="search" placeholder="Omni searchâ€¦ (use -term to exclude)" aria-label="Omni search"/>
    <button id="btnClearSearch" title="Clear search">Ã—</button>
    <span class="muted" id="searchCount"></span>
  </div>
</header>

<div id="resultsContainer"></div>
<main id="board" aria-live="polite" data-layout="auto"></main>
<div class="footer" id="status"></div>
<div id="toast"><div class="tmsg"></div><div class="tdesc"></div></div>

<!-- Editor -->
<dialog id="editDialog">
  <form method="dialog" class="modal" id="editForm">
    <button type="button" id="editorCloseBtn" class="modal-close" title="Close">Ã—</button>
    <h3 id="editTitle">Card</h3>

    <div class="field">
      <label for="fTitle">Title</label>
      <div class="row">
        <input id="fTitle" placeholder="Short title" autofocus/>
        <button id="btnSaveAndNew" class="btn small primary" value="save_new">Save & New</button>
      </div>
    </div>

    <div class="grid-2">
      <div class="field">
        <label for="fPlatform">Platform</label>
        <select id="fPlatform"></select>
      </div>
      <div class="field">
        <label for="fStage">Lane</label>
        <select id="fStage"></select>
      </div>
    </div>

    <div class="grid-2">
      <div class="field">
        <label for="fDev">Dev Link</label>
        <input id="fDev" type="url" placeholder="https://â€¦"/>
      </div>
      <div class="field">
        <label for="fLive">Live Link</label>
        <input id="fLive" type="url" placeholder="https://â€¦"/>
      </div>
    </div>

    <div class="field">
      <label>Tags</label>
      <div id="tagChips" class="chips" aria-live="polite"></div>
      <div class="tag-input-row">
        <input id="tagInput" placeholder="type a tag, press Enter" />
      </div>
      <div class="suggestions" id="tagSuggestions" aria-label="Previously used tags"></div>
      <input id="fTags" class="hidden" />
    </div>

    <!-- Attachments -->
    <div class="field">
      <label for="fFiles">Attachments</label>
      <div class="row">
        <input id="fFiles" type="file" multiple />
        <button id="btnClearFiles" type="button" class="btn small">Clear selection</button>
      </div>
      <div id="fileChips" class="chips" aria-live="polite"></div>
    </div>

    <div class="field">
      <label for="fNotes">Notes (paste images or URLs)</label>
      <textarea id="fNotes" rows="6" placeholder="Paste images here (from clipboard) or type/paste URLsâ€¦"></textarea>
    </div>

    <div class="row">
      <button class="btn primary" value="save" id="btnSave">Save</button>
      <button class="btn" value="cancel" id="btnCancel">Cancel</button>
      <button id="btnDelete" class="btn danger" value="delete">Archive</button>
    </div>
  </form>
</dialog>

<!-- Archive Dialog -->
<dialog id="archiveDialog">
  <form method="dialog" class="modal">
    <h3>Archive</h3>
    <div id="archiveList" style="max-height:60vh; overflow:auto; margin-top:8px;"></div>
    <div class="row" style="margin-top:10px;">
      <button class="btn danger" value="empty" id="btnEmptyArchive">Empty Archive</button>
      <button class="btn" value="close">Close</button>
    </div>
  </form>
</dialog>

<!-- Search Modal -->
<dialog id="searchDialog">
  <form method="dialog" class="modal">
    <h3>Search results</h3>
    <div id="searchList" style="max-height:60vh; overflow:auto;"></div>
    <div class="row" style="margin-top:10px;">
      <button class="btn" value="close">Close</button>
    </div>
  </form>
</dialog>

<!-- Settings -->
<dialog id="settingsDialog">
  <form method="dialog" class="modal" id="settingsForm">
    <h3>Settings</h3>
    
    <div class="grid-2">
        <div class="field">
            <label for="sTitleLen">Card Title Max Length</label>
            <input id="sTitleLen" type="number" min="1" step="1"/>
        </div>
        <div class="field">
            <label for="sChipLen">Chip/Tag Max Length</label>
            <input id="sChipLen" type="number" min="1" step="1"/>
        </div>
    </div>

    <div class="field">
      <label for="sPlatforms">Platforms (comma-separated)</label>
      <input id="sPlatforms" value="Gemini, Claude, ChatGPT, Perplexity"/>
    </div>
    <div class="field">
      <label for="sStages">Stages (leftâ†’right, topâ†’bottom order)</label>
      <input id="sStages" value="Done, Doing, Next"/>
    </div>
    <div class="field">
      <label for="sLayout">Lanes layout</label>
      <select id="sLayout">
        <option value="auto" selected>Auto (portrait stacked, landscape side-by-side)</option>
        <option value="horizontal">Horizontal</option>
        <option value="vertical">Vertical</option>
      </select>
    </div>
    <div class="field">
      <label for="sEmojis">Custom Emojis (space or comma-separated)</label>
      <input id="sEmojis"/>
      <div class="row" style="margin-top:6px;gap:6px;">
        <button class="btn small" type="button" id="btnExportEmojis">Export Emojis</button>
        <button class="btn small" type="button" id="btnImportEmojis">Import Emojis</button>
        <input id="fileImportEmojis" type="file" accept="application/json" class="hidden" aria-hidden="true" tabindex="-1" />
      </div>
    </div>
    <div class="row">
      <button class="btn primary" value="save">Apply</button>
      <button class="btn" value="cancel">Cancel</button>
      <button class="btn danger" id="btnReset" value="reset">Reset Board</button>
    </div>
  </form>
</dialog>

<!-- Tooltip -->
<div id="tooltip" role="tooltip" aria-hidden="true">
  <div class="t-title"></div>
  <div class="t-meta"></div>
  <div class="t-tags"></div>
  <div class="t-notes"></div>
</div>

<!-- Emoji Picker -->
<div id="emojiPicker" role="listbox" aria-hidden="true">
    <button id="emojiPickerClose" title="Close picker">Ã—</button>
</div>

<script>
const BUILD = "2025-10-28";
/* ===== New Default Configuration (from uploaded JSON) ===== */
const UPLOADED_CONFIG = {
  stages: ["Next", "Doing", "Done"],
  platforms: ["Default", "Codex", "Gemini", "Claude", "ChatGPT", "Perplexity"],
  emojis: ["ðŸŸ¢", "ðŸŸ¡", "ðŸ”´", "â­", "ðŸ˜¡", "ðŸ¤¬", "ðŸ™ƒ", "ðŸ˜ƒ"], // Use last working emoji list for settings default
  titleLimit: 20, 
  chipLimit: 10
};

/* ===== Persistence & State Keys ===== */
const STABLE_KEY = "ai_jobs_kanban";
const TAGS_KEY = "ai_jobs_kanban_tags";
const EMOJIS_KEY = "ai_jobs_kanban_emojis";
const LEGACY_KEYS = ["ai_jobs_kanban_v3","ai_jobs_kanban_v4","ai_jobs_kanban_v5","ai_jobs_kanban_v6","ai_jobs_kanban_v7"];
let dirty=false, saveTimer=null;

function trySave(key, value){ try{ localStorage.setItem(key, value); return localStorage.getItem(key)===value; }catch(e){ console.warn(e); return false; } }

function persistNow(){ 
    const ok=trySave(STABLE_KEY, JSON.stringify(state)); 
    setStatus((ok? "Saved" : "Save failed")+" â€¢ Config: Default â€¢ "+fmtFullDate(new Date())); 
    dirty=false; 
}

function scheduleSave(){ dirty=true; clearTimeout(saveTimer); saveTimer=setTimeout(persistNow, 250); }

// --- REVAMPED loadState ---
function loadState(){
  let raw = localStorage.getItem(STABLE_KEY);
  if(raw){ 
    try{ 
      const obj=JSON.parse(raw); 
      // Basic validation: must have the core lists, ignore if it's junk
      if(obj?.cards && obj?.stages && obj?.platforms) return obj; 
    }catch(e){
      console.warn("Found corrupt state in local storage:", e);
      // If corrupt, fall through to create new baseline
    } 
  }
  
  // If no stable, valid state found, create the new baseline from UPLOADED_CONFIG
  const newBaseline = {
    stages: UPLOADED_CONFIG.stages,
    platforms: UPLOADED_CONFIG.platforms,
    cards: [], // Crucially, start with NO cards
    archive: [],
    collapsed: {},
    layout: "auto",
    titleLimit: UPLOADED_CONFIG.titleLimit,
    chipLimit: UPLOADED_CONFIG.chipLimit
  };

  // Persist the new baseline immediately so it becomes the new persisted state
  trySave(STABLE_KEY, JSON.stringify(newBaseline)); 
  return newBaseline;
}
// --- END REVAMP ---

function loadTagHistory(){ try{ const arr=JSON.parse(localStorage.getItem(TAGS_KEY)||"[]"); return Array.isArray(arr)?arr:[]; }catch{ return []; } }
function saveTagHistory(list){ const uniq=[...new Set(list.map(t=>String(t).toLowerCase()))]; trySave(TAGS_KEY, JSON.stringify(uniq)); return uniq; }
function loadEmojis(){ 
    try{ 
        const raw=localStorage.getItem(EMOJIS_KEY); 
        // If saved emojis exist, use them. Otherwise, use the new UPLOADED_CONFIG default.
        return raw ? JSON.parse(raw) : UPLOADED_CONFIG.emojis; 
    }catch{ 
        return UPLOADED_CONFIG.emojis; 
    } 
}
function saveEmojis(list){ const arr=Array.isArray(list)?list.map(s=>String(s).trim()).filter(Boolean):[]; trySave(EMOJIS_KEY, JSON.stringify(arr)); customEmojis=arr; }

/* ===== App State ===== */
// State is loaded via the new persistent strategy
let state = loadState();

let tagHistory = loadTagHistory();
let customEmojis = loadEmojis(); // Load/default emojis

const $ = s=>document.querySelector(s), $$ = s=>Array.from(document.querySelectorAll(s));
function uid(){return Math.random().toString(36).slice(2,10)}

/* ===== Ordering ===== */
function stageCards(stage){ return state.cards.filter(c=>c.stage===stage).sort((a,b)=> (a.pos??0)-(b.pos??0) || (a.createdAt-b.createdAt)); }
function topPos(stage){ const list=stageCards(stage); return list.length? (list[0].pos??1000)-1000 : 1000; }
function moveToStageAt(id, stage, index){
  const c=state.cards.find(x=>x.id===id); if(!c) return;
  const list=stageCards(stage); let pos;
  if(index<=0 || list.length===0) pos=(list[0]?.pos??1000)-1000;
  else if(index>=list.length) pos=(list[list.length-1].pos??1000)+1000;
  else { const prev=list[index-1], next=list[index]; pos=((prev.pos??0)+(next.pos??0))/2; }
  c.stage=stage; c.pos=pos; c.updatedAt=Date.now(); maybeRebalance(stage); scheduleSave(); render(); focusCard(id);
}
function maybeRebalance(stage){ const list=stageCards(stage); for(let i=1;i<list.length;i++){ if(Math.abs((list[i].pos??0)-(list[i-1].pos??0))<0.5){ list.forEach((c,i)=> c.pos=(i+1)*1000); break; } } }

/* ===== Rendering ===== */
let draggingId=null, highlightEl=null, editorDirty=false;
function render(){
  $("#sPlatforms").value = state.platforms.join(", ");
  $("#sStages").value = state.stages.join(", ");
  $("#sLayout").value = state.layout;
  $("#sEmojis").value = customEmojis.join(" ");
  $("#sTitleLen").value = state.titleLimit;
  $("#sChipLen").value = state.chipLimit;

  const board=$("#board"); board.dataset.layout=state.layout; board.innerHTML="";
  state.stages.forEach(stage=>{
    const lane=document.createElement("section"); lane.className="lane"; lane.dataset.stage=stage;
    const head=document.createElement("div"); head.className="lane-header";
    const titleWrap=document.createElement("div"); titleWrap.className="lane-title";
    const title=document.createElement("span"); title.textContent=stage;
    const count=document.createElement("span"); count.className="muted"; count.textContent=state.cards.filter(c=>c.stage===stage).length;
    titleWrap.append(title,count);

    const actions=document.createElement("div"); actions.className="lane-actions";
    const toggleBtn=document.createElement("button"); toggleBtn.className="btn icon"; toggleBtn.title="Collapse/Expand"; toggleBtn.textContent = state.collapsed[stage] ? "ï¼‹" : "âˆ’";
    toggleBtn.onclick=()=>{ state.collapsed[stage] = !state.collapsed[stage]; scheduleSave(); render(); };
    const newBtn=document.createElement("button"); newBtn.className="btn icon"; newBtn.title="New card in this lane"; newBtn.textContent="ï¼‹";
    newBtn.onclick=()=> openEditor(null, stage);
    actions.append(toggleBtn,newBtn);

    head.append(titleWrap,actions);

    const body=document.createElement("div"); body.className="lane-body"; if(state.collapsed[stage]) body.classList.add("collapsed");

    body.addEventListener("dragenter", e=> e.preventDefault());
    body.addEventListener("dragover", e=>{
      e.preventDefault();
      const {index,targetEl}=getDropTarget(body,e.clientY);
      body.dataset.dropIndex=index;
      setHighlight(targetEl); // highlight landing card (insert ABOVE)
      if(e.dataTransfer) e.dataTransfer.dropEffect="move";
    });
    body.addEventListener("dragleave", e=>{ if(!body.contains(e.relatedTarget)) setHighlight(null); });
    body.addEventListener("drop", e=>{
      e.preventDefault();
      const id=draggingId||e.dataTransfer.getData("text/id")||e.dataTransfer.getData("text/plain");
      if(!id){ setHighlight(null); return; }
      const idx=Number(body.dataset.dropIndex??0);
      moveToStageAt(id,stage,idx);
      setHighlight(null);
    });

    stageCards(stage).forEach(c=> body.appendChild(renderCard(c)));
    lane.append(head, body); board.appendChild(lane);
  });

  refillSelects();
  applySearch($("#search").value);
  
  // Update status immediately after render
  setStatus("Loaded â€¢ Config: Default â€¢ "+fmtFullDate(new Date()));
}
document.addEventListener("dragover", e=> e.preventDefault());

function setHighlight(el){ if(highlightEl && highlightEl!==el) highlightEl.classList.remove("drop-highlight"); highlightEl=el; if(highlightEl) highlightEl.classList.add("drop-highlight"); }
function getDropTarget(body,y){
  const cards=[...body.querySelectorAll(".card")].filter(x=> x.dataset.id!==draggingId);
  if(!cards.length) return {index:0,targetEl:null};
  let index=cards.length;
  for(let i=0;i<cards.length;i++){
    const r=cards[i].getBoundingClientRect();
    const mid=r.top+r.height/2;
    if(y<mid){ index=i; break; }
  }
  const targetEl = (index<cards.length) ? cards[index] : cards[cards.length-1];
  return {index,targetEl};
}
function renderCard(card){
  const el=document.createElement("article"); el.className="card"; el.draggable=true; el.dataset.id=card.id;
  el.addEventListener("dragstart", e=>{
    draggingId=card.id;
    el.classList.add("dragging");
    e.dataTransfer.setData("text/id",card.id);
    e.dataTransfer.setData("text/plain",card.id);
    e.dataTransfer.effectAllowed="move";
  });
  el.addEventListener("dragend", ()=>{ draggingId=null; el.classList.remove("dragging"); setHighlight(null); });
  el.addEventListener("click", ()=> openEditor(card.id));
  el.addEventListener("mouseenter", (e)=> showTooltip(e, card));
  el.addEventListener("mousemove", (e)=> positionTooltip(e));
  el.addEventListener("mouseleave", hideTooltip);

  const line=document.createElement("div"); line.className="card-line";
  const p=document.createElement("span"); p.className="card-platform"; p.textContent=card.platform;
  
  // Apply title length limit
  const cardTitle = card.title || "(untitled)";
  const displayedTitle = cardTitle.length > state.titleLimit ? cardTitle.substring(0, state.titleLimit) + "..." : cardTitle;
  const title=document.createElement("span"); title.className="card-title"; title.textContent=displayedTitle;
  
  const links=document.createElement("span"); links.className="card-links";
  if(card.dev){ const a=document.createElement("a"); a.href=card.dev; a.target="_blank"; a.rel="noopener"; a.textContent="dev"; a.onclick=(e)=> e.stopPropagation(); links.appendChild(a); }
  if(card.live){ const a=document.createElement("a"); a.href=card.live; a.target="_blank"; a.rel="noopener"; a.textContent="live"; a.onclick=(e)=> e.stopPropagation(); links.appendChild(a); }
  line.append(p,title,links); el.append(line);

  const tagsRow=document.createElement("div"); tagsRow.className="card-tags";
  if(card.tags?.length){ 
    card.tags.forEach(t=>{ 
      // Apply chip length limit
      const displayedTag = t.length > state.chipLimit ? t.substring(0, state.chipLimit) + "..." : t;
      const chip=document.createElement("span"); chip.className="chip"; chip.textContent=displayedTag; 
      chip.title = t; // Show full tag on hover
      tagsRow.appendChild(chip); 
    }); 
  }
  el.append(tagsRow);
  return el;
}

/* ===== Card Ops ===== */
function createCard(data){
  const now=Date.now(); const stage=data.stage||state.stages[0]||"Next";
  const c={ id:uid(), title:(data.title||"").trim(), platform:data.platform||state.platforms[0]||"General", stage, dev:(data.dev||"").trim(), live:(data.live||"").trim(), tags:normalizeTags(data.tags), notes:(data.notes||"").trim(), pos:topPos(stage), createdAt:now, updatedAt:now, files:(data.files||[]) };
  state.cards.push(c); bumpTagHistory(c.tags); scheduleSave(); render(); focusCard(c.id); return c.id;
}
function updateCard(id, patch){
  const c=state.cards.find(x=>x.id===id); if(!c) return;
  Object.assign(c, patch); c.tags=normalizeTags(c.tags); c.updatedAt=Date.now(); bumpTagHistory(c.tags); scheduleSave(); render(); focusCard(c.id);
}
function archiveCard(id){
  const idx = state.cards.findIndex(x=>x.id===id); if(idx===-1) return;
  const c = state.cards[idx];
  state.cards.splice(idx,1);
  state.archive.push({...c, archivedAt: Date.now()});
  scheduleSave(); render();
}
function restoreCard(id){
  const idx = state.archive.findIndex(x=>x.id===id); if(idx===-1) return;
  const c = state.archive[idx];
  state.archive.splice(idx,1);
  c.pos = topPos(c.stage);
  c.updatedAt = Date.now();
  delete c.archivedAt;
  state.cards.push(c);
  scheduleSave(); render(); focusCard(c.id);
}
function deleteCardPermanently(id){ state.archive = state.archive.filter(x=>x.id!==id); scheduleSave(); renderArchiveList(); }
function emptyArchive(){ if(confirm("Permanently delete all archived cards? This cannot be undone.")){ state.archive = []; scheduleSave(); renderArchiveList(); } }
function deleteCard(id){ archiveCard(id); }
function focusCard(id){ const el=$( `.card[data-id="${id}"]` ); if(el){ el.scrollIntoView({behavior:"smooth",block:"center",inline:"center"}); el.animate([{transform:"scale(1)"},{transform:"scale(1.02)"},{transform:"scale(1)"}],{duration:450}); } }
function normalizeTags(tags){ let arr=[]; if(Array.isArray(tags)) arr=tags; else if(typeof tags==="string") arr=tags.split(",").map(s=>s.trim()); arr=arr.map(s=>s.toLowerCase()).filter(Boolean); return [...new Set(arr)]; }
function bumpTagHistory(tags){ if(!tags?.length) return; tagHistory=saveTagHistory([...tagHistory, ...tags]); }

/* ===== Editor ===== */
const editDialog=$("#editDialog"); const editForm=$("#editForm");
const editorCloseBtn=$("#editorCloseBtn");
let editingId=null, activeTags=[], pendingFiles=[], currentFiles=[];
function openEditor(id=null, presetStage=null){
  editingId=id; editorDirty=false;
  $("#editTitle").textContent=id? "Edit Card":"New Card";
  const c=id? state.cards.find(x=>x.id===id):null;
  refillSelects();
  $("#fPlatform").value = c?.platform || (state.platforms[0]||"General");
  $("#fStage").value = c?.stage || (presetStage || state.stages[0] || "Next");
  $("#fTitle").value = c?.title || "";
  $("#fDev").value = c?.dev || "";
  $("#fLive").value = c?.live || "";
  $("#fNotes").value = c?.notes || "";
  $("#btnDelete").classList.toggle("hidden", !id);
  activeTags = c?.tags ? [...c.tags] : [];
  currentFiles = Array.isArray(c?.files) ? c.files.slice() : [];
  pendingFiles = [];
  renderTagChips(); renderTagSuggestions();
  renderFileChips();
  $("#fFiles").value = ""; // reset file input
  editDialog.showModal(); 
  $("#fTitle").focus();
}

// Function to instantly apply current editor changes and save state
function saveEditorState(id){
    if(!id) return;
    const payload = collectEditorData();
    const c=state.cards.find(x=>x.id===id); if(!c) return;
    Object.assign(c, payload);
    c.tags=normalizeTags(c.tags);
    c.updatedAt=Date.now();
    bumpTagHistory(c.tags);
    scheduleSave(); // Triggers persistence
}

editDialog.addEventListener("close", ()=>{
  hideEmojiPicker();
  const action=editDialog.returnValue; if(action==="cancel"){ editingId=null; return; }
  const payload=collectEditorData();
  if(action==="delete" && editingId){ deleteCard(editingId); editingId=null; return; }
  if(action==="save" || action==="save_new"){
    if(!payload.title){ alert("Title is required."); openEditor(editingId); return; }
    if(editingId) updateCard(editingId, payload); else createCard(payload);
    const savedStage = payload.stage;
    if(action==="save_new"){ openEditor(null, savedStage); } else { editingId=null; }
  }
  editorDirty=false;
});

// Add a general blur listener to the edit dialog to ensure changes are saved on field exit
editDialog.addEventListener("focusout", (e) => {
    if ((e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA" || e.target.tagName === "SELECT") && editingId) {
        saveEditorState(editingId);
    }
});


editForm.addEventListener("input", ()=>{ editorDirty=true; });
editForm.addEventListener("change", ()=>{ editorDirty=true; });
editorCloseBtn.addEventListener("click", ()=>{
  if(editorDirty){ if(confirm("Discard changes?")) { editDialog.close("cancel"); editorDirty=false; } }
  else { editDialog.close("cancel"); }
});
$("#fTitle").addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); $("#btnSave").click(); } });
$("#btnSaveAndNew").addEventListener("click", (e)=>{ e.preventDefault(); editDialog.close("save_new"); });
function collectEditorData(){ return { platform:$("#fPlatform").value, stage:$("#fStage").value, title:$("#fTitle").value.trim(), dev:$("#fDev").value.trim(), live:$("#fLive").value.trim(), tags:activeTags.join(","), notes:$("#fNotes").value, files: currentFiles.slice() }; }
function refillSelects(){ $("#fPlatform").innerHTML = state.platforms.map(p=>`<option>${p}</option>`).join(""); $("#fStage").innerHTML = state.stages.map(s=>`<option>${s}</option>`).join(""); }

/* ===== Tagging UI ===== */
const tagInput=$("#tagInput"), tagChips=$("#tagChips"), tagSuggestions=$("#tagSuggestions"), hiddenTags=$("#fTags");
function commitTagFromInput(){
  const raw = tagInput.value.trim();
  if(!raw) return;
  raw.split(/[\,\s]+/).forEach(piece=>{
    const t = piece.trim().toLowerCase();
    if(t && !activeTags.includes(t)) activeTags.push(t);
  });
  tagInput.value="";
  renderTagChips();
  bumpTagHistory(activeTags);
  renderTagSuggestions();
  if(editingId) saveEditorState(editingId); // Save state after committing tags
}
tagInput.addEventListener("keydown", (e)=>{ if(e.key==="Enter" || e.key===","){ e.preventDefault(); commitTagFromInput(); } });
tagInput.addEventListener("blur", ()=>{ commitTagFromInput(); });
function renderTagChips(){
  tagChips.innerHTML="";
  activeTags.forEach(t=>{
    const el=document.createElement("span"); el.className="chip"; el.innerHTML=`${escapeHtml(t)} <button title="remove" aria-label="remove tag">Ã—</button>`;
    el.querySelector("button").onclick=()=>{ activeTags=activeTags.filter(x=>x!==t); renderTagChips(); if(editingId) saveEditorState(editingId); };
    tagChips.appendChild(el);
  });
  hiddenTags.value = activeTags.join(",");
}
function renderTagSuggestions(){
  tagSuggestions.innerHTML=""; 
  if(!tagHistory.length) return;
  const seen=new Set();
  tagHistory.forEach(t=>{
    const k=t.toLowerCase(); if(seen.has(k)) return; seen.add(k);
    const el=document.createElement("span"); el.className="suggestion";
    const txt=document.createElement("span"); txt.textContent=t;
    const rm=document.createElement("span"); rm.textContent="Ã—"; rm.className="remove"; rm.title="remove from history";
    el.append(txt,rm);
    el.onclick=(e)=>{
      if(e.target===rm){ tagHistory=saveTagHistory(tagHistory.filter(x=>x!==t)); renderTagSuggestions(); renderTagChips(); return; }
      if(!activeTags.includes(t)){ activeTags.push(t); renderTagChips(); if(editingId) saveEditorState(editingId); }
    };
    tagSuggestions.appendChild(el);
  });
}

/* ===== Attachments ===== */
const fFiles=$("#fFiles"), fileChips=$("#fileChips"), btnClearFiles=$("#btnClearFiles"), notesEl=$("#fNotes");
btnClearFiles.addEventListener("click", ()=>{ pendingFiles=[]; fFiles.value=""; renderFileChips(); if(editingId) saveEditorState(editingId); });
fFiles.addEventListener("change", async (e)=>{ await addFiles(Array.from(e.target.files||[])); if(editingId) saveEditorState(editingId); });
async function addFiles(files){
  for(const file of files){ const dataUrl = await readAsDataURL(file); pendingFiles.push({name:file.name,type:file.type,size:file.size,data:dataUrl}); }
  currentFiles = mergeFiles(currentFiles, pendingFiles); pendingFiles = []; renderFileChips(); }
function mergeFiles(existing, added){ const byName=new Map(existing.map(x=>[x.name,x])); for(const f of added){ byName.set(f.name, f); } return Array.from(byName.values()); }
function renderFileChips(){ fileChips.innerHTML=""; if(!currentFiles.length){ fileChips.innerHTML="<span class='muted'>No attachments</span>"; return; } currentFiles.forEach((f,idx)=>{ const el=document.createElement("span"); el.className="chip"; const a=document.createElement("a"); a.href=f.data; a.download=f.name; a.textContent=f.name; a.onclick=(e)=>e.stopPropagation(); const rm=document.createElement("button"); rm.textContent="Ã—"; rm.title="remove attachment"; rm.onclick=(e)=>{ e.stopPropagation(); currentFiles.splice(idx,1); renderFileChips(); if(editingId) saveEditorState(editingId); }; el.append(a, rm); fileChips.appendChild(el); }); }
function readAsDataURL(file){ return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(file); }); }

/* ===== Paste images/URLs into Notes ===== */
notesEl.addEventListener("paste", async (e)=>{
  if(!e.clipboardData) return; // safety
  const items = Array.from(e.clipboardData.items||[]);
  // Images
  const imageItems = items.filter(it=> it.kind==="file" && it.type.startsWith("image/"));
  for(const it of imageItems){
    const file = it.getAsFile(); if(!file) continue;
    const dataUrl = await readAsDataURL(file);
    // Add as attachment AND embed markdown in notes
    currentFiles = mergeFiles(currentFiles, [{name:file.name||("pasted-"+Date.now()+".png"), type:file.type, size:file.size, data:dataUrl}]);
    const cursor = notesEl.selectionStart||notesEl.value.length;
    const md = `\n![pasted](${dataUrl})\n`;
    notesEl.value = notesEl.value.slice(0,cursor)+md+notesEl.value.slice(cursor);
  }
  // URLs
  const text = e.clipboardData.getData("text/plain");
  if(text && /^https?:\/\//i.test(text)){
    // keep as plain text in notes; linkified in tooltip render
  }
});

/* ===== Settings ===== */
const settingsDialog=$("#settingsDialog");
$("#btnSettings").onclick=()=>{
  $("#sPlatforms").value=state.platforms.join(", ");
  $("#sStages").value=state.stages.join(", ");
  $("#sLayout").value=state.layout;
  $("#sEmojis").value = customEmojis.join(" ");
  $("#sTitleLen").value = state.titleLimit;
  $("#sChipLen").value = state.chipLimit;
  settingsDialog.showModal();
};

// Function to instantly apply current settings changes and save state
function saveSettingsState(){
    const platforms=$("#sPlatforms").value.split(",").map(s=>s.trim()).filter(Boolean);
    const stages=$("#sStages").value.split(",").map(s=>s.trim()).filter(Boolean);
    const emojis=$("#sEmojis").value.split(/[\s,]+/).map(s=>s.trim()).filter(Boolean);
    const newTitleLimit = parseInt($("#sTitleLen").value, 10);
    const newChipLimit = parseInt($("#sChipLen").value, 10);

    // Apply immediate changes to state
    if(platforms.length) state.platforms=platforms;
    if(stages.length){ const newFirst=stages[0]; state.cards.forEach(c=>{ if(!stages.includes(c.stage)){ c.stage=newFirst; c.pos=topPos(newFirst); c.updatedAt=Date.now(); } }); state.stages=stages; }
    state.titleLimit = (newTitleLimit && newTitleLimit > 0) ? newTitleLimit : 20;
    state.chipLimit = (newChipLimit && newChipLimit > 0) ? newChipLimit : 10;
    
    saveEmojis(emojis);
    scheduleSave();
}

// Add a general blur listener to the settings dialog to ensure changes are saved on field exit
settingsDialog.addEventListener("focusout", (e) => {
    if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") {
        saveSettingsState();
    }
});

settingsDialog.addEventListener("close", ()=>{
  const v=settingsDialog.returnValue; if(v==="cancel") return;
  if(v==="reset"){ 
    if(confirm("Permanently reset all settings and remove all cards and archive?")){ 
        // Overwrite entire state with a fresh, empty baseline
        state = loadState(); // This re-initializes and saves the clean baseline
        saveEmojis(UPLOADED_CONFIG.emojis);
        persistNow();
        render(); 
    } 
    return; 
  }
  if(v==="save"){
    saveSettingsState(); 
    state.layout=$("#sLayout").value;
    scheduleSave(); 
    render();
  }
});

/* ===== Import/Export/New & Emojis Import/Export ===== */
function timestampedFileName(base){ const d=new Date(); return base+d.getFullYear()+("0"+(d.getMonth()+1)).slice(-2)+("0"+d.getDate()).slice(-2)+"_"+("0"+d.getHours()).slice(-2)+("0"+d.getMinutes()).slice(-2)+("0"+d.getSeconds()).slice(-2)+".json"; }

// Manual Save Button
$("#btnManualSave").onclick = () => {
    persistNow();
    toast("Manual Save", "Board state committed to memory.");
};

$("#btnNew").onclick=()=> openEditor(null, state.stages[0] || "Next");

$("#btnExport").onclick=()=>{ 
  const data=JSON.stringify(state,null,2); 
  const blob=new Blob([data],{type:"application/json"}); 
  const url=URL.createObjectURL(blob); 
  const a=document.createElement("a"); 
  a.href=url; 
  a.download=timestampedFileName("ai-jobs-kanban_");
  a.click(); 
  URL.revokeObjectURL(url); 
  setStatus("Exported current board JSON â€¢ Config: Default â€¢ "+fmtFullDate(new Date())); 
};

function toast(title, desc="", isErr=false){ const t=document.getElementById("toast"); t.className=isErr? "err":""; t.querySelector(".tmsg").textContent=title; t.querySelector(".tdesc").textContent=desc; t.style.display="block"; clearTimeout(t._timer); t._timer=setTimeout(()=>{ t.style.display="none"; }, 2800); }

$("#btnImport").onclick=()=> $("#fileImport").click();

$("#fileImport").onchange=(e)=>{ 
  const f=e.target.files?.[0]; if(!f) return; 
  const r=new FileReader(); 
  r.onload=()=>{ try{ 
    const obj=JSON.parse(r.result); 
    // Allowing import of pre-upgrade exports without full metadata
    if(Array.isArray(obj.cards)||Array.isArray(obj.platforms)||Array.isArray(obj.stages)){ 
      state=obj; 
      // Ensure all required fields exist or apply defaults
      state.collapsed = state.collapsed || {}; 
      state.layout = state.layout || "auto"; 
      state.archive = Array.isArray(state.archive)? state.archive : []; 
      state.titleLimit = state.titleLimit || UPLOADED_CONFIG.titleLimit;
      state.chipLimit = state.chipLimit || UPLOADED_CONFIG.chipLimit;
      state.platforms = state.platforms || UPLOADED_CONFIG.platforms;
      state.stages = state.stages || UPLOADED_CONFIG.stages;

      state.stages.forEach(st=>{ const list=state.cards.filter(c=>c.stage===st); list.sort((a,b)=>(a.pos??0)-(b.pos??0)||(a.createdAt-b.createdAt)); list.forEach((c,i)=>{ if(typeof c.pos!=="number") c.pos=(i+1)*1000; }); }); 
      
      persistNow(); // Use persistNow for immediate save on import
      render(); 
      toast("Import successful","Board replaced and committed to memory."); 
      setStatus("Imported JSON â€¢ Config: Default â€¢ "+fmtFullDate(new Date())); 
    } else { 
      toast("Import failed","Invalid JSON", true); alert("Invalid JSON structure."); 
    } 
  }catch(err){ toast("Import failed","Could not parse file", true); alert("Failed to parse JSON."); } }; 
  r.readAsText(f); 
};

// Emoji Export/Import Handlers
$("#btnExportEmojis").onclick=()=>{
  const data=JSON.stringify(customEmojis,null,2);
  const blob=new Blob([data],{type:"application/json"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url;
  a.download=timestampedFileName("ai-jobs-emojis_");
  a.click();
  URL.revokeObjectURL(url);
  toast("Exported Emojis","Custom emoji list saved to file.");
};
$("#btnImportEmojis").onclick=()=> $("#fileImportEmojis").click();
$("#fileImportEmojis").onchange=(e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  const r=new FileReader();
  r.onload=()=>{ try{
    const obj=JSON.parse(r.result);
    if(Array.isArray(obj)){
      const newEmojis = obj.map(s=>String(s).trim()).filter(Boolean);
      saveEmojis(newEmojis);
      $("#sEmojis").value = newEmojis.join(" ");
      persistNow(); // Save the new emoji list immediately
      toast("Import successful","Custom emojis updated.");
    } else {
      toast("Import failed","Invalid JSON structure (expected array)", true);
    }
  }catch(err){ toast("Import failed","Could not parse file", true); } };
  r.readAsText(f);
};


/* ===== Lane dblclick: new at top ===== */
$("#board").addEventListener("dblclick", (e)=>{ const lane=e.target.closest(".lane"); if(!lane) return; const stage=lane.dataset.stage; openEditor(null, stage); });

/* ===== Archive UI ===== */
const archiveDialog=$("#archiveDialog");
$("#btnArchive").onclick=()=>{ renderArchiveList(); archiveDialog.showModal(); };
archiveDialog.addEventListener("close", (e)=>{ if(archiveDialog.returnValue==="empty"){ emptyArchive(); } });
function renderArchiveList(){
  const list=$("#archiveList"); list.innerHTML="";
  if(!state.archive.length){ list.innerHTML = "<div class='muted'>Archive is empty.</div>"; return; }
  state.archive.slice().sort((a,b)=> (b.archivedAt||0)-(a.archivedAt||0)).forEach(c=>{
    const row=document.createElement("div"); row.className="result-item";
    row.innerHTML = `
      <strong>${escapeHtml(c.title||"(untitled)")}</strong>
      <div class="muted">${escapeHtml(c.platform)} Â· ${escapeHtml(c.stage)}
        ${c.tags?.length? " Â· #"+c.tags.join(" #"):""}
        <span class="timepill">Archived ${escapeHtml(fmtDate(c.archivedAt))}</span>
      </div>
      <div class="row" style="margin-top:6px;">
        <button class="btn small" data-act="restore" data-id="${c.id}">Restore</button>
        <button class="btn small danger" data-act="delete" data-id="${c.id}">Delete Permanently</button>
      </div>
    `;
    row.querySelector('[data-act="restore"]').onclick=()=> restoreCard(c.id);
    row.querySelector('[data-act="delete"]').onclick=()=> deleteCardPermanently(c.id);
    list.appendChild(row);
  });
}
$("#btnEmptyArchive").onclick=(e)=>{ e.preventDefault(); archiveDialog.close("empty"); };

/* ===== Search ===== */
const searchInput=$("#search"); let searchDebounce, currentMatches=[];
$("#btnClearSearch").addEventListener("click", ()=>{ searchInput.value=""; applySearch(""); });
searchInput.addEventListener("input", ()=>{ clearTimeout(searchDebounce); searchDebounce=setTimeout(()=> applySearch(searchInput.value), 120); });
searchInput.addEventListener("keydown", (e)=>{ if(e.key==="Escape"){ searchInput.value=""; applySearch(""); return; } if(e.key==="Enter"){ e.preventDefault(); openSearchModal(currentMatches); } });
function applySearch(q){
  const {includes, excludes}=parseSearch(q||""); const all=state.cards.slice();
  currentMatches = filterCards(all, includes, excludes);
  highlightMatches(new Set(currentMatches.map(c=>c.id)), includes.length||excludes.length);
  renderResultsPreview(currentMatches.slice(0,120));
  $("#searchCount").textContent=(includes.length||excludes.length)? `${currentMatches.length} match(es)`:"";
}
function parseSearch(q){ const parts=q.trim().toLowerCase().split(/\s+/).filter(Boolean); const includes=[], excludes=[]; for(const p of parts){ if(p.startsWith("-")&&p.length>1) excludes.push(p.slice(1)); else includes.push(p); } return {includes,excludes}; }
function haystack(c){ const files = (c.files||[]).map(f=>f.name).join(" "); return [c.title,c.platform,c.stage,c.notes,c.dev,c.live,files,...(c.tags||[])].join(" ").toLowerCase(); }
function filterCards(cards, inc, exc){ return cards.filter(c=>{ const hay=haystack(c); for(const e of exc){ if(hay.includes(e)) return false; } for(const i of inc){ if(!hay.includes(i)) return false; } return true; }); }
function highlightMatches(idset, active){ $$(".card").forEach(el=>{ el.classList.toggle("search-hit", active && idset.has(el.dataset.id)); el.style.opacity = active && !idset.has(el.dataset.id) ? 0.35 : 1; }); }
function renderResultsPreview(cards){ const cont=$("#resultsContainer"); cont.innerHTML=""; const active=$("#search").value.trim().length>0; if(!active||!cards.length) return; const box=document.createElement("div"); box.className="results"; cards.forEach(c=>{ const item=document.createElement("div"); item.className="result-item"; item.innerHTML=`<strong>${escapeHtml(c.title)}</strong><div class="muted">${escapeHtml(c.platform)} Â· ${escapeHtml(c.stage)}${c.tags?.length? " Â· #"+c.tags.join(" #"):""}</div>`; item.onclick=()=>{ openEditor(c.id); }; box.appendChild(item); }); cont.appendChild(box); }
const searchDialog=$("#searchDialog");
function openSearchModal(cards){ const list=$("#searchList"); list.innerHTML=""; if(!cards.length){ list.innerHTML="<div class='muted'>No results (active cards only)</div>"; } else { cards.forEach(c=>{ const row=document.createElement("div"); row.className="result-item"; row.innerHTML=`<strong>${escapeHtml(c.title)}</strong><div class="muted">${escapeHtml(c.platform)} Â· ${escapeHtml(c.stage)}${c.tags?.length? " Â· #"+c.tags.join(" #"):""}</div>`; row.onclick=()=>{ searchDialog.close("close"); openEditor(c.id); }; list.appendChild(row); }); } searchDialog.showModal(); }

/* ===== Tooltip ===== */
const tooltip = document.getElementById("tooltip");
function showTooltip(e, card){
  tooltip.querySelector(".t-title").textContent = card.title || "(untitled)";
  tooltip.querySelector(".t-meta").textContent = `${card.platform} Â· ${card.stage}`;
  tooltip.querySelector(".t-tags").textContent = card.tags?.length ? "tags: " + card.tags.join(", ") : "no tags";
  tooltip.querySelector(".t-notes").innerHTML = linkifyNotes(sanitizeMarkdownImages(card.notes||""));
  // Append inline previews for image attachments if not already embedded
  if(card.files && card.files.length){
    const imgs = card.files.filter(f=>/^image\//.test(f.type));
    if(imgs.length){
      const frag = document.createElement('div');
      imgs.forEach(f=>{ const im=new Image(); im.src=f.data; im.alt=f.name; im.style.maxWidth='100%'; im.style.height='auto'; im.style.marginTop='6px'; im.style.borderRadius='8px'; frag.appendChild(im); });
      tooltip.querySelector('.t-notes').appendChild(frag);
    }
  }
  tooltip.style.display = "block"; positionTooltip(e);
}
function positionTooltip(e){ const pad=12; let x=e.clientX+pad, y=e.clientY+pad; const rect=tooltip.getBoundingClientRect(); if(x+rect.width>window.innerWidth-6) x=e.clientX-rect.width-pad; if(y+rect.height>window.innerHeight-6) y=e.clientY-rect.height-pad; tooltip.style.left=x+"px"; tooltip.style.top=y+"px"; tooltip.setAttribute("aria-hidden","false"); }
function hideTooltip(){ tooltip.style.display="none"; tooltip.setAttribute("aria-hidden","true"); }

/* ===== Emoji Picker - Persistent Panel ===== */
const emojiPicker = $("#emojiPicker");
const emojiPickerCloseBtn = $("#emojiPickerClose");
let activeInput = null;

emojiPickerCloseBtn.onclick = hideEmojiPicker;

function handleAtTyping(e){
  const input = e.target;
  activeInput = input;
  const cursor = input.selectionStart || 0;
  const text = input.value;
  
  if ((e.key === "@" && input.selectionEnd === cursor) || (text.length > 0 && text[cursor - 1] === '@')) {
    if(customEmojis.length === 0) return hideEmojiPicker();
    showEmojiPicker(input, cursor);
  } else if (emojiPicker.style.display === "block") {
    positionEmojiPicker(input, cursor);
  } else {
    if(e.key === "Escape" || e.key === "Enter" || e.key === " "){
        hideEmojiPicker();
    }
  }
}

function showEmojiPicker(input, cursor){
  positionEmojiPicker(input, cursor);
  emojiPicker.innerHTML = "";
  
  emojiPicker.appendChild(emojiPickerCloseBtn);

  customEmojis.forEach(emoji => {
    const item = document.createElement("span");
    item.className = "emoji-item";
    item.textContent = emoji;
    item.title = emoji;
    item.onclick = (e) => { 
      e.stopPropagation(); 
      insertEmoji(emoji); 
      if(editingId) saveEditorState(editingId);
    }; 
    emojiPicker.appendChild(item);
  });

  emojiPicker.style.display = "block";
}

function positionEmojiPicker(input, cursor){
  const rect = input.getBoundingClientRect();
  const pickerHeight = 160;
  let x = rect.left;
  let y = rect.bottom + 4;

  if(input.tagName === "INPUT"){
    x += (cursor * 8);
  }

  if (y + pickerHeight > window.innerHeight - 6) {
    y = rect.top - pickerHeight - 4;
  }
  if (x + 200 > window.innerWidth - 6) {
    x = window.innerWidth - 206;
  }
  
  emojiPicker.style.left = x + "px";
  emojiPicker.style.top = y + "px";
}

function hideEmojiPicker(){
  emojiPicker.style.display = "none";
  activeInput = null;
}

function insertEmoji(emoji){
  if(!activeInput) return;
  const input = activeInput;
  const cursor = input.selectionStart || 0;
  const text = input.value;
  let insertPos = cursor;
  let textToInsert = emoji + " ";

  if (cursor > 0 && text[cursor - 1] === '@') {
    insertPos = cursor - 1;
    textToInsert = emoji + " ";
  } else {
    insertPos = cursor;
    textToInsert = emoji + " ";
  }
  
  const start = text.slice(0, insertPos);
  const end = text.slice(cursor);

  if (text[insertPos] === '@') {
      input.value = text.slice(0, insertPos) + textToInsert + text.slice(insertPos + 1);
  } else {
      input.value = start + textToInsert + end;
  }
  
  const newCursorPos = insertPos + textToInsert.length;
  input.setSelectionRange(newCursorPos, newCursorPos);
  
  input.focus();
  editorDirty = true;
}

// Attach event listeners to all relevant text fields
const allTextFields = [$("#fTitle"), $("#fDev"), $("#fLive"), $("#fNotes"), $("#tagInput")];
allTextFields.forEach(input => {
  if (input) {
    input.addEventListener("input", handleAtTyping);
    input.addEventListener("keyup", handleAtTyping);
  }
});

document.addEventListener("click", (e) => {
    if(emojiPicker.style.display === "block"){
        const isPicker = emojiPicker.contains(e.target);
        const isInput = activeInput && e.target === activeInput;
        if(!isPicker && !isInput) {
            hideEmojiPicker();
        }
    }
});
document.addEventListener("focusin", (e) => {
    if (activeInput && e.target !== activeInput && emojiPicker.style.display === "block" && !emojiPicker.contains(e.target)) {
        hideEmojiPicker();
    }
});


/* ===== Helpers ===== */
function fmtDate(ts){ if(!ts) return ""; const d=new Date(ts); const pad=n=>String(n).padStart(2,"0"); return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`; }
function fmtFullDate(d){ const pad=n=>String(n).padStart(2,"0"); return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`; }
function escapeHtml(s){ return String(s||"").replace(/[&<>"']/g, m=> ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m])); }
function setStatus(t){ document.getElementById("status").textContent=t; }
function linkifyNotes(s){
  // Convert URLs to clickable links; keep simple, safe replacement
  return escapeHtml(s).replace(/(https?:\/\/[^\s)]+)(?![^<]*>)/g, '<a href="$1" target="_blank" rel="noopener">$1<\/a>');
}
function sanitizeMarkdownImages(s){
  // allow markdown ![alt](data:...) to render as <img> for pasted images only
  return s.replace(/!\[[^\]]*\]\((data:image\/[a-zA-Z0-9+.-]+;base64,[^\)]+)\)/g, (m,src)=>`<img src="${src}" alt="pasted"/>`);
}

/* ===== Init ===== */
window.addEventListener("beforeunload", ()=>{ if(dirty) persistNow(); });
render();
// The initial status is set in render() now
</script>
</body>
</html>

<.> 2025-11-01 - 10:20 PM <.>