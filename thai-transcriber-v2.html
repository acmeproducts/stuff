<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thai Transcriber & Translator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');
        
        :root {
            --bg-deep: #0a0a0f;
            --bg-surface: #12121a;
            --bg-elevated: #1a1a25;
            --bg-hover: #22222f;
            --border-subtle: #2a2a3a;
            --border-accent: #4a4a6a;
            --text-primary: #e8e8f0;
            --text-secondary: #9090a8;
            --text-muted: #606078;
            --accent-gold: #d4a853;
            --accent-gold-dim: #a88a43;
            --accent-thai: #2d7d9a;
            --accent-thai-light: #3a9fc4;
            --accent-english: #7d5ba6;
            --accent-english-light: #9a7bc4;
            --success: #4a9d6a;
            --warning: #c4883a;
            --error: #c45a5a;
            --gradient-gold: linear-gradient(135deg, #d4a853 0%, #a88a43 100%);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Sarabun', sans-serif;
            background: var(--bg-deep);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }
        
        /* Setup Wizard Overlay */
        .setup-overlay {
            position: fixed;
            inset: 0;
            background: rgba(10, 10, 15, 0.95);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }
        
        .setup-overlay.hidden { display: none; }
        
        .setup-card {
            background: var(--bg-surface);
            border: 1px solid var(--border-accent);
            border-radius: 16px;
            max-width: 600px;
            width: 100%;
            overflow: hidden;
        }
        
        .setup-header {
            padding: 2rem;
            text-align: center;
            border-bottom: 1px solid var(--border-subtle);
        }
        
        .setup-title {
            font-size: 1.75rem;
            font-weight: 300;
            background: var(--gradient-gold);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }
        
        .setup-subtitle {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }
        
        .setup-body { padding: 2rem; }
        
        .setup-step { display: none; }
        .setup-step.active { display: block; }
        
        .setup-step-title {
            font-size: 1.1rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            color: var(--accent-gold);
        }
        
        .setup-option {
            padding: 1rem;
            background: var(--bg-elevated);
            border: 2px solid var(--border-subtle);
            border-radius: 8px;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .setup-option:hover {
            border-color: var(--border-accent);
            background: var(--bg-hover);
        }
        
        .setup-option.selected {
            border-color: var(--accent-gold);
            background: rgba(212, 168, 83, 0.1);
        }
        
        .setup-option-title {
            font-weight: 500;
            margin-bottom: 0.25rem;
        }
        
        .setup-option-desc {
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        .setup-progress {
            margin: 2rem 0;
        }
        
        .setup-progress-bar {
            height: 8px;
            background: var(--bg-elevated);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .setup-progress-fill {
            height: 100%;
            background: var(--gradient-gold);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .setup-progress-text {
            margin-top: 0.75rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
            text-align: center;
        }
        
        .setup-footer {
            padding: 1.5rem 2rem;
            border-top: 1px solid var(--border-subtle);
            display: flex;
            justify-content: space-between;
            gap: 1rem;
        }
        
        .setup-nav-dots {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .setup-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--border-accent);
        }
        
        .setup-dot.active { background: var(--accent-gold); }
        .setup-dot.complete { background: var(--success); }
        
        /* Main App */
        .app-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .app-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-subtle);
        }
        
        .app-brand {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .app-title {
            font-size: 1.5rem;
            font-weight: 300;
            letter-spacing: 0.1em;
            background: var(--gradient-gold);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .model-status-badge {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            font-size: 0.8rem;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
        }
        
        .status-dot.ready { background: var(--success); }
        .status-dot.loading { background: var(--warning); animation: pulse 1s infinite; }
        .status-dot.error { background: var(--error); }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
        
        .header-actions {
            display: flex;
            gap: 0.75rem;
        }
        
        /* Buttons */
        .btn {
            padding: 0.6rem 1.25rem;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-primary {
            background: var(--gradient-gold);
            color: var(--bg-deep);
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(212, 168, 83, 0.3);
        }
        
        .btn-secondary {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border: 1px solid var(--border-accent);
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: var(--bg-hover);
        }
        
        .btn-ghost {
            background: transparent;
            color: var(--text-secondary);
        }
        
        .btn-ghost:hover { color: var(--text-primary); }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-lg {
            padding: 1rem 2rem;
            font-size: 1rem;
        }
        
        /* Main Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 2rem;
            min-height: calc(100vh - 200px);
        }
        
        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Panels */
        .panel {
            background: var(--bg-surface);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            padding: 1rem 1.25rem;
            background: var(--bg-elevated);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }
        
        .panel-title {
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--text-secondary);
        }
        
        .panel-content {
            padding: 1.25rem;
            flex: 1;
            overflow-y: auto;
        }
        
        /* Upload Zone */
        .upload-zone {
            border: 2px dashed var(--border-accent);
            border-radius: 8px;
            padding: 2rem 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(42, 42, 58, 0.2);
        }
        
        .upload-zone:hover,
        .upload-zone.dragover {
            border-color: var(--accent-gold);
            background: rgba(212, 168, 83, 0.05);
        }
        
        .upload-zone.has-file {
            border-color: var(--success);
            border-style: solid;
            background: rgba(74, 157, 106, 0.05);
        }
        
        .upload-icon { font-size: 2.5rem; margin-bottom: 0.75rem; }
        .upload-text { color: var(--text-secondary); margin-bottom: 0.25rem; }
        .upload-hint { font-size: 0.8rem; color: var(--text-muted); }
        
        .file-input { display: none; }
        
        /* File Card */
        .file-card {
            display: none;
            margin-top: 1rem;
            padding: 1rem;
            background: var(--bg-elevated);
            border-radius: 8px;
            border: 1px solid var(--border-subtle);
        }
        
        .file-card.visible { display: block; }
        
        .file-card-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }
        
        .file-name {
            font-weight: 500;
            color: var(--accent-gold);
            word-break: break-all;
            font-size: 0.9rem;
        }
        
        .file-meta {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }
        
        .file-remove {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1.25rem;
            line-height: 1;
            padding: 0.25rem;
        }
        
        .file-remove:hover { color: var(--error); }
        
        /* Audio Player */
        .audio-player {
            margin-top: 0.75rem;
        }
        
        .audio-player audio {
            width: 100%;
            height: 36px;
            border-radius: 6px;
        }
        
        /* Processing Section */
        .processing-section {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-subtle);
        }
        
        .processing-stages {
            margin-bottom: 1.5rem;
        }
        
        .stage {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.6rem 0;
            color: var(--text-muted);
            font-size: 0.9rem;
        }
        
        .stage.active { color: var(--text-primary); }
        .stage.complete { color: var(--success); }
        .stage.error { color: var(--error); }
        
        .stage-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border-subtle);
            flex-shrink: 0;
        }
        
        .stage.active .stage-icon {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            animation: pulse 1s infinite;
        }
        
        .stage.complete .stage-icon {
            background: var(--success);
            border-color: var(--success);
            color: white;
        }
        
        .stage.error .stage-icon {
            background: var(--error);
            border-color: var(--error);
            color: white;
        }
        
        .stage-info {
            flex: 1;
            min-width: 0;
        }
        
        .stage-label { font-weight: 500; }
        
        .stage-detail {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.1rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .stage.active .stage-detail { color: var(--text-secondary); }
        
        /* Progress Bar */
        .progress-container {
            margin: 1rem 0;
        }
        
        .progress-bar {
            height: 6px;
            background: var(--bg-elevated);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--gradient-gold);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .progress-text {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* Action Buttons */
        .action-row {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }
        
        .action-row .btn { flex: 1; justify-content: center; }
        
        /* Transcript Panel */
        .transcript-container {
            flex: 1;
            overflow-y: auto;
            padding-right: 0.5rem;
        }
        
        .transcript-container::-webkit-scrollbar { width: 6px; }
        .transcript-container::-webkit-scrollbar-track { background: var(--bg-elevated); border-radius: 3px; }
        .transcript-container::-webkit-scrollbar-thumb { background: var(--border-accent); border-radius: 3px; }
        
        .transcript-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 300px;
            text-align: center;
            color: var(--text-muted);
        }
        
        .transcript-empty-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }
        
        /* Segments */
        .segment {
            padding: 1rem;
            margin-bottom: 0.75rem;
            border-radius: 8px;
            border-left: 3px solid;
            background: var(--bg-elevated);
        }
        
        .segment.thai { border-color: var(--accent-thai); }
        .segment.english { border-color: var(--accent-english); }
        
        .segment-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
        }
        
        .segment-lang {
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
        }
        
        .segment.thai .segment-lang {
            background: rgba(45, 125, 154, 0.2);
            color: var(--accent-thai-light);
        }
        
        .segment.english .segment-lang {
            background: rgba(125, 91, 166, 0.2);
            color: var(--accent-english-light);
        }
        
        .segment-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        
        .segment-original {
            line-height: 1.8;
            font-size: 1rem;
        }
        
        .segment-translation {
            color: var(--accent-gold);
            font-style: italic;
            padding-left: 1rem;
            border-left: 2px solid var(--accent-gold-dim);
            margin-top: 0.75rem;
            font-size: 0.95rem;
        }
        
        /* Settings Panel */
        .settings-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 0;
            border-bottom: 1px solid var(--border-subtle);
        }
        
        .settings-row:last-child { border-bottom: none; }
        
        .settings-label {
            font-size: 0.9rem;
        }
        
        .settings-label-sub {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        /* Info Callout */
        .info-callout {
            background: rgba(45, 125, 154, 0.1);
            border: 1px solid var(--accent-thai);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            font-size: 0.85rem;
        }
        
        .info-callout-title {
            font-weight: 600;
            color: var(--accent-thai-light);
            margin-bottom: 0.5rem;
        }
        
        .info-callout p {
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }
        
        .info-callout p:last-child { margin-bottom: 0; }
        
        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .toast {
            padding: 1rem 1.5rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border-accent);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            animation: slideIn 0.3s ease;
            max-width: 400px;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .toast.success { border-color: var(--success); }
        .toast.error { border-color: var(--error); }
        .toast.warning { border-color: var(--warning); }
        
        .toast-icon { font-size: 1.25rem; }
        .toast-message { flex: 1; font-size: 0.9rem; }
        
        /* Keep-alive indicator */
        .keepalive-indicator {
            position: fixed;
            top: 1rem;
            right: 1rem;
            padding: 0.5rem 1rem;
            background: rgba(212, 168, 83, 0.9);
            color: var(--bg-deep);
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            display: none;
            z-index: 500;
        }
        
        .keepalive-indicator.visible { display: flex; align-items: center; gap: 0.5rem; }
    </style>
</head>
<body>
    <!-- Keep-alive indicator for background processing -->
    <div class="keepalive-indicator" id="keepaliveIndicator">
        <span>‚ö°</span> Processing in background...
    </div>

    <!-- Setup Wizard -->
    <div class="setup-overlay" id="setupOverlay">
        <div class="setup-card">
            <div class="setup-header">
                <h1 class="setup-title">Thai Transcriber Setup</h1>
                <p class="setup-subtitle">One-time configuration ‚Ä¢ Models cached locally</p>
            </div>
            
            <div class="setup-body">
                <!-- Step 1: Model Selection -->
                <div class="setup-step active" data-step="1">
                    <h3 class="setup-step-title">1. Choose Transcription Model</h3>
                    
                    <div class="setup-option" data-value="tiny">
                        <div class="setup-option-title">üöÄ Tiny (~40MB)</div>
                        <div class="setup-option-desc">Fastest processing, good for clear audio. Best for quick tests.</div>
                    </div>
                    
                    <div class="setup-option selected" data-value="base">
                        <div class="setup-option-title">‚öñÔ∏è Base (~75MB) ‚Äî Recommended</div>
                        <div class="setup-option-desc">Good balance of speed and accuracy. Works well for most recordings.</div>
                    </div>
                    
                    <div class="setup-option" data-value="small">
                        <div class="setup-option-title">üéØ Small (~250MB)</div>
                        <div class="setup-option-desc">Most accurate, but slower. Best for noisy or difficult audio.</div>
                    </div>
                </div>
                
                <!-- Step 2: Translation -->
                <div class="setup-step" data-step="2">
                    <h3 class="setup-step-title">2. Translation Settings</h3>
                    
                    <div class="setup-option selected" data-value="local">
                        <div class="setup-option-title">üîí Local Translation (~50MB)</div>
                        <div class="setup-option-desc">Runs entirely offline. Thai ‚Üí English translation in your browser.</div>
                    </div>
                    
                    <div class="setup-option" data-value="none">
                        <div class="setup-option-title">üìù Transcription Only</div>
                        <div class="setup-option-desc">Skip translation. Just transcribe Thai/English speech as-is.</div>
                    </div>
                </div>
                
                <!-- Step 3: Download Models -->
                <div class="setup-step" data-step="3">
                    <h3 class="setup-step-title">3. Download AI Models</h3>
                    
                    <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                        Models will be cached in your browser. This only happens once.
                    </p>
                    
                    <div class="setup-progress">
                        <div class="setup-progress-bar">
                            <div class="setup-progress-fill" id="setupProgressFill"></div>
                        </div>
                        <div class="setup-progress-text" id="setupProgressText">Ready to download</div>
                    </div>
                    
                    <div id="setupModelList" style="font-size: 0.85rem; color: var(--text-muted);"></div>
                </div>
                
                <!-- Step 4: Complete -->
                <div class="setup-step" data-step="4">
                    <div style="text-align: center; padding: 2rem 0;">
                        <div style="font-size: 4rem; margin-bottom: 1rem;">‚úÖ</div>
                        <h3 style="font-size: 1.5rem; margin-bottom: 0.5rem; color: var(--success);">Setup Complete!</h3>
                        <p style="color: var(--text-secondary);">
                            Models are cached and ready. You can now transcribe audio offline.
                        </p>
                    </div>
                </div>
            </div>
            
            <div class="setup-footer">
                <div class="setup-nav-dots">
                    <div class="setup-dot active" data-dot="1"></div>
                    <div class="setup-dot" data-dot="2"></div>
                    <div class="setup-dot" data-dot="3"></div>
                    <div class="setup-dot" data-dot="4"></div>
                </div>
                <div style="display: flex; gap: 0.75rem;">
                    <button class="btn btn-ghost" id="setupBackBtn" style="display: none;">‚Üê Back</button>
                    <button class="btn btn-primary" id="setupNextBtn">Next ‚Üí</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Application -->
    <div class="app-container">
        <header class="app-header">
            <div class="app-brand">
                <h1 class="app-title">THAI TRANSCRIBER</h1>
                <div class="model-status-badge" id="modelStatusBadge">
                    <span class="status-dot" id="modelStatusDot"></span>
                    <span id="modelStatusText">Checking...</span>
                </div>
            </div>
            <div class="header-actions">
                <button class="btn btn-ghost" id="settingsBtn" title="Settings">‚öôÔ∏è</button>
                <button class="btn btn-secondary" id="exportBtn">üíæ Export</button>
            </div>
        </header>

        <div class="main-grid">
            <!-- Input Panel -->
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">Audio Input</span>
                </div>
                <div class="panel-content">
                    <div class="upload-zone" id="uploadZone">
                        <div class="upload-icon">üéµ</div>
                        <p class="upload-text">Drop audio file or click to browse</p>
                        <p class="upload-hint">M4A, MP3, WAV, OGG, WEBM ‚Ä¢ Up to 500MB</p>
                        <input type="file" class="file-input" id="fileInput" accept="audio/*,.m4a,.mp3,.wav,.ogg,.webm,.flac">
                    </div>
                    
                    <div class="file-card" id="fileCard">
                        <div class="file-card-header">
                            <div>
                                <div class="file-name" id="fileName"></div>
                                <div class="file-meta" id="fileMeta"></div>
                            </div>
                            <button class="file-remove" id="fileRemove" title="Remove file">√ó</button>
                        </div>
                        <div class="audio-player">
                            <audio id="audioElement" controls></audio>
                        </div>
                    </div>
                    
                    <div class="processing-section" id="processingSection">
                        <div class="processing-stages" id="processingStages">
                            <div class="stage" data-stage="load">
                                <div class="stage-icon">1</div>
                                <div class="stage-info">
                                    <div class="stage-label">Load Audio</div>
                                    <div class="stage-detail" id="loadDetail">Waiting...</div>
                                </div>
                            </div>
                            <div class="stage" data-stage="decode">
                                <div class="stage-icon">2</div>
                                <div class="stage-info">
                                    <div class="stage-label">Decode Audio</div>
                                    <div class="stage-detail" id="decodeDetail">Waiting...</div>
                                </div>
                            </div>
                            <div class="stage" data-stage="transcribe">
                                <div class="stage-icon">3</div>
                                <div class="stage-info">
                                    <div class="stage-label">Transcribe</div>
                                    <div class="stage-detail" id="transcribeDetail">Waiting...</div>
                                </div>
                            </div>
                            <div class="stage" data-stage="translate">
                                <div class="stage-icon">4</div>
                                <div class="stage-info">
                                    <div class="stage-label">Translate</div>
                                    <div class="stage-detail" id="translateDetail">Waiting...</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="progress-container" id="progressContainer" style="display: none;">
                            <div class="progress-bar">
                                <div class="progress-fill" id="progressFill"></div>
                            </div>
                            <div class="progress-text">
                                <span id="progressLabel">Processing...</span>
                                <span id="progressPercent">0%</span>
                            </div>
                        </div>
                        
                        <div class="action-row">
                            <button class="btn btn-primary btn-lg" id="transcribeBtn" disabled>
                                ‚ñ∂Ô∏è Transcribe
                            </button>
                            <button class="btn btn-secondary" id="cancelBtn" style="display: none;">
                                ‚èπ Cancel
                            </button>
                        </div>
                    </div>
                    
                    <div class="info-callout">
                        <div class="info-callout-title">üí° Tips for large files</div>
                        <p>‚Ä¢ Processing happens in 30-second chunks</p>
                        <p>‚Ä¢ Keep this tab open (can be in background)</p>
                        <p>‚Ä¢ Results appear as each chunk completes</p>
                    </div>
                </div>
            </div>
            
            <!-- Transcript Panel -->
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">Transcript</span>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-ghost" id="copyBtn" title="Copy all">üìã</button>
                        <button class="btn btn-ghost" id="clearTranscriptBtn" title="Clear">üóëÔ∏è</button>
                    </div>
                </div>
                <div class="panel-content">
                    <div class="transcript-container" id="transcriptContainer">
                        <div class="transcript-empty">
                            <div class="transcript-empty-icon">üéß</div>
                            <p>Load an audio file to begin transcription</p>
                            <p style="font-size: 0.85rem; margin-top: 0.5rem;">
                                Thai speech will be detected and translated to English
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <script type="module">
        // ============================================
        // THAI TRANSCRIBER v2 - Robust Implementation
        // ============================================
        
        // Configuration stored in localStorage
        const CONFIG_KEY = 'thai-transcriber-config';
        const SETUP_COMPLETE_KEY = 'thai-transcriber-setup-complete';
        
        // Default configuration
        const DEFAULT_CONFIG = {
            whisperModel: 'base',
            enableTranslation: true,
            chunkDuration: 30,
            language: 'th'
        };
        
        // State
        const state = {
            config: { ...DEFAULT_CONFIG },
            setupStep: 1,
            audioFile: null,
            audioArrayBuffer: null,
            audioBuffer: null,
            isProcessing: false,
            isCancelled: false,
            segments: [],
            whisperPipeline: null,
            translatorPipeline: null,
            modelsReady: false,
            processingWorker: null
        };
        
        // ============================================
        // Storage & Configuration
        // ============================================
        
        function loadConfig() {
            try {
                const saved = localStorage.getItem(CONFIG_KEY);
                if (saved) {
                    state.config = { ...DEFAULT_CONFIG, ...JSON.parse(saved) };
                }
            } catch (e) {
                console.warn('Failed to load config:', e);
            }
        }
        
        function saveConfig() {
            try {
                localStorage.setItem(CONFIG_KEY, JSON.stringify(state.config));
            } catch (e) {
                console.warn('Failed to save config:', e);
            }
        }
        
        function isSetupComplete() {
            return localStorage.getItem(SETUP_COMPLETE_KEY) === 'true';
        }
        
        function markSetupComplete() {
            localStorage.setItem(SETUP_COMPLETE_KEY, 'true');
        }
        
        // ============================================
        // Transformers.js Management
        // ============================================
        
        let transformers = null;
        
        async function loadTransformers() {
            if (transformers) return transformers;
            
            try {
                transformers = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2');
                
                // Configure cache to use IndexedDB
                transformers.env.cacheDir = 'transformers-cache';
                transformers.env.allowLocalModels = false;
                
                return transformers;
            } catch (error) {
                console.error('Failed to load Transformers.js:', error);
                throw new Error('Failed to load AI framework');
            }
        }
        
        async function loadWhisperModel(onProgress) {
            const tf = await loadTransformers();
            
            if (state.whisperPipeline) {
                return state.whisperPipeline;
            }
            
            const modelName = `Xenova/whisper-${state.config.whisperModel}`;
            
            state.whisperPipeline = await tf.pipeline(
                'automatic-speech-recognition',
                modelName,
                {
                    quantized: true,
                    progress_callback: (progress) => {
                        if (progress.status === 'progress' && onProgress) {
                            onProgress(progress.progress, `Downloading: ${progress.file}`);
                        }
                    }
                }
            );
            
            return state.whisperPipeline;
        }
        
        async function loadTranslationModel(onProgress) {
            if (!state.config.enableTranslation) return null;
            
            const tf = await loadTransformers();
            
            if (state.translatorPipeline) {
                return state.translatorPipeline;
            }
            
            state.translatorPipeline = await tf.pipeline(
                'translation',
                'Xenova/opus-mt-th-en',
                {
                    quantized: true,
                    progress_callback: (progress) => {
                        if (progress.status === 'progress' && onProgress) {
                            onProgress(progress.progress, `Downloading: ${progress.file}`);
                        }
                    }
                }
            );
            
            return state.translatorPipeline;
        }
        
        async function checkModelsLoaded() {
            try {
                const tf = await loadTransformers();
                
                // Check if models exist in cache
                // This is a simplified check - transformers.js handles caching internally
                state.modelsReady = state.whisperPipeline !== null;
                
                updateModelStatus();
                return state.modelsReady;
            } catch (e) {
                return false;
            }
        }
        
        // ============================================
        // Audio Processing (Robust Implementation)
        // ============================================
        
        // Keep reference to prevent garbage collection
        let persistentAudioContext = null;
        
        function getAudioContext() {
            if (!persistentAudioContext || persistentAudioContext.state === 'closed') {
                persistentAudioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000
                });
            }
            return persistentAudioContext;
        }
        
        async function loadAudioFileAsArrayBuffer(file, onProgress) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onprogress = (e) => {
                    if (e.lengthComputable && onProgress) {
                        const percent = (e.loaded / e.total) * 100;
                        onProgress(percent, `${formatBytes(e.loaded)} / ${formatBytes(e.total)}`);
                    }
                };
                
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(new Error('Failed to read file'));
                
                reader.readAsArrayBuffer(file);
            });
        }
        
        async function decodeAudioData(arrayBuffer, onProgress) {
            const audioContext = getAudioContext();
            
            // Resume context if suspended (happens on user interaction requirement)
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            
            onProgress && onProgress(0, 'Decoding audio...');
            
            // Clone the buffer since decodeAudioData consumes it
            const bufferCopy = arrayBuffer.slice(0);
            
            try {
                const audioBuffer = await audioContext.decodeAudioData(bufferCopy);
                onProgress && onProgress(100, 'Decode complete');
                return audioBuffer;
            } catch (error) {
                console.error('Decode error:', error);
                throw new Error(`Failed to decode audio: ${error.message}`);
            }
        }
        
        function extractMonoAudio(audioBuffer) {
            const numChannels = audioBuffer.numberOfChannels;
            const length = audioBuffer.length;
            const sampleRate = audioBuffer.sampleRate;
            
            // Get mono audio (average channels if stereo)
            const monoData = new Float32Array(length);
            
            if (numChannels === 1) {
                audioBuffer.copyFromChannel(monoData, 0);
            } else {
                const left = new Float32Array(length);
                const right = new Float32Array(length);
                audioBuffer.copyFromChannel(left, 0);
                audioBuffer.copyFromChannel(right, 1);
                
                for (let i = 0; i < length; i++) {
                    monoData[i] = (left[i] + right[i]) / 2;
                }
            }
            
            // Resample to 16kHz if needed
            if (sampleRate !== 16000) {
                return resampleTo16k(monoData, sampleRate);
            }
            
            return monoData;
        }
        
        function resampleTo16k(audioData, fromRate) {
            const toRate = 16000;
            const ratio = fromRate / toRate;
            const newLength = Math.round(audioData.length / ratio);
            const result = new Float32Array(newLength);
            
            for (let i = 0; i < newLength; i++) {
                const srcIndex = i * ratio;
                const srcFloor = Math.floor(srcIndex);
                const srcCeil = Math.min(srcFloor + 1, audioData.length - 1);
                const t = srcIndex - srcFloor;
                result[i] = audioData[srcFloor] * (1 - t) + audioData[srcCeil] * t;
            }
            
            return result;
        }
        
        function createChunks(audioData, chunkDurationSec, sampleRate = 16000) {
            const samplesPerChunk = chunkDurationSec * sampleRate;
            const chunks = [];
            
            for (let start = 0; start < audioData.length; start += samplesPerChunk) {
                const end = Math.min(start + samplesPerChunk, audioData.length);
                chunks.push({
                    data: audioData.slice(start, end),
                    startTime: start / sampleRate,
                    endTime: end / sampleRate
                });
            }
            
            return chunks;
        }
        
        // ============================================
        // Transcription & Translation
        // ============================================
        
        async function transcribeChunk(audioData) {
            const whisper = state.whisperPipeline;
            if (!whisper) throw new Error('Whisper model not loaded');
            
            const result = await whisper(audioData, {
                language: state.config.language === 'auto' ? null : state.config.language,
                task: 'transcribe',
                return_timestamps: false,
                chunk_length_s: 30,
                stride_length_s: 5
            });
            
            return result.text?.trim() || '';
        }
        
        async function translateText(text) {
            if (!text || !state.config.enableTranslation || !state.translatorPipeline) {
                return '';
            }
            
            // Skip if text appears to be English
            if (!containsThai(text)) {
                return '';
            }
            
            try {
                const result = await state.translatorPipeline(text, {
                    max_length: 512
                });
                return result[0]?.translation_text || '';
            } catch (e) {
                console.warn('Translation failed:', e);
                return '';
            }
        }
        
        function containsThai(text) {
            const thaiPattern = /[\u0E00-\u0E7F]/;
            return thaiPattern.test(text);
        }
        
        function detectLanguage(text) {
            const thaiChars = (text.match(/[\u0E00-\u0E7F]/g) || []).length;
            const totalChars = text.replace(/\s/g, '').length;
            if (totalChars === 0) return 'unknown';
            return (thaiChars / totalChars) > 0.3 ? 'th' : 'en';
        }
        
        // ============================================
        // Main Processing Pipeline
        // ============================================
        
        async function processAudio() {
            if (state.isProcessing || !state.audioFile) return;
            
            state.isProcessing = true;
            state.isCancelled = false;
            state.segments = [];
            
            clearTranscript();
            updateUIForProcessing(true);
            showKeepAlive(true);
            
            try {
                // Stage 1: Load file
                setStageActive('load');
                updateStageDetail('load', 'Reading file...');
                
                state.audioArrayBuffer = await loadAudioFileAsArrayBuffer(
                    state.audioFile,
                    (percent, detail) => {
                        updateStageDetail('load', detail);
                        updateProgress(percent * 0.15, 'Loading file...');
                    }
                );
                
                if (state.isCancelled) throw new Error('Cancelled');
                setStageComplete('load');
                updateStageDetail('load', formatBytes(state.audioArrayBuffer.byteLength));
                
                // Stage 2: Decode audio
                setStageActive('decode');
                updateStageDetail('decode', 'Decoding...');
                
                state.audioBuffer = await decodeAudioData(
                    state.audioArrayBuffer,
                    (percent, detail) => {
                        updateStageDetail('decode', detail);
                        updateProgress(15 + percent * 0.1, 'Decoding audio...');
                    }
                );
                
                if (state.isCancelled) throw new Error('Cancelled');
                setStageComplete('decode');
                
                const duration = state.audioBuffer.duration;
                updateStageDetail('decode', `${formatTime(duration)} @ ${state.audioBuffer.sampleRate}Hz`);
                
                // Extract and chunk audio
                const monoAudio = extractMonoAudio(state.audioBuffer);
                const chunks = createChunks(monoAudio, state.config.chunkDuration);
                
                // Stage 3: Transcribe
                setStageActive('transcribe');
                updateStageDetail('transcribe', `0/${chunks.length} chunks`);
                
                // Ensure models are loaded
                if (!state.whisperPipeline) {
                    updateStageDetail('transcribe', 'Loading model...');
                    await loadWhisperModel((p, d) => updateStageDetail('transcribe', d));
                }
                
                const transcriptionResults = [];
                
                for (let i = 0; i < chunks.length; i++) {
                    if (state.isCancelled) throw new Error('Cancelled');
                    
                    const chunk = chunks[i];
                    const chunkProgress = 25 + ((i / chunks.length) * 50);
                    
                    updateStageDetail('transcribe', `Chunk ${i + 1}/${chunks.length}`);
                    updateProgress(chunkProgress, `Transcribing ${i + 1}/${chunks.length}...`);
                    
                    const text = await transcribeChunk(chunk.data);
                    
                    if (text) {
                        transcriptionResults.push({
                            index: i,
                            startTime: chunk.startTime,
                            endTime: chunk.endTime,
                            text: text,
                            language: detectLanguage(text)
                        });
                    }
                }
                
                setStageComplete('transcribe');
                updateStageDetail('transcribe', `${transcriptionResults.length} segments`);
                
                // Stage 4: Translate
                if (state.config.enableTranslation) {
                    setStageActive('translate');
                    
                    if (!state.translatorPipeline) {
                        updateStageDetail('translate', 'Loading model...');
                        await loadTranslationModel((p, d) => updateStageDetail('translate', d));
                    }
                    
                    for (let i = 0; i < transcriptionResults.length; i++) {
                        if (state.isCancelled) throw new Error('Cancelled');
                        
                        const result = transcriptionResults[i];
                        const translateProgress = 75 + ((i / transcriptionResults.length) * 25);
                        
                        updateStageDetail('translate', `${i + 1}/${transcriptionResults.length}`);
                        updateProgress(translateProgress, `Translating ${i + 1}/${transcriptionResults.length}...`);
                        
                        if (result.language === 'th') {
                            result.translation = await translateText(result.text);
                        }
                        
                        // Add segment to UI immediately
                        state.segments.push(result);
                        appendSegment(result);
                    }
                    
                    setStageComplete('translate');
                    updateStageDetail('translate', 'Complete');
                } else {
                    // Skip translation, just add segments
                    setStageComplete('translate');
                    updateStageDetail('translate', 'Skipped');
                    
                    for (const result of transcriptionResults) {
                        state.segments.push(result);
                        appendSegment(result);
                    }
                }
                
                updateProgress(100, 'Complete!');
                showToast('success', 'Transcription complete!');
                
            } catch (error) {
                if (error.message === 'Cancelled') {
                    showToast('warning', 'Processing cancelled');
                } else {
                    console.error('Processing error:', error);
                    showToast('error', `Error: ${error.message}`);
                    setStageError(getCurrentStage());
                }
            } finally {
                state.isProcessing = false;
                updateUIForProcessing(false);
                showKeepAlive(false);
            }
        }
        
        function cancelProcessing() {
            state.isCancelled = true;
        }
        
        // ============================================
        // UI Updates
        // ============================================
        
        function updateUIForProcessing(isProcessing) {
            document.getElementById('transcribeBtn').disabled = isProcessing;
            document.getElementById('transcribeBtn').style.display = isProcessing ? 'none' : '';
            document.getElementById('cancelBtn').style.display = isProcessing ? '' : 'none';
            document.getElementById('progressContainer').style.display = isProcessing ? '' : 'none';
            document.getElementById('uploadZone').style.pointerEvents = isProcessing ? 'none' : '';
            document.getElementById('fileRemove').disabled = isProcessing;
        }
        
        function setStageActive(stage) {
            document.querySelectorAll('.stage').forEach(el => {
                el.classList.remove('active');
            });
            const stageEl = document.querySelector(`.stage[data-stage="${stage}"]`);
            if (stageEl) stageEl.classList.add('active');
        }
        
        function setStageComplete(stage) {
            const stageEl = document.querySelector(`.stage[data-stage="${stage}"]`);
            if (stageEl) {
                stageEl.classList.remove('active');
                stageEl.classList.add('complete');
                stageEl.querySelector('.stage-icon').textContent = '‚úì';
            }
        }
        
        function setStageError(stage) {
            const stageEl = document.querySelector(`.stage[data-stage="${stage}"]`);
            if (stageEl) {
                stageEl.classList.remove('active');
                stageEl.classList.add('error');
                stageEl.querySelector('.stage-icon').textContent = '‚úó';
            }
        }
        
        function updateStageDetail(stage, detail) {
            const el = document.getElementById(`${stage}Detail`);
            if (el) el.textContent = detail;
        }
        
        function getCurrentStage() {
            const active = document.querySelector('.stage.active');
            return active?.dataset.stage || 'load';
        }
        
        function resetStages() {
            document.querySelectorAll('.stage').forEach((el, i) => {
                el.classList.remove('active', 'complete', 'error');
                el.querySelector('.stage-icon').textContent = i + 1;
            });
            updateStageDetail('load', 'Waiting...');
            updateStageDetail('decode', 'Waiting...');
            updateStageDetail('transcribe', 'Waiting...');
            updateStageDetail('translate', 'Waiting...');
        }
        
        function updateProgress(percent, label) {
            document.getElementById('progressFill').style.width = `${percent}%`;
            document.getElementById('progressPercent').textContent = `${Math.round(percent)}%`;
            if (label) document.getElementById('progressLabel').textContent = label;
        }
        
        function updateModelStatus() {
            const dot = document.getElementById('modelStatusDot');
            const text = document.getElementById('modelStatusText');
            
            if (state.whisperPipeline) {
                dot.className = 'status-dot ready';
                text.textContent = `Whisper ${state.config.whisperModel} ready`;
                state.modelsReady = true;
            } else {
                dot.className = 'status-dot';
                text.textContent = 'Models not loaded';
                state.modelsReady = false;
            }
        }
        
        function showKeepAlive(show) {
            document.getElementById('keepaliveIndicator').classList.toggle('visible', show);
        }
        
        // ============================================
        // Transcript UI
        // ============================================
        
        function clearTranscript() {
            state.segments = [];
            document.getElementById('transcriptContainer').innerHTML = `
                <div class="transcript-empty">
                    <div class="transcript-empty-icon">üéß</div>
                    <p>Load an audio file to begin transcription</p>
                    <p style="font-size: 0.85rem; margin-top: 0.5rem;">
                        Thai speech will be detected and translated to English
                    </p>
                </div>
            `;
        }
        
        function appendSegment(segment) {
            const container = document.getElementById('transcriptContainer');
            const empty = container.querySelector('.transcript-empty');
            if (empty) empty.remove();
            
            const div = document.createElement('div');
            div.className = `segment ${segment.language}`;
            
            let html = `
                <div class="segment-header">
                    <span class="segment-lang">${segment.language === 'th' ? 'üáπüá≠ Thai' : 'üá∫üá∏ English'}</span>
                    <span class="segment-time">${formatTime(segment.startTime)} ‚Üí ${formatTime(segment.endTime)}</span>
                </div>
                <div class="segment-original">${escapeHtml(segment.text)}</div>
            `;
            
            if (segment.translation) {
                html += `<div class="segment-translation">${escapeHtml(segment.translation)}</div>`;
            }
            
            div.innerHTML = html;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }
        
        // ============================================
        // Setup Wizard
        // ============================================
        
        function showSetup() {
            document.getElementById('setupOverlay').classList.remove('hidden');
            state.setupStep = 1;
            updateSetupUI();
        }
        
        function hideSetup() {
            document.getElementById('setupOverlay').classList.add('hidden');
        }
        
        function updateSetupUI() {
            // Update steps
            document.querySelectorAll('.setup-step').forEach(el => {
                el.classList.toggle('active', el.dataset.step == state.setupStep);
            });
            
            // Update dots
            document.querySelectorAll('.setup-dot').forEach(el => {
                const dotStep = parseInt(el.dataset.dot);
                el.classList.remove('active', 'complete');
                if (dotStep === state.setupStep) el.classList.add('active');
                if (dotStep < state.setupStep) el.classList.add('complete');
            });
            
            // Update buttons
            document.getElementById('setupBackBtn').style.display = state.setupStep > 1 ? '' : 'none';
            
            const nextBtn = document.getElementById('setupNextBtn');
            if (state.setupStep === 3) {
                nextBtn.textContent = 'Download Models';
            } else if (state.setupStep === 4) {
                nextBtn.textContent = 'Start Using ‚Üí';
            } else {
                nextBtn.textContent = 'Next ‚Üí';
            }
        }
        
        async function handleSetupNext() {
            if (state.setupStep === 1) {
                // Get selected model
                const selected = document.querySelector('.setup-step[data-step="1"] .setup-option.selected');
                state.config.whisperModel = selected?.dataset.value || 'base';
                state.setupStep = 2;
                
            } else if (state.setupStep === 2) {
                // Get translation setting
                const selected = document.querySelector('.setup-step[data-step="2"] .setup-option.selected');
                state.config.enableTranslation = selected?.dataset.value === 'local';
                state.setupStep = 3;
                
                // Show model list
                const modelList = document.getElementById('setupModelList');
                modelList.innerHTML = `
                    <p>‚Ä¢ Whisper ${state.config.whisperModel} (transcription)</p>
                    ${state.config.enableTranslation ? '<p>‚Ä¢ Helsinki-NLP (Thai‚ÜíEnglish translation)</p>' : ''}
                `;
                
            } else if (state.setupStep === 3) {
                // Download models
                const nextBtn = document.getElementById('setupNextBtn');
                nextBtn.disabled = true;
                nextBtn.textContent = 'Downloading...';
                
                const progressFill = document.getElementById('setupProgressFill');
                const progressText = document.getElementById('setupProgressText');
                
                try {
                    // Load Whisper
                    progressText.textContent = 'Loading transcription model...';
                    await loadWhisperModel((progress, detail) => {
                        progressFill.style.width = `${progress * 0.7}%`;
                        progressText.textContent = detail;
                    });
                    
                    // Load translation if enabled
                    if (state.config.enableTranslation) {
                        progressText.textContent = 'Loading translation model...';
                        await loadTranslationModel((progress, detail) => {
                            progressFill.style.width = `${70 + progress * 0.3}%`;
                            progressText.textContent = detail;
                        });
                    }
                    
                    progressFill.style.width = '100%';
                    progressText.textContent = 'Models downloaded and cached!';
                    
                    saveConfig();
                    markSetupComplete();
                    
                    state.setupStep = 4;
                    
                } catch (error) {
                    progressText.textContent = `Error: ${error.message}`;
                    showToast('error', 'Failed to download models');
                }
                
                nextBtn.disabled = false;
                
            } else if (state.setupStep === 4) {
                hideSetup();
                updateModelStatus();
            }
            
            updateSetupUI();
        }
        
        function handleSetupBack() {
            if (state.setupStep > 1) {
                state.setupStep--;
                updateSetupUI();
            }
        }
        
        // Setup option selection
        document.querySelectorAll('.setup-option').forEach(option => {
            option.addEventListener('click', () => {
                const step = option.closest('.setup-step');
                step.querySelectorAll('.setup-option').forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
            });
        });
        
        // ============================================
        // Export Functions
        // ============================================
        
        function copyTranscript() {
            if (state.segments.length === 0) {
                showToast('warning', 'No transcript to copy');
                return;
            }
            
            const text = state.segments.map(s => {
                let line = `[${formatTime(s.startTime)}] ${s.text}`;
                if (s.translation) line += `\n  ‚Üí ${s.translation}`;
                return line;
            }).join('\n\n');
            
            navigator.clipboard.writeText(text).then(() => {
                showToast('success', 'Copied to clipboard');
            }).catch(() => {
                showToast('error', 'Failed to copy');
            });
        }
        
        function exportTranscript() {
            if (state.segments.length === 0) {
                showToast('warning', 'No transcript to export');
                return;
            }
            
            const baseName = (state.audioFile?.name || 'transcript').replace(/\.[^/.]+$/, '');
            
            // Text export
            const textContent = state.segments.map(s => {
                let line = `[${formatTime(s.startTime)} - ${formatTime(s.endTime)}] (${s.language.toUpperCase()})\n${s.text}`;
                if (s.translation) line += `\n‚Üí English: ${s.translation}`;
                return line;
            }).join('\n\n---\n\n');
            
            downloadFile(`${baseName}_transcript.txt`, textContent, 'text/plain');
            
            // JSON export
            const jsonContent = JSON.stringify({
                exportDate: new Date().toISOString(),
                sourceFile: state.audioFile?.name,
                config: state.config,
                segments: state.segments
            }, null, 2);
            
            setTimeout(() => {
                downloadFile(`${baseName}_transcript.json`, jsonContent, 'application/json');
            }, 500);
            
            showToast('success', 'Exported TXT and JSON files');
        }
        
        function downloadFile(filename, content, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // ============================================
        // Toast Notifications
        // ============================================
        
        function showToast(type, message) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icons = { success: '‚úì', error: '‚úó', warning: '‚ö†' };
            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || '‚Ñπ'}</span>
                <span class="toast-message">${message}</span>
            `;
            
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, 4000);
        }
        
        // ============================================
        // Utility Functions
        // ============================================
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // ============================================
        // File Handling
        // ============================================
        
        function handleFileSelect(file) {
            if (!file) return;
            
            state.audioFile = file;
            state.audioArrayBuffer = null;
            state.audioBuffer = null;
            
            // Update UI
            document.getElementById('uploadZone').classList.add('has-file');
            document.getElementById('fileCard').classList.add('visible');
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileMeta').textContent = `${formatBytes(file.size)} ‚Ä¢ ${file.type || 'audio'}`;
            
            const audioEl = document.getElementById('audioElement');
            audioEl.src = URL.createObjectURL(file);
            
            document.getElementById('transcribeBtn').disabled = false;
            resetStages();
        }
        
        function removeFile() {
            state.audioFile = null;
            state.audioArrayBuffer = null;
            state.audioBuffer = null;
            
            document.getElementById('uploadZone').classList.remove('has-file');
            document.getElementById('fileCard').classList.remove('visible');
            document.getElementById('transcribeBtn').disabled = true;
            document.getElementById('audioElement').src = '';
            
            resetStages();
        }
        
        // ============================================
        // Event Listeners
        // ============================================
        
        // File upload
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        
        uploadZone.addEventListener('click', () => fileInput.click());
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });
        uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('dragover'));
        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file?.type.startsWith('audio/') || file?.name.match(/\.(m4a|mp3|wav|ogg|webm|flac)$/i)) {
                handleFileSelect(file);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) handleFileSelect(e.target.files[0]);
        });
        
        document.getElementById('fileRemove').addEventListener('click', removeFile);
        
        // Processing
        document.getElementById('transcribeBtn').addEventListener('click', processAudio);
        document.getElementById('cancelBtn').addEventListener('click', cancelProcessing);
        
        // Transcript actions
        document.getElementById('copyBtn').addEventListener('click', copyTranscript);
        document.getElementById('exportBtn').addEventListener('click', exportTranscript);
        document.getElementById('clearTranscriptBtn').addEventListener('click', clearTranscript);
        
        // Setup wizard
        document.getElementById('setupNextBtn').addEventListener('click', handleSetupNext);
        document.getElementById('setupBackBtn').addEventListener('click', handleSetupBack);
        
        // Settings button (re-run setup)
        document.getElementById('settingsBtn').addEventListener('click', () => {
            state.setupStep = 1;
            showSetup();
            updateSetupUI();
        });
        
        // Prevent tab from sleeping during processing
        let wakeLock = null;
        
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                }
            } catch (e) {
                console.log('Wake Lock not available');
            }
        }
        
        function releaseWakeLock() {
            if (wakeLock) {
                wakeLock.release();
                wakeLock = null;
            }
        }
        
        // Handle visibility change - keep processing alive
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && state.isProcessing) {
                // Tab is hidden but we're processing - try to keep alive
                requestWakeLock();
            } else if (!document.hidden) {
                releaseWakeLock();
            }
        });
        
        // ============================================
        // Initialization
        // ============================================
        
        async function init() {
            loadConfig();
            
            // Check if setup is complete
            if (!isSetupComplete()) {
                showSetup();
            } else {
                hideSetup();
                
                // Try to reload models from cache
                updateModelStatus();
                
                // Pre-load models in background
                try {
                    await loadWhisperModel();
                    if (state.config.enableTranslation) {
                        await loadTranslationModel();
                    }
                    updateModelStatus();
                } catch (e) {
                    console.log('Models will load on first use');
                }
            }
        }
        
        init();
    </script>
</body>
</html>
