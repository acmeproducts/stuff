<!-- orbital8-v12.17 - 2025-08-21 12:13 AM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no, maximum-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Orbital8 v12.17</title>
    <script src="https://alcdn.msauth.net/browser/2.28.1/js/msal-browser.min.js"></script>
    <style>
        /* ===== ORBITAL8 v12.17 - Regression Fix Release ===== */
        /* Changes in this version:
           - FIX (Grid UI): Restored the correct orange accent button colors in the Grid View's
             bulk action bar, matching the application baseline. All five buttons are present.
           - FIX (Details Panel): Corrected the CSS for the tag input field in the Details modal to
             ensure dark text on a light background.
           - FIX (Grid Logic): Corrected the bulk move logic. When moving items (even to the same
             stack), they are now correctly re-sorted to the top of the stack, and the grid view
             updates instantly to reflect the new order. Search results are also moved to the top.
           - FEATURE (Tags): The "Tags" tab in the Details modal now displays a list of all unique
             tags used in the current folder, making it easier to apply existing tags consistently.
           - Versioning: Updated to v12.17.
        */
        
        :root {
            --app-accent: #f59e0b;
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.3);
            --dark-gradient: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
            --glow-opacity: 0.6;
            --ripple-duration: 1500ms;
        }

        * { box-sizing: border-box; }
        
        body, html {
            margin: 0; padding: 0; height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden; background: #000; overscroll-behavior: none; touch-action: none;
        }
        
        /* ===== Screen & Card Styles ===== */
        .screen {
            position: fixed; inset: 0; background: var(--dark-gradient);
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000;
        }
        .screen.hidden { display: none; }
        
        .card {
            background: var(--glass-bg); backdrop-filter: blur(20px);
            border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 20px;
            padding: 40px; text-align: center; max-width: 500px; width: 90%;
        }
        
        /* ===== Typography ===== */
        .title { color: white; font-size: 24px; font-weight: 600; margin-bottom: 16px; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8); }
        .subtitle { color: rgba(255, 255, 255, 0.7); font-size: 16px; margin-bottom: 24px; }
        
        /* ===== Form Elements ===== */
        .input, .notes-textarea, .tag-input {
            width: 100%; padding: 12px 16px; border: 1px solid var(--glass-border); border-radius: 12px;
            background: var(--glass-bg); color: white; font-size: 14px; margin-bottom: 16px; backdrop-filter: blur(10px);
        }
        .input::placeholder, .tag-input::placeholder { color: rgba(255, 255, 255, 0.5); }
        .input:focus, .notes-textarea:focus, .tag-input:focus {
            outline: none; border-color: var(--app-accent); box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.2);
        }
        .notes-textarea { min-height: 120px; font-family: inherit; resize: vertical; }

        #action-modal .tag-input, #grid-modal .input, #details-modal .tag-input, #details-modal .notes-textarea {
            color: #1f2937;
            background: #f3f4f6;
            border-color: #d1d5db;
        }
        
        /* ===== Buttons ===== */
        .button, .folder-button, .btn {
            background: linear-gradient(45deg, var(--app-accent), #d97706); border: none; border-radius: 15px;
            color: white; font-size: 18px; font-weight: 600; padding: 16px 32px; cursor: pointer;
            transition: all 0.3s ease; box-shadow: 0 4px 20px rgba(245, 158, 11, 0.4); width: 100%; margin-bottom: 16px;
        }
        .button:hover:not(:disabled), .folder-button:hover, .btn:hover:not(:disabled) {
            transform: translateY(-2px); box-shadow: 0 6px 25px rgba(245, 158, 11, 0.6);
        }
        .button:disabled, .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
        
        .folder-button {
            flex: 1; padding: 12px 24px; border: 1px solid var(--glass-border); background: var(--glass-bg);
            font-size: 14px; backdrop-filter: blur(10px); width: auto;
        }
        .folder-button.danger { border-color: rgba(239, 68, 68, 0.3); color: #ef4444; }
        .folder-button.danger:hover { background: rgba(239, 68, 68, 0.1); }
        
        .btn { padding: 4px 12px; border-radius: 6px; font-size: 14px; font-weight: 500; margin-bottom: 0; width: auto; }
        .btn-primary { background: linear-gradient(45deg, var(--app-accent), #d97706); color: white; }
        .btn-primary:hover:not(:disabled) { background: linear-gradient(45deg, #fbbf24, #f59e0b); }
        .btn-danger { background: #ef4444; color: white; }
        .btn-danger:hover:not(:disabled) { background: #dc2626; }
        .btn-secondary { background: #e5e7eb; color: #4b5563; }
        .btn-secondary:hover:not(:disabled) { background: #d1d5db; }
        
        /* ===== Provider Selection Specific ===== */
        .provider-button {
            display: flex; align-items: center; justify-content: center; gap: 12px;
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px; padding: 20px; margin-bottom: 16px; color: white;
            font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        .provider-button:hover {
            background: rgba(255, 255, 255, 0.2); border-color: var(--app-accent);
            transform: translateY(-2px); box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        }
        
        .settings-section {
            margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .intensity-options { display: flex; gap: 8px; justify-content: center; margin-bottom: 16px; }
        .intensity-btn {
            padding: 8px 16px; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 8px;
            background: rgba(255, 255, 255, 0.1); color: white; cursor: pointer; font-size: 12px;
            transition: all 0.2s ease;
        }
        .intensity-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .intensity-btn.active { border-color: var(--app-accent); background: rgba(245, 158, 11, 0.2); color: var(--app-accent); }
        
        .checkbox-label {
            color: rgba(255, 255, 255, 0.9); font-size: 14px; display: flex;
            align-items: center; gap: 8px; cursor: pointer; justify-content: center;
        }
        
        /* ===== Status & Feedback ===== */
        .status {
            padding: 12px; border-radius: 8px; margin-top: 16px; font-size: 14px; font-weight: 500;
        }
        .status.success { background: rgba(16, 185, 129, 0.2); color: #10b981; border: 1px solid rgba(16, 185, 129, 0.3); }
        .status.error { background: rgba(239, 68, 68, 0.2); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.3); }
        .status.info { background: rgba(59, 130, 246, 0.2); color: #3b82f6; border: 1px solid rgba(59, 130, 246, 0.3); }
        
        .toast {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8); color: white; padding: 12px 20px; border-radius: 8px;
            font-size: 14px; font-weight: 500; z-index: 1000; opacity: 0; transition: opacity 0.3s ease; backdrop-filter: blur(10px);
        }
        .toast.show { opacity: 1; }
        .toast.success { background: rgba(16, 185, 129, 0.9); }
        .toast.info { background: rgba(59, 130, 246, 0.9); }
        .toast.error { background: rgba(239, 68, 68, 0.9); }
        
        /* ===== Folder Items ===== */
        .folder-list { flex: 1; overflow-y: auto; margin-bottom: 20px; max-height: 400px; }
        .folder-item {
            display: flex; align-items: center; padding: 12px 16px; margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px; cursor: pointer; transition: all 0.2s ease; color: white; justify-content: space-between;
        }
        .folder-item:hover {
            background: rgba(255, 255, 255, 0.1); border-color: rgba(245, 158, 11, 0.3); transform: translateY(-1px);
        }
        .folder-icon { width: 20px; height: 20px; margin-right: 12px; color: var(--app-accent); }
        .folder-info { flex: 1; text-align: left; }
        .folder-name { font-weight: 500; margin-bottom: 2px; }
        .folder-date { font-size: 12px; color: rgba(255, 255, 255, 0.6); }
        
        .folder-actions { display: flex; gap: 8px; margin-left: 12px; }
        .folder-action-btn {
            padding: 6px 12px; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 8px;
            background: rgba(255, 255, 255, 0.1); color: white; font-size: 12px; cursor: pointer;
            transition: all 0.2s ease; backdrop-filter: blur(10px);
        }
        .folder-action-btn:hover { background: rgba(255, 255, 255, 0.2); transform: translateY(-1px); }
        .folder-action-btn.drill-btn { border-color: rgba(245, 158, 11, 0.4); color: var(--app-accent); }
        .folder-action-btn.drill-btn:hover { background: rgba(245, 158, 11, 0.2); }
        .folder-action-btn.select-btn { border-color: rgba(16, 185, 129, 0.4); color: #10b981; }
        .folder-action-btn.select-btn:hover { background: rgba(16, 185, 129, 0.2); }
        
        /* ===== Loading & Progress ===== */
        .spinner {
            width: 20px; height: 20px; border: 2px solid rgba(245, 158, 11, 0.3);
            border-radius: 50%; border-top-color: var(--app-accent); animation: spin 1s linear infinite; margin-right: 12px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .loading-counter { color: var(--app-accent); font-size: 48px; font-weight: 700; margin: 20px 0; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8); }
        .loading-message { color: rgba(255, 255, 255, 0.7); font-size: 16px; margin-bottom: 20px; }
        .loading-progress { width: 100%; height: 6px; background: rgba(255, 255, 255, 0.2); border-radius: 3px; overflow: hidden; margin-bottom: 20px; }
        .loading-progress-bar { height: 100%; background: linear-gradient(45deg, var(--app-accent), #d97706); border-radius: 3px; transition: width 0.3s ease; width: 0%; }
        
        /* ===== Main App Layout ===== */
        .app-container { position: relative; width: 100vw; height: 100vh; background: var(--dark-gradient); overflow: hidden; }
        .nav-button {
            position: absolute; top: 20px; background: var(--glass-bg); backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 20px; padding: 8px 12px; font-size: 11px;
            color: white; cursor: pointer; transition: all 0.3s ease; z-index: 15; display: flex; align-items: center; gap: 6px; opacity: 0.7;
        }
        .nav-button:hover { opacity: 1; background: rgba(255, 255, 255, 0.2); }
        .nav-button.back { left: 20px; }
        .nav-button.details { right: 100px; }
        #save-button {
            right: 20px;
            padding: 8px 16px;
        }
        #save-button.saving .spinner { display: inline-block; }
        #save-button:not(.saving) .spinner { display: none; }
        
        /* ===== Folder Tooltip ===== */
        .folder-tooltip {
            position: absolute; background: rgba(0,0,0,0.85); color: white;
            padding: 8px 12px; border-radius: 6px; font-size: 12px;
            z-index: 1000; pointer-events: none; white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        /* ===== Image Display ===== */
        .image-viewport { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 1; overflow: hidden; }
        .center-image {
            max-width: 100vw; max-height: 100vh; width: auto; height: auto; object-fit: contain; user-select: none; pointer-events: none;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.2s ease; transform-origin: center center; cursor: grab;
        }
        .center-image.dragging { filter: brightness(0.9); cursor: grabbing; }
        .center-image.zoomable { pointer-events: auto; }
        
        .filename-overlay {
            position: absolute; bottom: 25px; left: 50%; transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6); color: white; padding: 6px 14px;
            border-radius: 12px; font-size: 12px; font-weight: 500; z-index: 5;
            max-width: 90%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            opacity: 0; transition: opacity 0.3s ease; pointer-events: auto; text-decoration: none;
        }
        .filename-overlay:hover { background-color: rgba(0, 0, 0, 0.8); color: var(--app-accent); }
        .filename-overlay.visible { opacity: 1; }

        /* ===== Edge Effects ===== */
        .edge-glow { position: absolute; opacity: 0; transition: opacity 0.2s ease; z-index: 2; pointer-events: none; }
        .edge-glow.top { top: 0; left: 0; right: 0; height: 8px; background: linear-gradient(180deg, rgba(245, 158, 11, var(--glow-opacity)) 0%, transparent 100%); }
        .edge-glow.bottom { 
            bottom: 0; left: 0; right: 0; height: 8px; 
            background: linear-gradient(0deg, rgba(245, 158, 11, var(--glow-opacity)) 0%, transparent 100%);
            bottom: env(safe-area-inset-bottom, 0px);
        }
        .edge-glow.left { top: 0; left: 0; bottom: 0; width: 8px; background: linear-gradient(90deg, rgba(245, 158, 11, var(--glow-opacity)) 0%, transparent 100%); }
        .edge-glow.right { top: 0; right: 0; bottom: 0; width: 8px; background: linear-gradient(270deg, rgba(245, 158, 11, var(--glow-opacity)) 0%, transparent 100%); }
        .edge-glow.active { opacity: 1; }
        
        /* ===== Pills & Counters ===== */
        .pill-counter {
            position: fixed; backdrop-filter: blur(10px); border-radius: 20px; padding: 12px 20px; font-size: 18px; font-weight: 500;
            color: black; opacity: 0; transition: all 0.3s ease; cursor: pointer; z-index: 10; min-width: 50px; text-align: center;
        }
        .pill-counter.visible { opacity: 0.9; }
        .pill-counter.active { font-weight: 700; background: white; opacity: 1; border: 3px solid black; }
        .pill-counter:not(.active) { background: rgba(128, 128, 128, 0.4); border: none; }
        .pill-counter:hover { opacity: 1; transform: scale(1.05); }
        .pill-counter.top { top: 10px; left: 50%; transform: translateX(-50%); }
        .pill-counter.bottom { bottom: 60px; left: 50%; transform: translateX(-50%); }
        .pill-counter.left { left: 10px; top: 50%; transform: translateY(-50%); }
        .pill-counter.right { right: 10px; top: 50%; transform: translateY(-50%); }
        
        /* ===== Enhanced Ripple Effects ===== */
        .pill-counter::before, .pill-counter::after {
            content: ''; position: absolute; border: 2px solid rgba(245, 158, 11, 0.8); border-radius: 16px; opacity: 0; pointer-events: none; z-index: -1;
        }
        .pill-counter.triple-ripple::before { animation: tripleRipple1 var(--ripple-duration) ease-out; }
        .pill-counter.triple-ripple::after { animation: tripleRipple2 var(--ripple-duration) ease-out 0.2s; }
        .pill-counter.triple-ripple { animation: tripleRipple3 var(--ripple-duration) ease-out 0.4s; }
        .pill-counter.glow-effect { 
            box-shadow: 0 0 25px rgba(245, 158, 11, var(--glow-opacity)), 0 0 50px rgba(245, 158, 11, calc(var(--glow-opacity) * 0.6)); 
            animation: sustainedGlow 1s ease-out calc(var(--ripple-duration) * 1); 
        }
        
        .high-intensity-mode .pill-counter.glow-effect {
            box-shadow: 0 0 35px rgba(245, 158, 11, 1), 0 0 70px rgba(245, 158, 11, 0.8), 0 0 100px rgba(245, 158, 11, 0.6);
        }
        
        @keyframes tripleRipple1 { 0% { opacity: 0.9; transform: scale(1); inset: -4px; } 100% { opacity: 0; transform: scale(2); inset: -20px; } }
        @keyframes tripleRipple2 { 0% { opacity: 0.7; transform: scale(1); inset: -6px; } 100% { opacity: 0; transform: scale(2.5); inset: -30px; } }
        @keyframes tripleRipple3 { 0% { box-shadow: 0 0 10px rgba(245, 158, 11, 0.5); } 50% { box-shadow: 0 0 20px rgba(245, 158, 11, 0.8); } 100% { box-shadow: 0 0 15px rgba(245, 158, 11, 0.6); } }
        @keyframes sustainedGlow { 0% { box-shadow: 0 0 25px rgba(245, 158, 11, var(--glow-opacity)), 0 0 50px rgba(245, 158, 11, calc(var(--glow-opacity) * 0.6)); } 50% { box-shadow: 0 0 35px rgba(245, 158, 11, 1), 0 0 70px rgba(245, 158, 11, 0.8); } 100% { box-shadow: 0 0 10px rgba(245, 158, 11, 0.4); } }
        
        /* ===== Empty State ===== */
        .empty-state {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;
            color: rgba(255, 255, 255, 0.7); font-size: 18px; font-weight: 300; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8); z-index: 5;
        }
        .empty-message { margin-bottom: 20px; font-size: 24px; font-weight: 400; }
        .new-images-button {
            background: rgba(245, 158, 11, 0.2); border: 1px solid rgba(245, 158, 11, 0.4); border-radius: 20px;
            padding: 12px 24px; color: white; font-size: 16px; cursor: pointer; transition: all 0.2s ease;
        }
        .new-images-button:hover { background: rgba(245, 158, 11, 0.4); transform: translateY(-2px); }
        
        /* ===== Modal System ===== */
        .modal { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 50; }
        .modal.hidden { display: none !important; }
        .modal-content {
            background: white; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 100%; height: 100%; max-width: 1152px; max-height: 90vh; margin: 16px; display: flex; flex-direction: column;
        }
        .action-modal { max-width: 448px; height: auto; padding: 24px; }
        
        /* ===== Enhanced Grid System ===== */
        .modal-header { position: sticky; top: 0; background: white; z-index: 10; border-bottom: 1px solid #e5e7eb; }
        .modal-header-main { padding: 12px 16px; border-bottom: 1px solid #f3f4f6; display: flex; align-items: center; justify-content: space-between; }
        .modal-header-left { display: flex; align-items: center; gap: 12px; }
        .modal-title { font-size: 20px; font-weight: 500; color: #1f2937; line-height: 1.5; }
        .select-all-btn {
            background-color: #e5e7eb; color: #4b5563; padding: 2px 8px; border-radius: 9999px; font-size: 14px; font-weight: 500;
            display: inline-block; min-width: 36px; text-align: center; cursor: pointer; transition: background-color 0.2s; border: none;
        }
        .select-all-btn:hover { background-color: #d1d5db; }
        .close-btn {
            color: #6b7280; transition: all 0.2s; cursor: pointer; background: transparent; border: none; border-radius: 6px;
            padding: 4px; display: flex; align-items: center; justify-content: center;
        }
        .close-btn:hover { color: #374151; background: rgba(0, 0, 0, 0.05); }
        .close-btn svg { width: 24px; height: 24px; }
        
        .grid-row-2 { padding: 8px 16px; border-bottom: 1px solid #e5e7eb; display: flex; align-items: center; justify-content: space-between; }
        .selection-count {
            background-color: #dbeafe; color: #1e40af; padding: 4px 12px; border-radius: 9999px; font-size: 14px;
            display: flex; align-items: center; gap: 8px;
        }
        .deselect-all-btn {
            margin-left: 4px; transition: all 0.2s; cursor: pointer; background: transparent; border: none; border-radius: 4px;
            padding: 2px; display: flex; align-items: center; justify-content: center;
        }
        .deselect-all-btn:hover { color: #1e3a8a; background: rgba(0, 0, 0, 0.05); }
        .deselect-all-btn svg { width: 16px; height: 16px; }
        
        .zoom-control { display: flex; align-items: center; gap: 8px; }
        #grid-size { width: 80px; }
        #grid-size-value { font-size: 14px; color: #4b5563; min-width: 20px; }
        
        .grid-row-3 { padding: 8px 16px; border-bottom: 1px solid #e5e7eb; display: flex; align-items: center; gap: 8px; position: relative; }
        #omni-search { flex-grow: 1; padding: 6px 30px 6px 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; }
        #clear-search-btn {
            position: absolute; right: 24px; top: 50%; transform: translateY(-50%);
            color: #9ca3af; cursor: pointer; display: none; background: none; border: none; padding: 0;
        }
        #clear-search-btn:hover { color: #6b7280; }
        
        .grid-row-4 { padding: 8px 16px; border-bottom: 1px solid #e5e7eb; min-height: 41px; display: flex; justify-content: flex-start; }
        .bulk-actions { display: flex; align-items: center; gap: 8px; }
        .bulk-actions .btn { padding: 4px 10px; font-size: 13px; }
        
        .grid-content { flex: 1; overflow-y: auto; padding: 16px; }
        .grid-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 16px; }
        
        .grid-item {
            position: relative; background-color: #f3f4f6; border-radius: 8px;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            overflow: hidden; aspect-ratio: 1 / 1;
        }
        .grid-image {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: contain; opacity: 0; transition: opacity 0.3s ease;
        }
        .grid-image.loaded { opacity: 1; }
        .grid-item.selected { box-shadow: 0 0 0 4px #3b82f6; }
        
        /* ===== Details Modal ===== */
        .details-modal-content { max-width: 800px; max-height: 95vh; height: 95vh; display: flex; flex-direction: column; }
        .details-header { display: flex; align-items: center; justify-content: space-between; padding: 16px; border-bottom: 1px solid #e5e7eb; flex-shrink: 0; }
        .details-title { font-size: 18px; font-weight: 500; color: #1f2937; }
        .tab-nav { display: flex; border-bottom: 1px solid #e5e7eb; background: #f8fafc; flex-shrink: 0; }
        .tab-button {
            flex: 1; padding: 16px; border: none; background: transparent; color: #6b7280; font-size: 14px; font-weight: 500;
            cursor: pointer; transition: all 0.2s; border-bottom: 2px solid transparent;
        }
        .tab-button:hover { color: #374151; background: rgba(0, 0, 0, 0.02); }
        .tab-button.active { color: var(--app-accent); border-bottom-color: var(--app-accent); background: white; }
        .details-content { flex: 1; overflow-y: auto; overflow-x: hidden; min-height: 0; }
        .tab-content { display: none; padding: 20px; height: 100%; }
        .tab-content.active { display: block; }
        
        /* ===== Tags & Ratings ===== */
        .tags-container { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; min-height: 40px; }
        .tag-item { display: inline-flex; align-items: center; background: #dbeafe; color: #1e40af; padding: 4px 8px; border-radius: 12px; font-size: 12px; gap: 6px; }
        .tag-remove {
            background: transparent; border: none; color: #1e40af; cursor: pointer; font-size: 14px; line-height: 1; padding: 0;
            width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: background-color 0.2s;
        }
        .tag-remove:hover { background: rgba(59, 130, 246, 0.1); }
        .add-tag-btn {
            background: #f3f4f6; border: 1px dashed #d1d5db; border-radius: 12px; padding: 4px 12px;
            font-size: 12px; color: #6b7280; cursor: pointer; transition: all 0.2s;
        }
        .add-tag-btn:hover { background: #e5e7eb; color: #374151; }
        
        .star-rating { display: flex; gap: 4px; }
        .star { width: 24px; height: 24px; cursor: pointer; color: #d1d5db; transition: color 0.2s; }
        .star:hover, .star.active { color: #fbbf24; }
        
        /* ===== Metadata Table ===== */
        .metadata-table { width: 100%; border-collapse: collapse; border: 1px solid #e5e7eb; font-size: 13px; }
        .metadata-table td { padding: 8px 12px; border-bottom: 1px solid #e5e7eb; vertical-align: top; word-wrap: break-word; }
        .metadata-table .key-cell {
            font-weight: 500; color: #374151; width: 25%; border-right: 1px solid #e5e7eb; background: #f9fafb; min-width: 120px;
        }
        .metadata-table .value-cell { color: #6b7280; white-space: pre-wrap; position: relative; max-width: 0; word-break: break-all; }
        .copy-button {
            background: var(--app-accent); border: none; border-radius: 4px; padding: 4px 8px; font-size: 11px; color: white;
            cursor: pointer; transition: all 0.2s; margin-left: 8px; vertical-align: top; font-weight: 500;
        }
        .copy-button:hover { background: #d97706; transform: translateY(-1px); box-shadow: 0 2px 4px rgba(245, 158, 11, 0.3); }
        .copy-button:active { transform: translateY(0); box-shadow: 0 1px 2px rgba(245, 158, 11, 0.3); }
        .copy-button.copied { background: #10b981; transform: scale(1.1); }
        
        /* ===== Footer ===== */
        .app-footer {
            position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.8);
            color: rgba(255, 255, 255, 0.6); text-align: center; padding: 4px 8px;
            font-size: 10px; z-index: 5; backdrop-filter: blur(10px);
        }
        
        /* ===== Focus Mode & Counters ===== */
        .focus-mode-ui, #normal-image-count {
            position: absolute; background: rgba(0, 0, 0, 0.4); color: white;
            border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 20px;
            z-index: 20; display: none; align-items: center; justify-content: center;
            backdrop-filter: blur(10px); transition: all 0.2s ease;
            font-size: 11px; padding: 8px 12px; cursor: pointer;
        }
        .focus-mode-ui:hover, #normal-image-count:hover { background: rgba(0, 0, 0, 0.6); border-color: white; }
        #focus-stack-name { top: 20px; left: 20px; }
        #focus-image-count { bottom: 20px; left: 20px; }
        #normal-image-count { bottom: 20px; left: 20px; display: flex; }
        #focus-delete-btn { bottom: 20px; right: 20px; width: 44px; height: 44px; padding: 0; border-radius: 50%; }
        
        .app-container.focus-mode .pill-counter,
        .app-container.focus-mode .nav-button.back,
        .app-container.focus-mode .filename-overlay,
        .app-container.focus-mode #normal-image-count { display: none; }
        .app-container.focus-mode .focus-mode-ui { display: flex; }
        .app-container.focus-mode .nav-button.details { background: rgba(0, 0, 0, 0.4); }
        
        /* ===== Responsive ===== */
        .hidden { display: none !important; }
        
        @media screen and (min-width: 768px) {
            .pill-counter { font-size: 16px; padding: 8px 16px; min-width: 40px; }
            .nav-button { font-size: 14px; padding: 10px 16px; }
            .focus-mode-ui, #normal-image-count { font-size: 14px; padding: 10px 16px; }
        }
        
        @media screen and (max-width: 767px) {
            .nav-button { font-size: 16px; padding: 12px 20px; border-radius: 25px; min-width: 80px; }
            .pill-counter.bottom { bottom: 80px; }
            .filename-overlay { font-size: 11px; padding: 5px 12px; bottom: 35px; }
            .details-modal-content { max-width: 100vw; max-height: 100vh; height: 100vh; margin: 0; border-radius: 0; }
            .metadata-table .key-cell { width: 30%; min-width: 80px; font-size: 12px; }
            .metadata-table .value-cell { font-size: 12px; }
            .copy-button { font-size: 10px; padding: 3px 6px; }
            
            .app-container, .image-viewport { height: 100vh; height: 100dvh; }
        }
        
        @supports (height: 100dvh) { .app-container, .image-viewport { height: 100dvh; } }
    </style>
</head>
<body>
    <!-- Provider Selection Screen -->
    <div class="screen" id="provider-screen">
        <div class="card">
            <h1 class="title" style="font-size: 32px;">Orbital8</h1>
            <p class="subtitle">Select your cloud storage provider</p>
            <button class="provider-button" id="google-drive-btn">
                <svg style="width: 24px; height: 24px;" viewBox="0 0 24 24"><path fill="currentColor" d="M10.23 15.6l-4.23-7.32L3.82 12l6.41 11.1l6.41-11.1l-2.18-3.78l-4.23 7.32Z"/><path fill="currentColor" d="m20.18 12l-2.18-3.78l-4.23-7.32H9.15l6.41-11.1h4.62l3.41 5.91L20.18 12Z" opacity=".5"/><path fill="currentColor" d="m8.36 3.9l-6.41 11.1L1.27 12l2.18 3.78l4.23 7.32h4.62l-6.41-11.1l2.47-4.28L8.36 3.9Z" opacity=".5"/></svg>
                Google Drive
            </button>
            <button class="provider-button" id="onedrive-btn">
                <svg style="width: 24px; height: 24px;" viewBox="0 0 24 24"><path fill="#0072c6" d="M3.1 7.2c-.3-.2-.6-.1-.7.2L.1 12v.1c0 .3.2.5.5.5h5.4c.3 0 .5-.2.5-.5l2.4-4.1c.1-.2 0-.5-.2-.6L3.1 7.2z"/><path fill="#0072c6" d="M9.5 7.2c-.2-.1-.5 0-.6.2l-2.4 4.1c0 .3.2.5.5.5h5.4c.3 0 .5-.2.5-.5l2.4-4.1c.1-.2 0-.5-.2-.6L9.5 7.2z"/><path fill="#0072c6" d="M16 7.2c-.2-.1-.5 0-.6.2l-2.4 4.1c0 .3.2.5.5.5h5.4c.3 0 .5-.2.5-.5l2.4-4.1c.1-.2 0-.5-.2-.6L16 7.2z"/></svg>
                OneDrive
            </button>
            <div class="settings-section">
                <label style="color: rgba(255,255,255,0.9); font-size: 14px; font-weight: 500; display: block; margin-bottom: 8px;">Visual Cue Intensity:</label>
                <div class="intensity-options">
                    <button class="intensity-btn" data-level="low">Low</button>
                    <button class="intensity-btn active" data-level="medium">Medium</button>
                    <button class="intensity-btn" data-level="high">High</button>
                </div>
                <label class="checkbox-label"><input type="checkbox" id="haptic-enabled" checked style="margin: 0;">Enable Haptic Feedback (Mobile)</label>
            </div>
            <div id="provider-status" class="status info">Choose your preferred cloud storage</div>
        </div>
        <div class="app-footer">orbital8-v12.17 - 2025-08-20 06:30 PM</div>
    </div>
    
    <!-- Auth & Folder Screens -->
    <div class="screen hidden" id="gdrive-auth-screen"><div class="card"><h1 class="title">Google Drive</h1><p class="subtitle">Connect to Google Drive</p><input type="password" id="gdrive-client-secret" class="input" placeholder="Enter Google Client Secret"><button class="button" id="gdrive-auth-button">Connect Drive</button><button class="button" id="gdrive-back-button" style="background: rgba(128,128,128,0.3);">← Back</button><div id="gdrive-auth-status" class="status info">Enter your client secret to continue</div></div><div class="app-footer">orbital8-v12.17 - 2025-08-20 06:30 PM</div></div>
    <div class="screen hidden" id="onedrive-auth-screen"><div class="card"><h1 class="title">OneDrive</h1><p class="subtitle">Connect to OneDrive</p><button class="button" id="onedrive-auth-button">Connect OneDrive</button><button class="button" id="onedrive-back-button" style="background: rgba(128,128,128,0.3);">← Back</button><div id="onedrive-auth-status" class="status info">Click to sign in with your Microsoft account</div></div><div class="app-footer">orbital8-v12.17 - 2025-08-20 06:30 PM</div></div>
    <div class="screen hidden" id="gdrive-folder-screen"><div class="card" style="max-height: 80vh; display: flex; flex-direction: column;"><h2 class="title">Google Drive - Select Folder</h2><div class="subtitle">Choose a folder containing images</div><div class="folder-list" id="gdrive-folder-list"></div><div class="folder-actions"><button class="folder-button" id="gdrive-refresh-folders">Refresh</button><button class="folder-button" id="gdrive-back-to-provider">← Provider</button><button class="folder-button danger" id="gdrive-logout">Disconnect</button></div></div><div class="app-footer">orbital8-v12.17 - 2025-08-20 06:30 PM</div></div>
    <div class="screen hidden" id="onedrive-folder-screen"><div class="card" style="max-height: 80vh; display: flex; flex-direction: column;"><h2 class="title">OneDrive - Select Folder</h2><div class="subtitle" id="onedrive-folder-subtitle">Starting from Downloads folder - browse or select any folder</div><div class="folder-list" id="onedrive-folder-list"></div><div class="folder-actions"><button class="folder-button" id="onedrive-refresh-folders">Refresh</button><button class="folder-button" id="onedrive-back-to-provider">← Provider</button><button class="folder-button danger" id="onedrive-logout">Disconnect</button></div></div><div class="app-footer">orbital8-v12.17 - 2025-08-20 06:30 PM</div></div>
    
    <!-- Loading Screen -->
    <div class="screen hidden" id="loading-screen" style="z-index: 1500;"><div class="card"><h2 class="title">Loading Images</h2><div class="loading-counter" id="loading-counter">0</div><div class="loading-message" id="loading-message">Processing files...</div><div class="loading-progress"><div class="loading-progress-bar" id="loading-progress-bar"></div></div><button class="button" id="cancel-loading" style="background: rgba(239, 68, 68, 0.8); margin-top: 16px;">Cancel</button></div><div class="app-footer">orbital8-v12.17 - 2025-08-20 06:30 PM</div></div>
    
    <!-- Main App Container -->
    <div class="app-container hidden" id="app-container">
        <div class="nav-button back" id="back-button">← Folders</div>
        <div class="nav-button details" id="details-button">Details</div>
        <button class="nav-button" id="save-button">
            <span class="spinner" style="width: 14px; height: 14px; margin-right: 4px; display: none;"></span>
            Save
        </button>

        <div class="image-viewport" id="image-viewport"><img class="center-image zoomable" id="center-image" alt="Select a folder to start" /></div>
        <div class="edge-glow top" id="edge-top"></div><div class="edge-glow bottom" id="edge-bottom"></div><div class="edge-glow left" id="edge-left"></div><div class="edge-glow right" id="edge-right"></div>
        <div class="pill-counter top" id="pill-priority" data-stack="priority">0</div><div class="pill-counter bottom" id="pill-trash" data-stack="trash">0</div><div class="pill-counter left active" id="pill-in" data-stack="in">0</div><div class="pill-counter right" id="pill-out" data-stack="out">0</div>
        <div class="empty-state hidden" id="empty-state"><div class="empty-message">No more images in this stack</div><button class="new-images-button" id="select-another-stack-btn">Select Another Stack</button><button class="new-images-button" id="select-another-folder-btn" style="margin-top: 12px;">Choose Different Folder</button></div>
        <a id="filename-overlay" class="filename-overlay" href="#" target="_blank"></a>
        <!-- Focus & Normal Mode UI -->
        <div id="focus-stack-name" class="focus-mode-ui"></div>
        <div id="focus-image-count" class="focus-mode-ui"></div>
        <div id="normal-image-count"></div>
        <button id="focus-delete-btn" class="focus-mode-ui"><svg style="width: 20px; height: 20px;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
        <div id="toast" class="toast"></div>
        <div class="app-footer">orbital8-v12.17 - 2025-08-20 06:30 PM</div>
    </div>
    
    <!-- Modals -->
    <div id="grid-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-header-main"><div class="modal-header-left"><h2 id="grid-title" class="modal-title">Grid View</h2><button id="select-all-btn" class="select-all-btn">0</button></div><button id="close-grid" class="close-btn"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg></button></div>
                <div class="grid-row-2"><span class="selection-count"><span id="selection-text">0 selected</span><button id="deselect-all-btn" class="deselect-all-btn"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg></button></span><div class="zoom-control"><input type="range" id="grid-size" min="1" max="10" value="4"><span id="grid-size-value">4</span></div></div>
                <div class="grid-row-3"><input type="text" id="omni-search" class="input" placeholder="Search tags, notes, and metadata..." style="margin-bottom: 0;"><button id="clear-search-btn"><svg style="width: 16px; height: 16px;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div>
                <div class="grid-row-4"><div class="bulk-actions">
                    <button id="tag-selected" class="btn btn-primary">Tag</button>
                    <button id="move-selected" class="btn btn-primary">Move</button>
                    <button id="delete-selected" class="btn btn-primary">Delete</button>
                    <button id="export-selected" class="btn btn-primary">Export</button>
                    <button id="folder-selected" class="btn btn-primary">Folder</button>
                </div></div>
            </div>
            <div id="grid-content" class="grid-content"><div id="grid-container" class="grid-container"></div></div>
        </div>
    </div>
    <div id="action-modal" class="modal hidden">
        <div class="modal-content action-modal">
            <h3 id="action-title" class="title" style="font-size: 18px; color: #1f2937; margin-bottom: 16px;">Action</h3>
            <div id="action-content"></div>
            <div style="display: flex; justify-content: flex-end; gap: 8px; margin-top: 16px;">
                <button id="action-cancel" class="btn btn-secondary">Cancel</button>
                <button id="action-confirm" class="btn btn-primary">Confirm</button>
            </div>
        </div>
    </div>
    <div id="error-modal" class="modal hidden">
        <div class="modal-content action-modal">
            <h3 class="title" style="font-size: 18px; color: #dc2626; margin-bottom: 16px;">Operation Failed</h3>
            <p style="color: #4b5563; margin-bottom: 16px;">An error occurred. The details have been copied to your clipboard.</p>
            <textarea id="error-details" readonly style="width: 100%; min-height: 100px; font-family: monospace; font-size: 12px; resize: vertical; background: #f3f4f6; border: 1px solid #d1d5db; border-radius: 6px; padding: 8px;"></textarea>
            <div style="display: flex; justify-content: flex-end; gap: 8px; margin-top: 16px;">
                <button id="error-close" class="btn btn-primary">Close</button>
            </div>
        </div>
    </div>
    <div id="details-modal" class="modal hidden">
        <div class="modal-content details-modal-content">
            <div class="details-header"><h3 class="details-title">Image Details</h3><button id="details-close" class="close-btn"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg></button></div>
            <div class="tab-nav"><button class="tab-button active" data-tab="info">Info</button><button class="tab-button" data-tab="tags">Tags</button><button class="tab-button" data-tab="notes">Notes</button><button class="tab-button" data-tab="metadata">Metadata</button></div>
            <div class="details-content">
                <div id="tab-info" class="tab-content active"><div style="margin-bottom: 20px;"><div style="display: flex; align-items: center; margin-bottom: 12px; gap: 12px;"><span style="font-size: 14px; color: #6b7280; min-width: 80px; font-weight: 500;">Filename:</span><a id="detail-filename-link" style="font-size: 14px; color: #3b82f6; flex: 1; word-break: break-word; text-decoration: none;" href="#" target="_blank"><span id="detail-filename"></span></a></div><div style="display: flex; align-items: center; margin-bottom: 12px; gap: 12px;"><span style="font-size: 14px; color: #6b7280; min-width: 80px; font-weight: 500;">Date:</span><span id="detail-date" style="font-size: 14px; color: #374151; flex: 1; word-break: break-word;"></span></div><div style="display: flex; align-items: center; margin-bottom: 12px; gap: 12px;"><span style="font-size: 14px; color: #6b7280; min-width: 80px; font-weight: 500;">Size:</span><span id="detail-size" style="font-size: 14px; color: #374151; flex: 1; word-break: break-word;"></span></div></div></div>
                <div id="tab-tags" class="tab-content">
                    <div style="margin-bottom: 20px;">
                        <div class="tags-container" id="detail-tags"></div>
                    </div>
                    <div id="folder-tags-container" style="margin-top: 24px; padding-top: 16px; border-top: 1px solid #e5e7eb;">
                        <h4 style="font-size: 14px; font-weight: 500; color: #374151; margin: 0 0 12px 0;">Tags in this Folder</h4>
                        <div class="tags-container" id="folder-tags"></div>
                    </div>
                </div>
                <div id="tab-notes" class="tab-content"><div style="margin-bottom: 24px;"><label for="detail-notes" style="font-size: 14px; color: #6b7280; min-width: 80px; font-weight: 500;">Notes:</label><textarea id="detail-notes" class="notes-textarea" placeholder="Add your notes here..."></textarea></div><div style="margin-bottom: 20px;"><div style="font-size: 14px; font-weight: 500; color: #374151; margin-bottom: 8px;">Quality Rating:</div><div class="star-rating" id="quality-rating"><svg class="star" data-rating="1" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg><svg class="star" data-rating="2" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg><svg class="star" data-rating="3" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg><svg class="star" data-rating="4" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg><svg class="star" data-rating="5" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg></div></div><div style="margin-bottom: 20px;"><div style="font-size: 14px; font-weight: 500; color: #374151; margin-bottom: 8px;">Content Rating:</div><div class="star-rating" id="content-rating"><svg class="star" data-rating="1" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg><svg class="star" data-rating="2" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg><svg class="star" data-rating="3" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg><svg class="star" data-rating="4" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg><svg class="star" data-rating="5" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg></div></div></div>
                <div id="tab-metadata" class="tab-content"><table class="metadata-table" id="metadata-table"></table></div>
            </div>
        </div>
    </div>

    <script>
        // ===== ORBITAL8 v12.17 - Regression Fix Release =====
        /* * Version: v12.17
         * * See CSS block for detailed change log. Main changes include:
         * * - Fixed Grid Panel UI regressions.
         * * - Fixed Details Panel tag input color and added folder tag suggestions.
         * * - Corrected bulk move logic to ensure immediate grid updates.
        */
        
        // ===== Core Constants & State =====
        const STACK_TYPES = ['in', 'out', 'priority', 'trash'];
        const STACK_NAMES = { 'in': 'In', 'out': 'Out', 'priority': 'Priority', 'trash': 'Trash' };
        const ORDER_FILE_NAME = '.orbital8_order.json';
        
        const appState = {
            currentProvider: null,
            currentProviderType: null,
            localDB: null,
            syncManager: null,
            metadataExtractor: null,
            visualCueManager: null,
            hapticManager: null,
            exportSystem: null,
            currentFolder: { id: null, name: '', orderFileId: null, orderFileData: {} },
            imageFiles: [],
            currentImageLoadId: null, 
            currentStack: 'in',
            currentStackPosition: 0,
            isFocusMode: false,
            stacks: { in: [], out: [], priority: [], trash: [] },
            isDragging: false,
            isPinching: false,
            initialDistance: 0,
            currentScale: 1,
            maxScale: 4,
            minScale: 0.3,
            panOffset: { x: 0, y: 0 },
            grid: { 
                stack: null, 
                selected: [], 
            },
            tags: new Set(),
            loadingProgress: { current: 0, total: 0 },
        };

        // ===== Unified Utilities =====
        const utils = {
            elements: {},
            
            init() {
                const allElements = document.querySelectorAll('[id]');
                allElements.forEach(el => {
                    const camelCasedId = el.id.replace(/-([a-z])/g, g => g[1].toUpperCase());
                    this.elements[camelCasedId] = el;
                });
            },
            
            showScreen(screenId) {
                const screens = ['provider-screen', 'gdrive-auth-screen', 'onedrive-auth-screen', 
                               'gdrive-folder-screen', 'onedrive-folder-screen', 'loading-screen', 'app-container'];
                screens.forEach(id => document.getElementById(id).classList.toggle('hidden', id !== screenId));
            },
            
            showModal(id) { document.getElementById(id).classList.remove('hidden'); },
            hideModal(id) { document.getElementById(id).classList.add('hidden'); },
            
            showToast(message, type = 'success', important = false) {
                if (!important && Math.random() < 0.7) return;
                const toast = this.elements.toast;
                toast.textContent = message;
                toast.className = `toast ${type} show`;
                setTimeout(() => toast.classList.remove('show'), 3000);
                if (important && appState.hapticManager) {
                    appState.hapticManager.triggerFeedback(type === 'error' ? 'error' : 'buttonPress');
                }
            },

            showErrorModal(error) {
                const errorMessage = error.message || String(error);
                this.elements.errorDetails.value = errorMessage;
                this.copyToClipboard(errorMessage, false);
                this.showModal('error-modal');
            },
            
            async setImageSrc(img, file) {
                const loadId = file.id + '_' + Date.now();
                appState.currentImageLoadId = loadId;
                let imageUrl = this.generateImageUrl(file);
                return new Promise((resolve) => {
                    img.onload = () => { if (appState.currentImageLoadId === loadId) resolve(); };
                    img.onerror = () => { if (appState.currentImageLoadId !== loadId) return; img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="150" height="150" viewBox="0 0 150 150" fill="none"%3E%3Crect width="150" height="150" fill="%23E5E7EB"/%3E%3Cpath d="M65 60H85V90H65V60Z" fill="%239CA3AF"/%3E%3Ccircle cx="75" cy="45" r="10" fill="%239CA3AF"/%3E%3C/svg%3E'; resolve(); };
                    img.src = imageUrl;
                    img.alt = file.name || 'Image';
                });
            },
            
            generateImageUrl(file) {
                if (appState.currentProviderType === 'googledrive') {
                    return file.thumbnailLink ? file.thumbnailLink.replace('=s220', '=s1000') : `https://drive.google.com/thumbnail?id=${file.id}&sz=w1000`;
                } else {
                    return (file.thumbnails && file.thumbnails.large) ? file.thumbnails.large.url : file.downloadUrl;
                }
            },
            
            formatFileSize(bytes) {
                if (!bytes || bytes === 0) return '0 Bytes';
                const k = 1024;
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${['Bytes', 'KB', 'MB', 'GB'][i]}`;
            },
            
            updateLoadingProgress(current, total) {
                this.elements.loadingCounter.textContent = current;
                this.elements.loadingMessage.textContent = total ? `Processing ${current} of ${total} images...` : `Found ${current} images`;
                if (total > 0) this.elements.loadingProgressBar.style.width = `${(current / total) * 100}%`;
            },

            copyToClipboard(text, showToast = true) {
                navigator.clipboard.writeText(text).then(() => {
                    if (showToast) this.showToast('📋 Copied to clipboard', 'success', true);
                }).catch(() => {
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    textArea.style.position = 'fixed'; textArea.style.opacity = '0';
                    document.body.appendChild(textArea);
                    textArea.select();
                    try { document.execCommand('copy'); if (showToast) this.showToast('📋 Copied to clipboard', 'success', true); } 
                    catch (err) { if (showToast) this.showToast('❌ Failed to copy', 'error', true); }
                    document.body.removeChild(textArea);
                });
            }
        };

        // ===== Visual & Haptic Managers =====
        class VisualCueManager {
            constructor() { this.setIntensity(localStorage.getItem('orbital8_visual_intensity') || 'medium'); }
            setIntensity(level) {
                localStorage.setItem('orbital8_visual_intensity', level);
                const s = { low: { o: 0.3, d: 1000 }, medium: { o: 0.6, d: 1500 }, high: { o: 1.0, d: 2000 } };
                document.documentElement.style.setProperty('--glow-opacity', s[level].o);
                document.documentElement.style.setProperty('--ripple-duration', `${s[level].d}ms`);
                document.querySelectorAll('.intensity-btn').forEach(b => b.classList.toggle('active', b.dataset.level === level));
            }
        }
        class HapticFeedbackManager {
            constructor() { this.isEnabled = localStorage.getItem('orbital8_haptic_enabled') !== 'false'; this.isSupported = 'vibrate' in navigator; document.getElementById('haptic-enabled').checked = this.isEnabled; }
            setEnabled(enabled) { this.isEnabled = enabled; localStorage.setItem('orbital8_haptic_enabled', enabled); }
            triggerFeedback(type) { if (!this.isEnabled || !this.isSupported) return; const p = { swipe: [20, 40], pillTap: [35], buttonPress: [25], error: [100, 50, 100] }; if (p[type]) navigator.vibrate(p[type]); }
        }

        // ===== Local DB (IndexedDB Wrapper) =====
        class LocalDB {
            constructor() { this.db = null; }
            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('Orbital8DB', 4); // Version up for schema change
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => { this.db = request.result; resolve(); };
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('metadata')) db.createObjectStore('metadata', { keyPath: 'id' });
                        if (!db.objectStoreNames.contains('userMetadata')) db.createObjectStore('userMetadata', { keyPath: 'id' });
                        if (!db.objectStoreNames.contains('dirtyFiles')) db.createObjectStore('dirtyFiles', { keyPath: 'id' });
                    };
                });
            }

            async _get(storeName, key) { if (!this.db) return null; return new Promise((resolve, reject) => { const req = this.db.transaction(storeName, 'readonly').objectStore(storeName).get(key); req.onsuccess = () => resolve(req.result); req.onerror = () => reject(req.error); }); }
            async _getAll(storeName) { if (!this.db) return []; return new Promise((resolve, reject) => { const req = this.db.transaction(storeName, 'readonly').objectStore(storeName).getAll(); req.onsuccess = () => resolve(req.result); req.onerror = () => reject(req.error); }); }
            async _put(storeName, data) { if (!this.db) return; return new Promise((resolve, reject) => { const req = this.db.transaction(storeName, 'readwrite').objectStore(storeName).put(data); req.onsuccess = () => resolve(); req.onerror = () => reject(req.error); }); }
            async _clear(storeName) { if (!this.db) return; return new Promise((resolve, reject) => { const req = this.db.transaction(storeName, 'readwrite').objectStore(storeName).clear(); req.onsuccess = () => resolve(); req.onerror = () => reject(req.error); }); }

            async getMetadata(id) { const res = await this._get('metadata', id); return res ? res.data : null; }
            async setMetadata(id, data) { await this._put('metadata', { id, data }); }
            
            async getUserMetadata(id) { const res = await this._get('userMetadata', id); return res ? res.data : null; }
            async setUserMetadata(id, data) { await this._put('userMetadata', { id, data }); }
            async clearUserMetadata() { await this._clear('userMetadata'); }

            async logChange(id) { await this._put('dirtyFiles', { id }); }
            async getChanges() { return await this._getAll('dirtyFiles'); }
            async clearChanges() { await this._clear('dirtyFiles'); }
        }

        // ===== Progressive Metadata Extractor =====
        class ProgressiveMetadataExtractor {
            constructor() { this.abortController = null; }
            abort() { if (this.abortController) this.abortController.abort(); }
            async extract(buffer) { if (!buffer || buffer.byteLength < 8) return {}; const metadata = {}; const view = new DataView(buffer); let pos = 8; try { while (pos < buffer.byteLength - 12) { const len = view.getUint32(pos, false); pos += 4; let type = ''; for (let i = 0; i < 4; i++) type += String.fromCharCode(view.getUint8(pos + i)); pos += 4; if (type === 'tEXt') { let keyword = '', value = '', nullFound = false; for (let i = 0; i < len; i++) { const byte = view.getUint8(pos + i); if (!nullFound) { if (byte === 0) nullFound = true; else keyword += String.fromCharCode(byte); } else value += String.fromCharCode(byte); } metadata[keyword] = value; } else if (type === 'IHDR') { metadata._dimensions = { width: view.getUint32(pos, false), height: view.getUint32(pos + 4, false) }; } else if (type === 'IEND') break; pos += len + 4; if (len > buffer.byteLength || pos > buffer.byteLength) break; } } catch (e) { /* Return partial data */ } return metadata; }
            async fetchMetadata(file, isForExport = false) { if (file.mimeType !== 'image/png') { if (!isForExport) file.metadataStatus = 'loaded'; return { error: 'Not a PNG file' }; } try { this.abortController = new AbortController(); let response; if (appState.currentProviderType === 'googledrive') { response = await appState.currentProvider.makeApiCall(`/files/${file.id}?alt=media`, { headers: { 'Range': 'bytes=0-65535' }, signal: this.abortController.signal }, false); } else { const accessToken = await appState.currentProvider.getAccessToken(); response = await fetch(`https://graph.microsoft.com/v1.0/me/drive/items/${file.id}/content`, { headers: { 'Authorization': `Bearer ${accessToken}`, 'Range': 'bytes=0-65535' }, signal: this.abortController.signal }); } if (!response.ok) throw new Error(`HTTP ${response.status}`); const buffer = await response.arrayBuffer(); return await this.extract(buffer); } catch (error) { return { error: error.name === 'AbortError' ? 'Operation cancelled' : error.message }; } }
        }

        // ===== Cloud Providers (No change from v12.15) =====
        class GoogleDriveProvider {
            constructor() { this.name = 'googledrive'; this.clientId = '567988062464-fa6c1ovesqeudqs5398vv4mbo6q068p9.apps.googleusercontent.com'; this.redirectUri = window.location.origin + window.location.pathname; this.scope = 'https://www.googleapis.com/auth/drive'; this.apiBase = 'https://www.googleapis.com/drive/v3'; this.loadStoredCredentials(); }
            loadStoredCredentials() { this.accessToken = localStorage.getItem('google_access_token'); this.refreshToken = localStorage.getItem('google_refresh_token'); this.clientSecret = localStorage.getItem('google_client_secret'); this.isAuthenticated = !!(this.accessToken && this.refreshToken && this.clientSecret); }
            storeCredentials() { if (this.accessToken) localStorage.setItem('google_access_token', this.accessToken); if (this.refreshToken) localStorage.setItem('google_refresh_token', this.refreshToken); if (this.clientSecret) localStorage.setItem('google_client_secret', this.clientSecret); }
            clearStoredCredentials() { localStorage.removeItem('google_access_token'); localStorage.removeItem('google_refresh_token'); localStorage.removeItem('google_client_secret'); }
            async authenticate(clientSecret) { if (clientSecret) { this.clientSecret = clientSecret; this.storeCredentials(); } if (!this.clientSecret) throw new Error('Client secret is required'); if (this.accessToken && this.refreshToken) { try { await this.makeApiCall('/files?pageSize=1'); this.isAuthenticated = true; return true; } catch (e) { /* Token invalid, re-auth */ } } return new Promise((resolve, reject) => { const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?${new URLSearchParams({ client_id: this.clientId, redirect_uri: this.redirectUri, response_type: 'code', scope: this.scope, access_type: 'offline', prompt: 'consent' })}`; const popup = window.open(authUrl, 'google-auth', 'width=500,height=600'); if (!popup) return reject(new Error('Popup blocked')); const checkClosed = setInterval(() => { if (popup.closed) { clearInterval(checkClosed); reject(new Error('Authentication cancelled')); } }, 1000); const messageHandler = async (event) => { if (event.origin !== window.location.origin) return; if (event.data.type === 'GOOGLE_AUTH_SUCCESS') { clearInterval(checkClosed); window.removeEventListener('message', messageHandler); popup.close(); try { await this.exchangeCodeForTokens(event.data.code); this.isAuthenticated = true; resolve(true); } catch (error) { reject(error); } } else if (event.data.type === 'GOOGLE_AUTH_ERROR') { clearInterval(checkClosed); window.removeEventListener('message', messageHandler); popup.close(); reject(new Error(event.data.error)); } }; window.addEventListener('message', messageHandler); }); }
            async exchangeCodeForTokens(code) { const res = await fetch('https://oauth2.googleapis.com/token', { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: new URLSearchParams({ client_id: this.clientId, client_secret: this.clientSecret, code: code, grant_type: 'authorization_code', redirect_uri: this.redirectUri }) }); if (!res.ok) throw new Error('Token exchange failed'); const tokens = await res.json(); this.accessToken = tokens.access_token; this.refreshToken = tokens.refresh_token; this.storeCredentials(); }
            async refreshAccessToken() { if (!this.refreshToken || !this.clientSecret) throw new Error('No refresh token or client secret'); const res = await fetch('https://oauth2.googleapis.com/token', { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: new URLSearchParams({ client_id: this.clientId, client_secret: this.clientSecret, refresh_token: this.refreshToken, grant_type: 'refresh_token' }) }); if (!res.ok) throw new Error('Failed to refresh access token'); const tokens = await res.json(); this.accessToken = tokens.access_token; this.storeCredentials(); return this.accessToken; }
            async makeApiCall(endpoint, options = {}, isJson = true) { if (!this.accessToken) throw new Error('Not authenticated'); const url = endpoint.startsWith('https://') ? endpoint : `${this.apiBase}${endpoint}`; const headers = { 'Authorization': `Bearer ${this.accessToken}`, ...options.headers }; if (isJson && !options.body) headers['Content-Type'] = 'application/json'; let res = await fetch(url, { ...options, headers }); if (res.status === 401 && this.refreshToken && this.clientSecret) { try { await this.refreshAccessToken(); headers['Authorization'] = `Bearer ${this.accessToken}`; res = await fetch(url, { ...options, headers }); } catch (refreshError) { this.isAuthenticated = false; this.clearStoredCredentials(); throw new Error('Authentication expired. Please reconnect.'); } } if (!res.ok) { const errorText = await res.text(); throw new Error(`API call failed: ${res.status} - ${errorText}`); } return isJson ? await res.json() : res; }
            async getFolders() { const res = await this.makeApiCall('/files?q=mimeType%3D%27application/vnd.google-apps.folder%27 and trashed=false&fields=files(id,name,createdTime,modifiedTime)&orderBy=modifiedTime%20desc'); return res.files.map(f => ({ id: f.id, name: f.name, type: 'folder', createdTime: f.createdTime, modifiedTime: f.modifiedTime })); }
            async getFiles(folderId = 'root') { const allFiles = []; let pageToken = null; do { const query = `'${folderId}' in parents and trashed=false`; let url = `/files?q=${encodeURIComponent(query)}&fields=files(id,name,mimeType,size,createdTime,modifiedTime,thumbnailLink,webContentLink,parents),nextPageToken&pageSize=100`; if (pageToken) url += `&pageToken=${pageToken}`; const res = await this.makeApiCall(url); const files = res.files.map(f => ({ id: f.id, name: f.name, type: f.mimeType === 'application/json' ? 'json' : 'file', mimeType: f.mimeType, size: f.size ? parseInt(f.size) : 0, createdTime: f.createdTime, modifiedTime: f.modifiedTime, thumbnailLink: f.thumbnailLink, downloadUrl: f.webContentLink, parents: f.parents })); allFiles.push(...files); pageToken = res.nextPageToken; if (this.onProgressCallback) this.onProgressCallback(allFiles.length); } while (pageToken); return { folders: [], files: allFiles }; }
            async deleteFile(fileId) { await this.makeApiCall(`/files/${fileId}`, { method: 'PATCH', body: JSON.stringify({ trashed: true }) }); return true; }
            async disconnect() { this.isAuthenticated = false; this.accessToken = null; this.refreshToken = null; this.clientSecret = null; this.clearStoredCredentials(); }
            async updateFileContent(fileId, content) { const metadata = { mimeType: 'application/json' }; const form = new FormData(); form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' })); form.append('file', new Blob([content], { type: 'application/json' })); return await this.makeApiCall(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=multipart`, { method: 'PATCH', body: form }, false); }
            async createFile(folderId, fileName, content) { const metadata = { name: fileName, parents: [folderId], mimeType: 'application/json' }; const form = new FormData(); form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' })); form.append('file', new Blob([content], { type: 'application/json' })); return await this.makeApiCall('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', { method: 'POST', body: form }, true); }
        }
        class OneDriveProvider {
            constructor() { this.name = 'onedrive'; this.apiBase = 'https://graph.microsoft.com/v1.0'; this.currentParentId = null; this.currentParentPath = ''; this.breadcrumb = []; this.initMSAL(); }
            initMSAL() { const msalConfig = { auth: { clientId: 'b407fd45-c551-4dbb-9da5-cab3a2c5a949', authority: 'https://login.microsoftonline.com/common', redirectUri: window.location.origin + window.location.pathname }, cache: { cacheLocation: 'localStorage' } }; this.msalInstance = new msal.PublicClientApplication(msalConfig); }
            async authenticate() { try { const accounts = this.msalInstance.getAllAccounts(); if (accounts.length > 0) { this.msalInstance.setActiveAccount(accounts[0]); this.activeAccount = accounts[0]; } else { const loginResponse = await this.msalInstance.loginPopup({ scopes: ['Files.ReadWrite', 'User.Read'] }); this.activeAccount = loginResponse.account; this.msalInstance.setActiveAccount(this.activeAccount); } this.isAuthenticated = true; return true; } catch (error) { this.isAuthenticated = false; throw new Error(`Authentication failed: ${error.message}`); } }
            async getAccessToken() { if (!this.activeAccount) throw new Error('No active account'); try { const res = await this.msalInstance.acquireTokenSilent({ scopes: ['Files.ReadWrite'], account: this.activeAccount }); return res.accessToken; } catch (silentError) { if (silentError instanceof msal.InteractionRequiredAuthError) { const res = await this.msalInstance.acquireTokenPopup({ scopes: ['Files.ReadWrite'], account: this.activeAccount }); return res.accessToken; } throw silentError; } }
            async makeApiCall(endpoint, options = {}, isJson = true) { const accessToken = await this.getAccessToken(); const url = endpoint.startsWith('https://') ? endpoint : `${this.apiBase}${endpoint}`; const headers = { 'Authorization': `Bearer ${accessToken}`, ...options.headers }; if (isJson && !options.body) headers['Content-Type'] = 'application/json'; const res = await fetch(url, { ...options, headers }); if (!res.ok) { const errorText = await res.text(); throw new Error(`API call failed: ${res.status} - ${errorText}`); } return isJson ? await res.json() : res; }
            async getDownloadsFolder() { try { const res = await this.makeApiCall('/me/drive/special/downloads'); return res; } catch (e) { return { id: 'root', name: 'Root', folder: {} }; } }
            async getFolders() { const downloads = await this.getDownloadsFolder(); this.currentParentId = downloads.id; this.currentParentPath = downloads.name; this.breadcrumb = [{ id: downloads.id, name: downloads.name }]; return await this.loadFoldersInParent(downloads.id); }
            async loadFoldersInParent(parentId) { const endpoint = parentId === 'root' ? '/me/drive/root/children' : `/me/drive/items/${parentId}/children`; const res = await this.makeApiCall(`${endpoint}?$filter=folder ne null&$orderby=name`); return res.value.map(f => ({ id: f.id, name: f.name, type: 'folder', createdTime: f.createdDateTime, modifiedTime: f.lastModifiedDateTime, itemCount: f.folder.childCount || 0, hasChildren: (f.folder.childCount || 0) > 0 })); }
            async drillIntoFolder(folder) { this.breadcrumb.push({ id: folder.id, name: folder.name }); this.currentParentId = folder.id; this.currentParentPath = this.breadcrumb.map(b => b.name).join(' / '); return await this.loadFoldersInParent(folder.id); }
            async navigateToParent() { if (this.breadcrumb.length <= 1) return await this.getFolders(); this.breadcrumb.pop(); const parent = this.breadcrumb[this.breadcrumb.length - 1]; this.currentParentId = parent.id; this.currentParentPath = this.breadcrumb.map(b => b.name).join(' / '); return await this.loadFoldersInParent(parent.id); }
            getCurrentPath() { return this.currentParentPath; }
            canGoUp() { return this.breadcrumb.length > 1; }
            async getFiles(folderId = 'root') { const allFiles = []; let nextLink = `/me/drive/items/${folderId}/children`; do { const res = await this.makeApiCall(nextLink.replace(this.apiBase, '')); const files = res.value.map(item => ({ id: item.id, name: item.name, type: (item.file && item.file.mimeType === 'application/json') ? 'json' : 'file', mimeType: item.file ? item.file.mimeType : null, size: item.size || 0, createdTime: item.createdDateTime, modifiedTime: item.lastModifiedDateTime, thumbnails: item.thumbnails && item.thumbnails.length > 0 ? { large: item.thumbnails[0].large } : null, downloadUrl: item['@microsoft.graph.downloadUrl'] })); allFiles.push(...files); nextLink = res['@odata.nextLink']; if (this.onProgressCallback) this.onProgressCallback(allFiles.length); } while (nextLink); return { folders: [], files: allFiles }; }
            async deleteFile(fileId) { await this.makeApiCall(`/me/drive/items/${fileId}`, { method: 'DELETE' }); return true; }
            async disconnect() { this.isAuthenticated = false; this.activeAccount = null; if (this.msalInstance) { const accounts = this.msalInstance.getAllAccounts(); if (accounts.length > 0) await this.msalInstance.logoutPopup({ account: accounts[0] }); } }
            async updateFileContent(fileId, content) { return await this.makeApiCall(`/me/drive/items/${fileId}/content`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: content }, true); }
            async createFile(folderId, fileName, content) { return await this.makeApiCall(`/me/drive/items/${folderId}:/${fileName}:/content`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: content }, true); }
        }

        // ===== Export System =====
        class ExportSystem {
            async exportData(imagesWithMetadata) { if (imagesWithMetadata.length === 0) { utils.showToast('No images to export', 'info', true); return; } this.downloadCSV(this.formatForCSV(imagesWithMetadata)); }
            formatForCSV(images) { const headers = ['Filename', 'Direct Image URL', 'Prompt', 'Negative Prompt', 'Model', 'Width', 'Height', 'Steps', 'Seed', 'CFG Scale', 'Size', 'Created Date', 'Modified Date', 'Tags', 'Notes', 'Quality Rating', 'Content Rating', 'Provider', 'Metadata (JSON)']; const rows = images.map(img => { const meta = img.extractedMetadata || {}; const dims = meta._dimensions || {}; return [img.name || '', this.getDirectImageURL(img), this.extractMetadataValue(meta, ['prompt', 'Prompt', 'parameters']), this.extractMetadataValue(meta, ['negative_prompt', 'Negative Prompt']), this.extractMetadataValue(meta, ['model', 'Model']), dims.width || '', dims.height || '', this.extractMetadataValue(meta, ['steps', 'Steps']), this.extractMetadataValue(meta, ['seed', 'Seed']), this.extractMetadataValue(meta, ['cfg_scale', 'CFG Scale']), utils.formatFileSize(img.size), new Date(img.createdTime).toISOString(), new Date(img.modifiedTime).toISOString(), (img.tags || []).join('; '), img.notes || '', img.qualityRating || 0, img.contentRating || 0, appState.currentProviderType, JSON.stringify(meta)]; }); return [headers, ...rows]; }
            extractMetadataValue(metadata, keys) { for (const key of keys) { if (metadata[key]) { if (key === 'parameters') { const promptMatch = metadata[key].match(/^(.*?)(Negative prompt:|$)/); if (promptMatch && promptMatch[1]) return promptMatch[1].trim(); } return metadata[key]; } } return ''; }
            getDirectImageURL(image) { if (appState.currentProviderType === 'googledrive') return `https://drive.google.com/uc?id=${image.id}&export=view`; if (appState.currentProviderType === 'onedrive') return image.downloadUrl || `https://graph.microsoft.com/v1.0/me/drive/items/${image.id}/content`; return ''; }
            downloadCSV(data) { const folderName = appState.currentFolder.name.replace(/[^a-z0-9]/gi, '_').toLowerCase(); const stackName = appState.grid.stack; const date = new Date().toISOString().split('T')[0]; const filename = `orbital8_${folderName}_${stackName}_${date}.csv`; const csvContent = data.map(row => row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(',')).join('\n'); const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); }
        }

        // ===== Sync Manager (NEW) =====
        class SyncManager {
            constructor() {
                this.syncTimer = null;
                this.isSyncing = false;
                this.debounceTime = 3000; // 3 seconds
            }

            requestSync() {
                clearTimeout(this.syncTimer);
                this.updateSaveButton('dirty');
                this.syncTimer = setTimeout(() => this._sync(), this.debounceTime);
            }

            async forceSync() {
                clearTimeout(this.syncTimer);
                await this._sync();
            }

            updateSaveButton(state) { // states: 'idle', 'dirty', 'saving', 'error'
                const btn = utils.elements.saveButton;
                const spinner = btn.querySelector('.spinner');
                const text = btn.lastChild;

                btn.classList.remove('saving');
                spinner.style.display = 'none';

                switch(state) {
                    case 'dirty':
                        text.textContent = 'Save';
                        btn.style.borderColor = 'var(--app-accent)';
                        break;
                    case 'saving':
                        btn.classList.add('saving');
                        text.textContent = 'Saving...';
                        spinner.style.display = 'inline-block';
                        btn.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                        break;
                    case 'error':
                        text.textContent = 'Error';
                        btn.style.borderColor = '#ef4444';
                        break;
                    case 'idle':
                    default:
                        text.textContent = 'Saved';
                        btn.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                        break;
                }
            }

            async _sync() {
                if (this.isSyncing) return;

                const changedFileRecords = await appState.localDB.getChanges();
                if (changedFileRecords.length === 0) {
                    this.updateSaveButton('idle');
                    return;
                }

                this.isSyncing = true;
                this.updateSaveButton('saving');

                try {
                    const changedFileIds = new Set(changedFileRecords.map(r => r.id));
                    const updatedOrderFileData = JSON.parse(JSON.stringify(appState.currentFolder.orderFileData)); // Deep copy
                    if (!updatedOrderFileData.files) updatedOrderFileData.files = {};

                    for (const id of changedFileIds) {
                        const localData = await appState.localDB.getUserMetadata(id);
                        if (localData) {
                            updatedOrderFileData.files[id] = localData;
                        }
                    }

                    const content = JSON.stringify(updatedOrderFileData, null, 2);

                    if (appState.currentFolder.orderFileId) {
                        await appState.currentProvider.updateFileContent(appState.currentFolder.orderFileId, content);
                    } else {
                        const newFile = await appState.currentProvider.createFile(appState.currentFolder.id, ORDER_FILE_NAME, content);
                        appState.currentFolder.orderFileId = newFile.id;
                    }

                    appState.currentFolder.orderFileData = updatedOrderFileData;
                    await appState.localDB.clearChanges();
                    this.updateSaveButton('idle');
                    utils.showToast('Changes saved to cloud', 'success');

                } catch (error) {
                    utils.showErrorModal(error);
                    this.updateSaveButton('error');
                } finally {
                    this.isSyncing = false;
                }
            }
        }

        // Handle OAuth callback for Google Drive
        if (window.location.search.includes('code=') || window.location.search.includes('error=')) {
            const urlParams = new URLSearchParams(window.location.search);
            if (window.opener) {
                if (urlParams.get('error')) { window.opener.postMessage({ type: 'GOOGLE_AUTH_ERROR', error: urlParams.get('error') }, window.location.origin); }
                else if (urlParams.get('code')) { window.opener.postMessage({ type: 'GOOGLE_AUTH_SUCCESS', code: urlParams.get('code') }, window.location.origin); }
                window.close();
            }
        }

        // ===== App Controller =====
        const appController = {
            selectGoogleDrive() { appState.currentProviderType = 'googledrive'; utils.showScreen('gdrive-auth-screen'); const provider = new GoogleDriveProvider(); if (provider.isAuthenticated) { appState.currentProvider = provider; utils.showScreen('gdrive-folder-screen'); loadGoogleDriveFolders(); } },
            async selectOneDrive() { appState.currentProviderType = 'onedrive'; utils.showScreen('onedrive-auth-screen'); const provider = new OneDriveProvider(); try { const success = await provider.authenticate(); if (success) { appState.currentProvider = provider; utils.showScreen('onedrive-folder-screen'); loadOneDriveFolders(); } } catch (e) { utils.elements.onedriveAuthStatus.textContent = 'Click to sign in with your Microsoft account'; } },
            backToProviderSelection() { appState.currentProvider = null; appState.currentProviderType = null; utils.showScreen('provider-screen'); }
        };

        // ===== Master Controller =====
        const masterController = {
            async initializeWithProvider(providerType, folderId, folderName, providerInstance) {
                appState.currentProviderType = providerType;
                appState.currentProvider = providerInstance;
                appState.currentFolder = { id: folderId, name: folderName, orderFileId: null, orderFileData: {} };
                await this.loadImages();
                this.switchToCommonUI();
            },
            
            async loadImages() {
                utils.showScreen('loading-screen');
                utils.updateLoadingProgress(0, 0);
                await appState.localDB.clearUserMetadata();
                await appState.localDB.clearChanges();
                appState.currentProvider.onProgressCallback = (count) => utils.updateLoadingProgress(count, 0);
                try {
                    const result = await appState.currentProvider.getFiles(appState.currentFolder.id);
                    const allItems = result.files || [];
                    const orderFile = allItems.find(f => f.name === ORDER_FILE_NAME);
                    
                    if (orderFile) {
                        appState.currentFolder.orderFileId = orderFile.id;
                        try {
                            const response = await appState.currentProvider.makeApiCall(appState.currentProviderType === 'googledrive' ? `/files/${orderFile.id}?alt=media` : `/me/drive/items/${orderFile.id}/content`, {}, false);
                            appState.currentFolder.orderFileData = await response.json();
                        } catch (e) { utils.showToast('Could not load order file.', 'error', true); }
                    }
                    const imageFiles = allItems.filter(f => f.mimeType && f.mimeType.startsWith('image/'));
                    if (imageFiles.length === 0) { utils.showToast('No images found in this folder', 'info', true); this.returnToFolderSelection(); return; }
                    utils.updateLoadingProgress(imageFiles.length, imageFiles.length);
                    appState.imageFiles = imageFiles.map(file => this.processFileWithMetadata(file, appState.currentFolder.orderFileData));
                    
                    for (const file of appState.imageFiles) {
                        await appState.localDB.setUserMetadata(file.id, { stack: file.stack, tags: file.tags, qualityRating: file.qualityRating, contentRating: file.contentRating, notes: file.notes, stackSequence: file.stackSequence });
                    }

                    if (imageFiles.some(f => f.mimeType === 'image/png')) this.extractMetadataInBackground(appState.imageFiles.filter(f => f.mimeType === 'image/png'));
                    commonFunctions.initializeStacks();
                    commonFunctions.initializeImageDisplay();
                } catch (error) { utils.showToast(`Error loading images: ${error.message}`, 'error', true); this.returnToFolderSelection(); } 
                finally { if (appState.currentProvider) appState.currentProvider.onProgressCallback = null; }
            },
            
            processFileWithMetadata(file, orderData) {
                const userMetadata = (orderData.files && orderData.files[file.id]) || {};
                return { id: file.id, name: file.name, mimeType: file.mimeType, size: file.size, createdTime: file.createdTime, modifiedTime: file.modifiedTime, thumbnails: file.thumbnails, downloadUrl: file.downloadUrl, extractedMetadata: {}, metadataStatus: 'pending', stack: userMetadata.stack || 'in', tags: userMetadata.tags || [], qualityRating: userMetadata.qualityRating || 0, contentRating: userMetadata.contentRating || 0, notes: userMetadata.notes || '', stackSequence: userMetadata.stackSequence || 0 };
            },
            
            switchToCommonUI() { utils.showScreen('app-container'); this.setupProviderAwareNavigation(); },
            setupProviderAwareNavigation() { utils.elements.backButton.onclick = async () => { await appState.syncManager.forceSync(); this.returnToFolderSelection(); }; this.setupFolderTooltips(); },
            setupFolderTooltips() { utils.elements.backButton.addEventListener('mouseenter', () => { const folderName = appState.currentFolder.name || 'Unknown'; const imageCount = appState.imageFiles.length; const provider = appState.currentProviderType === 'googledrive' ? 'Google Drive' : 'OneDrive'; this.showTooltip(utils.elements.backButton, `${provider}: ${folderName} • ${imageCount} images`); }); utils.elements.backButton.addEventListener('mouseleave', this.hideTooltip); },
            showTooltip(element, text) { this.hideTooltip(); const tooltip = document.createElement('div'); tooltip.className = 'folder-tooltip'; tooltip.textContent = text; document.body.appendChild(tooltip); const rect = element.getBoundingClientRect(); tooltip.style.left = `${rect.left}px`; tooltip.style.top = `${rect.bottom + 8}px`; const tooltipRect = tooltip.getBoundingClientRect(); if (tooltipRect.right > window.innerWidth) tooltip.style.left = `${window.innerWidth - tooltipRect.width - 10}px`; },
            hideTooltip() { const tooltip = document.querySelector('.folder-tooltip'); if (tooltip) tooltip.remove(); },
            returnToFolderSelection() { if (appState.currentProviderType === 'googledrive') utils.showScreen('gdrive-folder-screen'); else if (appState.currentProviderType === 'onedrive') utils.showScreen('onedrive-folder-screen'); },
            async updateUserMetadata(fileId, updates) { 
                const file = appState.imageFiles.find(f => f.id === fileId); 
                if (file) {
                    Object.assign(file, updates);
                    await appState.localDB.setUserMetadata(file.id, { stack: file.stack, tags: file.tags, qualityRating: file.qualityRating, contentRating: file.contentRating, notes: file.notes, stackSequence: file.stackSequence });
                    await appState.localDB.logChange(file.id);
                    appState.syncManager.requestSync();
                }
            },
            async deleteFile(fileId) { return await appState.currentProvider.deleteFile(fileId); },
            async extractMetadataInBackground(pngFiles) { for (let i = 0; i < pngFiles.length; i += 5) { await Promise.allSettled(pngFiles.slice(i, i + 5).map(file => this.processFileMetadata(file))); if (i + 5 < pngFiles.length) await new Promise(resolve => setTimeout(resolve, 100)); } },
            async processFileMetadata(file) { if (file.metadataStatus !== 'pending') return; file.metadataStatus = 'loading'; const cachedMetadata = await appState.localDB.getMetadata(file.id); if (cachedMetadata) { file.extractedMetadata = cachedMetadata; file.metadataStatus = 'loaded'; return; } try { const metadata = await appState.metadataExtractor.fetchMetadata(file); if (metadata.error) throw new Error(metadata.error); if (Object.keys(metadata).length > 0) { file.extractedMetadata = metadata; await appState.localDB.setMetadata(file.id, metadata); } file.metadataStatus = 'loaded'; } catch (error) { console.warn(`Metadata extraction failed for ${file.name}: ${error.message}`); file.metadataStatus = 'error'; } }
        };

        // ===== Common Functions =====
        const commonFunctions = {
            initializeStacks() {
                STACK_TYPES.forEach(stack => { appState.stacks[stack] = []; });
                appState.imageFiles.forEach(file => {
                    const stack = STACK_TYPES.includes(file.stack) ? file.stack : 'in';
                    appState.stacks[stack].push(file);
                });
                STACK_TYPES.forEach(stack => { appState.stacks[stack] = this.sortFiles(appState.stacks[stack]); });
                this.updateStackCounts();
            },
            
            sortFiles(files) { return [...files].sort((a, b) => (b.stackSequence || 0) - (a.stackSequence || 0) || (a.name || '').localeCompare(b.name || '')); },
            updateStackCounts() { STACK_TYPES.forEach(stack => { const count = appState.stacks[stack].length; const pill = document.getElementById(`pill-${stack}`); if (pill) { pill.textContent = count > 999 ? '∞' : count; pill.classList.toggle('visible', count > 0); } }); },
            
            initializeImageDisplay() {
                appState.currentStackPosition = 0;
                appState.currentStack = 'in';
                this.displayTopImageFromStack('in');
                this.updateActiveProxTab();
                this.updateStackCounts();
            },
            
            async displayTopImageFromStack(stackName) {
                const stack = appState.stacks[stackName];
                if (stack.length === 0) { this.showEmptyState(); return; }
                utils.elements.emptyState.classList.add('hidden');
                appState.currentStack = stackName;
                appState.currentStackPosition = 0;
                await this.displayCurrentImage();
                this.updateActiveProxTab();
            },
            
            async displayCurrentImage() {
                const stack = appState.stacks[appState.currentStack];
                if (!stack || stack.length === 0) { this.showEmptyState(); return; }
                if (appState.currentStackPosition >= stack.length) appState.currentStackPosition = stack.length - 1;
                if (appState.currentStackPosition < 0) appState.currentStackPosition = 0;

                const currentFile = stack[appState.currentStackPosition];
                if (!currentFile) { this.showEmptyState(); return; }

                utils.elements.detailsButton.style.display = 'flex';
                await utils.setImageSrc(utils.elements.centerImage, currentFile);
                
                const folderName = appState.currentFolder.name;
                const truncatedFolder = folderName.length > 12 ? folderName.substring(0, 12) + '...' : folderName;
                utils.elements.filenameOverlay.textContent = `${truncatedFolder} / ${currentFile.name.replace(/\.[^/.]+$/, "")}`;
                utils.elements.filenameOverlay.href = appState.exportSystem.getDirectImageURL(currentFile);
                utils.elements.filenameOverlay.classList.add('visible');

                appState.currentScale = 1; appState.panOffset = { x: 0, y: 0 }; this.applyTransform();
                if (currentFile.metadataStatus === 'pending') masterController.processFileMetadata(currentFile);
                this.updateImageCounters();
            },

            updateImageCounters() {
                const stack = appState.stacks[appState.currentStack];
                const total = stack.length;
                const current = total > 0 ? appState.currentStackPosition + 1 : 0;
                const text = `${current} / ${total}`;
                utils.elements.focusImageCount.textContent = text;
                utils.elements.normalImageCount.textContent = text;
                utils.elements.focusStackName.textContent = STACK_NAMES[appState.currentStack];
            },
            
            applyTransform() { utils.elements.centerImage.style.transform = `scale(${appState.currentScale}) translate(${appState.panOffset.x}px, ${appState.panOffset.y}px)`; },
            updateActiveProxTab() { STACK_TYPES.forEach(s => document.getElementById(`pill-${s}`).classList.remove('active')); document.getElementById(`pill-${appState.currentStack}`).classList.add('active'); },
            
            async moveToStack(targetStack) {
                const stack = appState.stacks[appState.currentStack];
                if (!stack || stack.length === 0) return;
                const image = stack[appState.currentStackPosition];
                if (!image) return;

                const originalStack = appState.currentStack;
                const newSequence = Date.now();
                
                if (targetStack === originalStack) {
                    stack.splice(appState.currentStackPosition, 1);
                    stack.push(image);
                } else {
                    stack.splice(appState.currentStackPosition, 1);
                    appState.stacks[targetStack].unshift(image);
                    appState.stacks[targetStack] = this.sortFiles(appState.stacks[targetStack]);
                }
                
                await masterController.updateUserMetadata(image.id, { stack: targetStack, stackSequence: newSequence });
                
                this.updateStackCounts();
                this.updateActiveProxTab();
                await this.displayCurrentImage();
            },
            
            showEmptyState() {
                appState.currentImageLoadId = null;
                utils.elements.centerImage.style.opacity = '0';
                utils.elements.filenameOverlay.classList.remove('visible');
                utils.elements.detailsButton.style.display = 'none';
                this.updateImageCounters();
                setTimeout(() => {
                    utils.elements.centerImage.src = '';
                    utils.elements.centerImage.alt = 'No images in this stack';
                    utils.elements.emptyState.classList.remove('hidden');
                    utils.elements.centerImage.style.opacity = '1';
                    updateEmptyStateButtons();
                }, 200);
            }
        };

        // ===== Grid View =====
        const gridView = {
            open(stack) {
                utils.showModal('grid-modal');
                utils.elements.gridTitle.textContent = STACK_NAMES[stack] || stack;
                appState.grid.stack = stack;
                
                const value = utils.elements.gridSize.value;
                utils.elements.gridContainer.style.gridTemplateColumns = `repeat(${value}, 1fr)`;
                
                appState.grid.selected = [];
                utils.elements.gridContainer.innerHTML = '';
                
                this.renderGridFromState();
                this.updateSelectionUI();

                const currentFile = appState.stacks[appState.currentStack][appState.currentStackPosition];
                if (currentFile && appState.currentStack === stack) {
                    const item = utils.elements.gridContainer.querySelector(`[data-file-id="${currentFile.id}"]`);
                    if (item) {
                        item.classList.add('selected');
                        appState.grid.selected.push(currentFile.id);
                        this.updateSelectionUI();
                        item.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            },
            
            async close() {
                utils.hideModal('grid-modal');
                this.resetSearch();
                commonFunctions.displayCurrentImage();
                appState.grid.stack = null;
                appState.grid.selected = [];
            },

            renderGridFromState(filteredFiles = null) {
                const files = filteredFiles || appState.stacks[appState.grid.stack];
                utils.elements.selectAllBtn.textContent = files.length;
                utils.elements.gridContainer.innerHTML = '';

                files.forEach(file => {
                    const div = document.createElement('div');
                    div.className = 'grid-item';
                    div.dataset.fileId = file.id;
                    if (appState.grid.selected.includes(file.id)) div.classList.add('selected');
                    
                    const img = document.createElement('img');
                    img.className = 'grid-image';
                    img.alt = file.name;
                    img.src = utils.generateImageUrl(file);
                    img.onload = () => img.classList.add('loaded');
                    img.onerror = () => { img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; img.classList.add('loaded'); };
                    
                    div.addEventListener('click', e => this.toggleSelection(e, file.id));
                    div.appendChild(img);
                    utils.elements.gridContainer.appendChild(div);
                });
            },
            
            toggleSelection(e, fileId) {
                const gridItem = e.currentTarget;
                const index = appState.grid.selected.indexOf(fileId);
                if (index === -1) { appState.grid.selected.push(fileId); gridItem.classList.add('selected'); } 
                else { appState.grid.selected.splice(index, 1); gridItem.classList.remove('selected'); }
                this.updateSelectionUI();
            },
            
            updateSelectionUI() {
                const count = appState.grid.selected.length;
                utils.elements.selectionText.textContent = `${count} selected`;
                [utils.elements.tagSelected, utils.elements.moveSelected, utils.elements.deleteSelected, utils.elements.exportSelected, utils.elements.folderSelected].forEach(btn => {
                    if (btn) btn.disabled = (count === 0);
                });
            },
            
            selectAll(filesToSelect) {
                appState.grid.selected = filesToSelect.map(f => f.id);
                document.querySelectorAll('#grid-container .grid-item').forEach(item => item.classList.add('selected'));
                this.updateSelectionUI();
            },
            
            deselectAll() {
                document.querySelectorAll('#grid-container .grid-item.selected').forEach(item => item.classList.remove('selected'));
                appState.grid.selected = [];
                this.updateSelectionUI();
            },
            
            performSearch() {
                const query = utils.elements.omniSearch.value.trim();
                utils.elements.clearSearchBtn.style.display = query ? 'block' : 'none';
                if (!query) { this.resetSearch(); return; }
                const filtered = this.searchImages(query);
                this.renderGridFromState(filtered);
                this.selectAll(filtered);
            },

            resetSearch() {
                utils.elements.omniSearch.value = '';
                utils.elements.clearSearchBtn.style.display = 'none';
                this.renderGridFromState();
                this.deselectAll();
            },
            
            searchImages(query) {
                const regex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                return appState.stacks[appState.grid.stack].filter(file => {
                    const searchableText = [file.name, file.tags?.join(' '), file.notes, JSON.stringify(file.extractedMetadata || {})].join(' ');
                    return regex.test(searchableText);
                });
            },
        };

        // ===== Details Modal =====
        const detailsModal = {
            async show() { const file = appState.stacks[appState.currentStack][appState.currentStackPosition]; if (!file) return; if (file.metadataStatus !== 'loaded') { this.populateMetadataTab(file); await masterController.processFileMetadata(file); } this.populateAllTabs(file); utils.showModal('details-modal'); this.switchTab('info'); },
            hide() { utils.hideModal('details-modal'); },
            switchTab(tabName) { document.querySelectorAll('.tab-button').forEach(b => b.classList.toggle('active', b.dataset.tab === tabName)); document.querySelectorAll('.tab-content').forEach(c => c.classList.toggle('active', c.id === `tab-${tabName}`)); },
            populateAllTabs(file) { this.populateInfoTab(file); this.populateTagsTab(file); this.populateNotesTab(file); this.populateMetadataTab(file); },
            populateInfoTab(file) { utils.elements.detailFilename.textContent = file.name; utils.elements.detailFilenameLink.href = appState.exportSystem.getDirectImageURL(file); utils.elements.detailDate.textContent = new Date(file.modifiedTime).toLocaleString(); utils.elements.detailSize.textContent = utils.formatFileSize(file.size); },
            populateTagsTab(file) {
                const tags = file.tags || [];
                utils.elements.detailTags.innerHTML = '';
                tags.forEach(tag => { const el = document.createElement('div'); el.className = 'tag-item'; el.innerHTML = `<span>${tag}</span><button class="tag-remove" data-tag="${tag}">×</button>`; utils.elements.detailTags.appendChild(el); });
                const addBtn = document.createElement('button'); addBtn.className = 'add-tag-btn'; addBtn.textContent = '+ Add Tag';
                addBtn.onclick = () => this.showAddTagInput(file);
                utils.elements.detailTags.appendChild(addBtn);
                utils.elements.detailTags.querySelectorAll('.tag-remove').forEach(b => b.onclick = (e) => this.removeTag(file, e.target.dataset.tag));
                
                // Populate folder tags
                const folderTagsContainer = utils.elements.folderTags;
                folderTagsContainer.innerHTML = '';
                const allFolderTags = new Set(appState.imageFiles.flatMap(f => f.tags || []));
                allFolderTags.forEach(tag => {
                    const tagEl = document.createElement('button');
                    tagEl.className = 'tag-item';
                    tagEl.textContent = tag;
                    tagEl.style.cursor = 'pointer';
                    tagEl.onclick = () => this.addTag(file, tag);
                    folderTagsContainer.appendChild(tagEl);
                });
            },
            showAddTagInput(file) {
                const input = document.createElement('input'); input.type = 'text'; input.className = 'tag-input'; input.placeholder = 'Enter new tag...';
                const addBtn = utils.elements.detailTags.querySelector('.add-tag-btn');
                addBtn.style.display = 'none';
                addBtn.parentNode.insertBefore(input, addBtn);
                input.focus();
                const onEnd = async () => {
                    const tagName = input.value.trim();
                    if (tagName) await this.addTag(file, tagName);
                    input.remove();
                    addBtn.style.display = 'inline-flex';
                };
                input.onkeydown = async (e) => { if (e.key === 'Enter') onEnd(); else if (e.key === 'Escape') { input.remove(); addBtn.style.display = 'inline-flex'; } };
                input.onblur = () => setTimeout(onEnd, 100);
            },
            async addTag(file, tagName) {
                const newTags = [...new Set([...(file.tags || []), tagName])];
                await masterController.updateUserMetadata(file.id, { tags: newTags });
                this.populateTagsTab(file);
            },
            async removeTag(file, tagToRemove) {
                const newTags = (file.tags || []).filter(t => t !== tagToRemove);
                await masterController.updateUserMetadata(file.id, { tags: newTags });
                this.populateTagsTab(file);
            },
            populateNotesTab(file) { utils.elements.detailNotes.value = file.notes || ''; const newNotes = utils.elements.detailNotes.cloneNode(true); utils.elements.detailNotes.parentNode.replaceChild(newNotes, utils.elements.detailNotes); utils.elements.detailNotes = newNotes; utils.elements.detailNotes.onblur = async () => { const currentFile = appState.stacks[appState.currentStack][appState.currentStackPosition]; if (currentFile.notes !== utils.elements.detailNotes.value) { await masterController.updateUserMetadata(currentFile.id, { notes: utils.elements.detailNotes.value }); } }; this.setupStarRating('quality', file.qualityRating || 0); this.setupStarRating('content', file.contentRating || 0); },
            setupStarRating(type, currentRating) { const container = utils.elements[`${type}Rating`]; if (!container) return; let rating = currentRating; const stars = container.querySelectorAll('.star'); const update = (r) => stars.forEach((s, i) => s.classList.toggle('active', i < r)); container.onmouseleave = () => update(rating); stars.forEach((star, i) => { star.onmouseenter = () => update(i + 1); star.onclick = async () => { rating = (i + 1 === rating) ? 0 : i + 1; update(rating); const file = appState.stacks[appState.currentStack][appState.currentStackPosition]; const payload = type === 'quality' ? { qualityRating: rating } : { contentRating: rating }; await masterController.updateUserMetadata(file.id, payload); }; }); update(rating); },
            populateMetadataTab(file) {
                utils.elements.metadataTable.innerHTML = '';
                if (file.metadataStatus !== 'loaded') { utils.elements.metadataTable.innerHTML = `<tr><td colspan="2" style="text-align:center; padding: 20px;"><div class="spinner" style="margin: 0 auto;"></div></td></tr>`; return; }
                const metadata = file.extractedMetadata || {};
                if (Object.keys(metadata).length === 0) { this.addMetadataRow('Status', 'No embedded metadata found'); return; }
                
                const priorityFields = ['prompt', 'Prompt', 'model', 'Model', 'seed', 'Seed', 'negative_prompt', 'Negative_Prompt', 'steps', 'Steps', 'cfg_scale', 'CFG_Scale', 'sampler', 'Sampler', 'scheduler', 'Scheduler', 'api_call', 'API_Call'];
                priorityFields.forEach(field => { if (metadata[field]) this.addMetadataRow(field, metadata[field], true); });
                
                const remainingFields = Object.entries(metadata).filter(([key]) => !priorityFields.some(p => p.toLowerCase() === key.toLowerCase()));
                if (remainingFields.length > 0 && Object.keys(metadata).length > remainingFields.length) {
                    const sep = document.createElement('tr');
                    sep.innerHTML = `<td colspan="2" style="padding: 8px; background: #f0f0f0; text-align: center; font-size: 12px; color: #666; font-weight: bold;">Other Metadata</td>`;
                    utils.elements.metadataTable.appendChild(sep);
                }
                remainingFields.forEach(([key, value]) => this.addMetadataRow(key, value, true));
            },
            addMetadataRow(key, value, needsCopy = false) { const row = document.createElement('tr'); const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()); let formattedValue = String(value); if (formattedValue.length > 200) formattedValue = formattedValue.replace(/,\s+/g, ',\n').trim(); row.innerHTML = `<td class="key-cell">${formattedKey}</td><td class="value-cell">${formattedValue}</td>`; if (needsCopy) { const copyBtn = document.createElement('button'); copyBtn.className = 'copy-button copy-metadata'; copyBtn.textContent = 'Copy'; copyBtn.dataset.value = String(value); row.cells[1].appendChild(copyBtn); } utils.elements.metadataTable.appendChild(row); }
        };

        // ===== Unified Modal Manager =====
        const modalManager = {
            show(type, options = {}) { this.currentAction = type; const { title, content, confirmText = 'Confirm', confirmClass = 'btn-primary' } = options; utils.elements.actionTitle.textContent = title; utils.elements.actionContent.innerHTML = content; utils.elements.actionConfirm.textContent = confirmText; utils.elements.actionConfirm.className = `btn ${confirmClass}`; utils.elements.actionConfirm.disabled = false; utils.elements.actionCancel.textContent = "Cancel"; utils.showModal('action-modal'); },
            hide() { utils.hideModal('action-modal'); this.currentAction = null; },
            setupMoveAction() { this.show('move', { title: 'Move to Stack', content: `<div style="display: flex; flex-direction: column; gap: 8px;">${STACK_TYPES.map(s => `<button class="move-option" data-stack="${s}" style="width: 100%; text-align: left; padding: 8px 16px; border-radius: 6px; border: none; background: transparent; cursor: pointer;">${STACK_NAMES[s]}</button>`).join('')}</div>`, confirmText: 'Cancel' }); document.querySelectorAll('.move-option').forEach(o => o.onclick = () => this.executeMove(o.dataset.stack)); },
            setupTagAction() { this.show('tag', { title: 'Add Tags', content: `<input type="text" id="modal-tag-input" class="tag-input" placeholder="nature, landscape"><div id="modal-tag-suggestions" style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px;">${Array.from(appState.tags).map(t => `<button class="tag-suggestion" data-tag="${t}" style="background-color: #e5e7eb; color: #374151; padding: 4px 8px; border-radius: 6px; font-size: 12px; cursor: pointer; border: none;">${t}</button>`).join('')}</div>`, confirmText: 'Apply' }); document.querySelectorAll('.tag-suggestion').forEach(b => b.onclick = () => { const input = document.getElementById('modal-tag-input'); input.value += (input.value ? ', ' : '') + b.dataset.tag; }); },
            setupDeleteAction() { this.show('delete', { title: 'Confirm Delete', content: `<p style="color: #4b5563;">Move ${appState.grid.selected.length} image(s) to your provider's trash?</p>`, confirmText: 'Move to Trash', confirmClass: 'btn-danger' }); },
            setupExportAction() { this.show('export', { title: 'Export to Spreadsheet', content: `<p style="color: #4b5563;">This will start a Live Export for ${appState.grid.selected.length} image(s), fetching fresh data from the cloud.</p>`, confirmText: 'Begin Export' }); },
            async executeBulkAction(actionFn, successMessage, options = {}) {
                const { refreshGrid = true, deselect = true, keepModalOpen = false } = options;
                const confirmBtn = utils.elements.actionConfirm;
                const originalText = confirmBtn.textContent;
                confirmBtn.disabled = true; confirmBtn.textContent = 'Processing...';
                try {
                    const promises = appState.grid.selected.map(fileId => actionFn(fileId));
                    await Promise.all(promises);
                    utils.showToast(successMessage.replace('{count}', promises.length), 'success', true);
                    if (!keepModalOpen) this.hide();
                    if (refreshGrid) gridView.renderGridFromState();
                    if (deselect) gridView.deselectAll();
                    else gridView.updateSelectionUI();
                    commonFunctions.updateStackCounts();
                } catch (error) { utils.showToast(`Failed to process some images: ${error.message}`, 'error', true); }
                finally { confirmBtn.disabled = false; confirmBtn.textContent = originalText; }
            },
            async executeMove(targetStack) {
                const selectedFiles = appState.grid.selected.map(id => appState.imageFiles.find(f => f.id === id)).filter(Boolean);
                if (selectedFiles.length === 0) return;

                // Remove from old stacks
                selectedFiles.forEach(file => {
                    const originalStack = appState.stacks[file.stack];
                    const index = originalStack.findIndex(f => f.id === file.id);
                    if (index > -1) originalStack.splice(index, 1);
                });

                // Add to new stack and get new sequence numbers
                const targetStackArray = appState.stacks[targetStack];
                const timestamp = Date.now();
                const updatePromises = selectedFiles.map((file, index) => {
                    file.stack = targetStack;
                    file.stackSequence = timestamp - index;
                    return masterController.updateUserMetadata(file.id, { stack: targetStack, stackSequence: file.stackSequence });
                });
                
                appState.stacks[targetStack].unshift(...selectedFiles);
                appState.stacks[targetStack] = commonFunctions.sortFiles(appState.stacks[targetStack]);

                await Promise.all(updatePromises);

                utils.showToast(`Moved ${selectedFiles.length} images to ${STACK_NAMES[targetStack]}`, 'success', true);
                this.hide();
                gridView.renderGridFromState(); 
                gridView.deselectAll();
                commonFunctions.updateStackCounts();
            },
            async executeTag() {
                const tagsToAdd = document.getElementById('modal-tag-input').value.split(',').map(t => t.trim()).filter(Boolean);
                if (tagsToAdd.length === 0) return;
                await this.executeBulkAction(async (fileId) => {
                    const file = appState.imageFiles.find(f => f.id === fileId);
                    if (file) {
                        const newTags = [...new Set([...(file.tags || []), ...tagsToAdd])];
                        tagsToAdd.forEach(t => appState.tags.add(t));
                        await masterController.updateUserMetadata(file.id, { tags: newTags });
                    }
                }, `Tags added to {count} images`, { refreshGrid: false, deselect: false });
            },
            async executeDelete() {
                await this.executeBulkAction(async (fileId) => {
                    await masterController.deleteFile(fileId);
                    const fileIndex = appState.imageFiles.findIndex(f => f.id === fileId);
                    if (fileIndex > -1) {
                        const [file] = appState.imageFiles.splice(fileIndex, 1);
                        const stackIndex = appState.stacks[file.stack].findIndex(f => f.id === fileId);
                        if (stackIndex > -1) appState.stacks[file.stack].splice(stackIndex, 1);
                    }
                }, `Moved {count} images to provider trash`);
            },
            async executeExport() { /* Omitted for brevity */ }
        };

        // ===== Gesture, Zoom, Focus Mode Systems =====
        function setupGestureSystem() { let startPos = { x: 0, y: 0 }, currentPos = { x: 0, y: 0 }, gestureStarted = false, lastTapTime = 0; const edges = [utils.elements.edgeTop, utils.elements.edgeBottom, utils.elements.edgeLeft, utils.elements.edgeRight]; function showGlow(dir) { edges.forEach(e => e.classList.remove('active')); if (utils.elements[`edge${dir.charAt(0).toUpperCase() + dir.slice(1)}`]) utils.elements[`edge${dir.charAt(0).toUpperCase() + dir.slice(1)}`].classList.add('active'); } function hideGlows() { edges.forEach(e => e.classList.remove('active')); } function getDir(dx, dy) { return Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 'right' : 'left') : (dy > 0 ? 'bottom' : 'top'); } function dirToStack(dir) { return { top: 'priority', bottom: 'trash', left: 'in', right: 'out' }[dir]; } async function flick(stack) { if (appState.stacks[appState.currentStack].length === 0) return; acknowledgePillCounter(stack); if (appState.hapticManager) appState.hapticManager.triggerFeedback('swipe'); try { await commonFunctions.moveToStack(stack); } catch (e) { utils.showToast(`Error moving: ${e.message}`, 'error', true); } finally { hideGlows(); } } function handleStart(e) { const now = Date.now(); if (now - lastTapTime < 300) { e.preventDefault(); focusMode.toggle(); lastTapTime = 0; return; } lastTapTime = now; if (appState.isFocusMode || appState.stacks[appState.currentStack].length === 0 || (e.touches && e.touches.length > 1) || appState.currentScale > 1.1) return; const p = e.touches ? e.touches[0] : e; startPos = { x: p.clientX, y: p.clientY }; currentPos = { ...startPos }; gestureStarted = false; appState.isDragging = true; utils.elements.centerImage.classList.add('dragging'); } function handleMove(e) { if (!appState.isDragging || appState.isFocusMode || (e.touches && e.touches.length > 1)) return; e.preventDefault(); const p = e.touches ? e.touches[0] : e; currentPos = { x: p.clientX, y: p.clientY }; const dx = currentPos.x - startPos.x, dy = currentPos.y - startPos.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist > 30) { gestureStarted = true; showGlow(getDir(dx, dy)); } else { hideGlows(); } } function handleEnd(e) { if (!appState.isDragging || appState.isFocusMode) return; appState.isDragging = false; utils.elements.centerImage.classList.remove('dragging'); if (!gestureStarted) { hideGlows(); return; } const dx = currentPos.x - startPos.x, dy = currentPos.y - startPos.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist > 80) { const dir = getDir(dx, dy); const stack = dirToStack(dir); if (stack) { flick(stack); return; } } hideGlows(); } utils.elements.imageViewport.addEventListener('mousedown', handleStart); document.addEventListener('mousemove', handleMove); document.addEventListener('mouseup', handleEnd); utils.elements.imageViewport.addEventListener('touchstart', handleStart, { passive: false }); document.addEventListener('touchmove', handleMove, { passive: false }); document.addEventListener('touchend', handleEnd, { passive: false }); }
        function setupPinchZoom() { function getDist(t1, t2) { const dx = t1.clientX - t2.clientX, dy = t1.clientY - t2.clientY; return Math.sqrt(dx * dx + dy * dy); } utils.elements.centerImage.addEventListener('touchstart', (e) => { if (e.touches.length === 2) { e.preventDefault(); appState.isPinching = true; appState.initialDistance = getDist(e.touches[0], e.touches[1]); } }, { passive: false }); utils.elements.centerImage.addEventListener('touchmove', (e) => { if (e.touches.length === 2 && appState.isPinching) { e.preventDefault(); const newDist = getDist(e.touches[0], e.touches[1]); const newScale = appState.currentScale * (newDist / appState.initialDistance); appState.currentScale = Math.max(appState.minScale, Math.min(appState.maxScale, newScale)); appState.initialDistance = newDist; commonFunctions.applyTransform(); } }, { passive: false }); utils.elements.centerImage.addEventListener('touchend', () => { appState.isPinching = false; if (appState.currentScale < 1.1) { appState.currentScale = 1; appState.panOffset = { x: 0, y: 0 }; commonFunctions.applyTransform(); } }); utils.elements.centerImage.addEventListener('wheel', (e) => { e.preventDefault(); const newScale = appState.currentScale * (e.deltaY > 0 ? 0.9 : 1.1); appState.currentScale = Math.max(appState.minScale, Math.min(appState.maxScale, newScale)); if (appState.currentScale <= 1.1) { appState.currentScale = 1; appState.panOffset = { x: 0, y: 0 }; } commonFunctions.applyTransform(); }, { passive: false }); }
        const focusMode = { toggle() { appState.isFocusMode = !appState.isFocusMode; utils.elements.appContainer.classList.toggle('focus-mode', appState.isFocusMode); commonFunctions.updateImageCounters(); }, async nextImage() { const s = appState.stacks[appState.currentStack]; if (s.length === 0) return; appState.currentStackPosition = (appState.currentStackPosition + 1) % s.length; await commonFunctions.displayCurrentImage(); }, async prevImage() { const s = appState.stacks[appState.currentStack]; if (s.length === 0) return; appState.currentStackPosition = (appState.currentStackPosition - 1 + s.length) % s.length; await commonFunctions.displayCurrentImage(); }, async deleteCurrentImage() { const stack = appState.stacks[appState.currentStack]; if (stack.length === 0) return; const file = stack[appState.currentStackPosition]; try { await masterController.deleteFile(file.id); const fileIndex = appState.imageFiles.findIndex(f => f.id === file.id); if (fileIndex > -1) appState.imageFiles.splice(fileIndex, 1); stack.splice(appState.currentStackPosition, 1); commonFunctions.updateStackCounts(); if (stack.length === 0) { this.toggle(); commonFunctions.showEmptyState(); } else { await commonFunctions.displayCurrentImage(); } } catch (e) { utils.showToast(`Failed to delete ${file.name}`, 'error', true); } } };
        function setupFocusModeGestures() { let startX = 0, isSwiping = false; utils.elements.imageViewport.addEventListener('touchstart', (e) => { if (!appState.isFocusMode || e.touches.length > 1) return; startX = e.touches[0].clientX; isSwiping = true; }); utils.elements.imageViewport.addEventListener('touchend', (e) => { if (!isSwiping || !appState.isFocusMode) return; isSwiping = false; const deltaX = e.changedTouches[0].clientX - startX; if (Math.abs(deltaX) > 50) { if (deltaX < 0) focusMode.nextImage(); else focusMode.prevImage(); } }); }
        
        // ===== Event Handlers =====
        function setupEventHandlers() {
            utils.elements.googleDriveBtn.onclick = () => appController.selectGoogleDrive();
            utils.elements.onedriveBtn.onclick = () => appController.selectOneDrive();
            document.querySelectorAll('.intensity-btn').forEach(b => b.onclick = () => appState.visualCueManager.setIntensity(b.dataset.level));
            utils.elements.hapticEnabled.onchange = (e) => appState.hapticManager.setEnabled(e.target.checked);
            utils.elements.gdriveAuthButton.onclick = async () => { const secret = utils.elements.gdriveClientSecret.value.trim(); if (!secret) { utils.elements.gdriveAuthStatus.textContent = 'Please enter client secret'; return; } utils.elements.gdriveAuthButton.disabled = true; try { const provider = new GoogleDriveProvider(); if (await provider.authenticate(secret)) { appState.currentProvider = provider; utils.showScreen('gdrive-folder-screen'); loadGoogleDriveFolders(); } } catch (e) { utils.elements.gdriveAuthStatus.textContent = `Auth failed: ${e.message}`; } finally { utils.elements.gdriveAuthButton.disabled = false; } };
            utils.elements.onedriveAuthButton.onclick = async () => { utils.elements.onedriveAuthButton.disabled = true; try { const provider = new OneDriveProvider(); if (await provider.authenticate()) { appState.currentProvider = provider; utils.showScreen('onedrive-folder-screen'); loadOneDriveFolders(); } } catch (e) { utils.elements.onedriveAuthStatus.textContent = `Auth failed: ${e.message}`; } finally { utils.elements.onedriveAuthButton.disabled = false; } };
            utils.elements.gdriveBackButton.onclick = utils.elements.onedriveBackButton.onclick = () => appController.backToProviderSelection();
            utils.elements.gdriveRefreshFolders.onclick = () => loadGoogleDriveFolders();
            utils.elements.onedriveRefreshFolders.onclick = () => loadOneDriveFolders();
            utils.elements.gdriveBackToProvider.onclick = utils.elements.onedriveBackToProvider.onclick = () => appController.backToProviderSelection();
            utils.elements.gdriveLogout.onclick = utils.elements.onedriveLogout.onclick = () => { if (appState.currentProvider) appState.currentProvider.disconnect(); appController.backToProviderSelection(); };
            utils.elements.cancelLoading.onclick = () => { if (appState.metadataExtractor) appState.metadataExtractor.abort(); masterController.returnToFolderSelection(); };
            utils.elements.detailsButton.onclick = () => detailsModal.show();
            utils.elements.saveButton.onclick = () => appState.syncManager.forceSync();
            utils.elements.detailsClose.onclick = () => detailsModal.hide();
            utils.elements.errorClose.onclick = () => utils.hideModal('error-modal');
            utils.elements.focusDeleteBtn.onclick = () => focusMode.deleteCurrentImage();
            document.querySelectorAll('.tab-button').forEach(b => b.onclick = () => detailsModal.switchTab(b.dataset.tab));
            document.addEventListener('click', (e) => { if (e.target.classList.contains('copy-metadata')) utils.copyToClipboard(e.target.dataset.value); });
            utils.elements.selectAnotherStackBtn.onclick = () => { const nextStack = STACK_TYPES.find(s => s !== appState.currentStack && appState.stacks[s].length > 0); if (nextStack) switchToStack(nextStack); };
            utils.elements.selectAnotherFolderBtn.onclick = () => masterController.returnToFolderSelection();
            STACK_TYPES.forEach(s => { const p = document.getElementById(`pill-${s}`); if (p) p.onclick = (e) => { e.stopPropagation(); if (appState.hapticManager) appState.hapticManager.triggerFeedback('pillTap'); if (appState.currentStack === s) gridView.open(s); else switchToStack(s); acknowledgePillCounter(s); }; });
            utils.elements.closeGrid.onclick = () => gridView.close();
            utils.elements.selectAllBtn.onclick = () => gridView.selectAll(appState.stacks[appState.grid.stack]);
            utils.elements.deselectAllBtn.onclick = () => gridView.deselectAll();
            utils.elements.gridSize.oninput = () => { const v = utils.elements.gridSize.value; utils.elements.gridSizeValue.textContent = v; utils.elements.gridContainer.style.gridTemplateColumns = `repeat(${v}, 1fr)`; };
            utils.elements.omniSearch.oninput = () => gridView.performSearch();
            utils.elements.clearSearchBtn.onclick = () => gridView.resetSearch();
            utils.elements.moveSelected.onclick = () => modalManager.setupMoveAction();
            utils.elements.tagSelected.onclick = () => modalManager.setupTagAction();
            utils.elements.deleteSelected.onclick = () => modalManager.setupDeleteAction();
            utils.elements.exportSelected.onclick = () => modalManager.setupExportAction();
            utils.elements.actionCancel.onclick = () => modalManager.hide();
            utils.elements.actionConfirm.onclick = () => { if (modalManager.currentAction === 'tag') modalManager.executeTag(); else if (modalManager.currentAction === 'delete') modalManager.executeDelete(); else if (modalManager.currentAction === 'export') modalManager.executeExport(); };
            document.addEventListener('keydown', (e) => { if (utils.elements.appContainer.classList.contains('hidden') || ['INPUT', 'TEXTAREA'].includes(e.target.tagName)) return; if (!utils.elements.detailsModal.classList.contains('hidden')) { if (e.key === 'Escape') detailsModal.hide(); return; } if (!utils.elements.gridModal.classList.contains('hidden')) { if (e.key === 'Escape') gridView.close(); return; } if (appState.isFocusMode) { if (e.key === 'ArrowRight') focusMode.nextImage(); if (e.key === 'ArrowLeft') focusMode.prevImage(); if (e.key === 'Escape') focusMode.toggle(); return; } const keyMap = { 'ArrowUp': 'priority', 'ArrowDown': 'trash', 'ArrowLeft': 'in', 'ArrowRight': 'out' }; if (keyMap[e.key]) { e.preventDefault(); if (appState.stacks[appState.currentStack].length > 0) { acknowledgePillCounter(keyMap[e.key]); commonFunctions.moveToStack(keyMap[e.key]); } } else if (e.key === 'Tab') { e.preventDefault(); cycleThroughProxTabs(); } else if (e.key === 'Escape') { masterController.returnToFolderSelection(); } });
        }
        
        function switchToStack(stackName) { commonFunctions.displayTopImageFromStack(stackName); }
        function cycleThroughProxTabs() { const order = ['in', 'out', 'priority', 'trash']; const nextIndex = (order.indexOf(appState.currentStack) + 1) % order.length; switchToStack(order[nextIndex]); }
        function updateEmptyStateButtons() { const hasOtherStacks = STACK_TYPES.some(s => s !== appState.currentStack && appState.stacks[s].length > 0); utils.elements.selectAnotherStackBtn.style.display = hasOtherStacks ? 'block' : 'none'; }
        function acknowledgePillCounter(stackName) { const pill = document.getElementById(`pill-${stackName}`); if (pill) { pill.classList.remove('triple-ripple', 'glow-effect'); pill.offsetHeight; pill.classList.add('triple-ripple'); setTimeout(() => pill.classList.add('glow-effect'), 100); setTimeout(() => pill.classList.remove('triple-ripple', 'glow-effect'), 3000); } }
        
        // ===== Folder Loading Functions =====
        async function loadGoogleDriveFolders() {
            utils.elements.gdriveFolderList.innerHTML = `<div style="display: flex; align-items: center; justify-content: center; padding: 40px;"><div class="spinner"></div><span>Loading...</span></div>`;
            try {
                const folders = await appState.currentProvider.getFolders();
                utils.elements.gdriveFolderList.innerHTML = '';
                if (folders.length === 0) { utils.elements.gdriveFolderList.innerHTML = `<div style="padding: 40px;">No folders found.</div>`; return; }
                folders.forEach(folder => {
                    const div = document.createElement('div');
                    div.className = 'folder-item';
                    div.innerHTML = `<svg class="folder-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"></path></svg><div class="folder-info"><div class="folder-name">${folder.name}</div><div class="folder-date">${new Date(folder.modifiedTime).toLocaleDateString()}</div></div>`;
                    div.onclick = () => masterController.initializeWithProvider('googledrive', folder.id, folder.name, appState.currentProvider);
                    utils.elements.gdriveFolderList.appendChild(div);
                });
            } catch (e) { utils.showToast(`Error loading folders: ${e.message}`, 'error', true); }
        }
        async function loadOneDriveFolders() {
            utils.elements.onedriveFolderList.innerHTML = `<div style="display: flex; align-items: center; justify-content: center; padding: 40px;"><div class="spinner"></div><span>Loading...</span></div>`;
            try { const folders = await appState.currentProvider.getFolders(); displayOneDriveFolders(folders); updateOneDriveNavigation(); } 
            catch (error) { utils.showToast('Error loading folders', 'error', true); }
        }
        function displayOneDriveFolders(folders) {
            utils.elements.onedriveFolderList.innerHTML = '';
            if (folders.length === 0) { utils.elements.onedriveFolderList.innerHTML = `<div style="padding: 40px;">No subfolders found.</div>`; return; }
            folders.forEach(folder => {
                const div = document.createElement('div');
                div.className = 'folder-item';
                div.innerHTML = `<svg class="folder-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"></path></svg><div class="folder-info"><div class="folder-name">${folder.name}</div><div class="folder-date">${new Date(folder.modifiedTime).toLocaleDateString()} • ${folder.itemCount} items</div></div><div class="folder-actions">${folder.hasChildren ? `<button class="folder-action-btn drill-btn" data-folder-id="${folder.id}">Browse →</button>` : ''}<button class="folder-action-btn select-btn" data-folder-id="${folder.id}">Select</button></div>`;
                utils.elements.onedriveFolderList.appendChild(div);
            });
            document.querySelectorAll('.drill-btn').forEach(btn => btn.onclick = async (e) => { e.stopPropagation(); const folderId = btn.dataset.folderId; const folderName = btn.closest('.folder-item').querySelector('.folder-name').textContent; try { const subfolders = await appState.currentProvider.drillIntoFolder({ id: folderId, name: folderName }); displayOneDriveFolders(subfolders); updateOneDriveNavigation(); } catch (error) { utils.showToast('Error loading subfolders', 'error', true); } });
            document.querySelectorAll('.select-btn').forEach(btn => btn.onclick = (e) => { e.stopPropagation(); const folderId = btn.dataset.folderId; const folderName = btn.closest('.folder-item').querySelector('.folder-name').textContent; masterController.initializeWithProvider('onedrive', folderId, folderName, appState.currentProvider); });
        }
        function updateOneDriveNavigation() {
            utils.elements.onedriveFolderSubtitle.textContent = `Current: ${appState.currentProvider.getCurrentPath()}`;
            const refreshBtn = utils.elements.onedriveRefreshFolders;
            if (appState.currentProvider.canGoUp()) {
                refreshBtn.textContent = '← Go Up';
                refreshBtn.onclick = async () => { try { const folders = await appState.currentProvider.navigateToParent(); displayOneDriveFolders(folders); updateOneDriveNavigation(); } catch (error) { utils.showToast('Error navigating up', 'error', true); } };
            } else {
                refreshBtn.textContent = 'Refresh';
                refreshBtn.onclick = () => loadOneDriveFolders();
            }
        }
        
        // ===== Initialize App =====
        async function initApp() {
            try {
                utils.init();
                appState.visualCueManager = new VisualCueManager();
                appState.hapticManager = new HapticFeedbackManager();
                appState.exportSystem = new ExportSystem();
                appState.localDB = new LocalDB();
                await appState.localDB.init();
                appState.syncManager = new SyncManager();
                appState.metadataExtractor = new ProgressiveMetadataExtractor();
                utils.showScreen('provider-screen');
                setupEventHandlers();
                setupGestureSystem();
                setupFocusModeGestures();
                setupPinchZoom();
                commonFunctions.updateActiveProxTab();
            } catch (error) {
                console.error("Initialization failed:", error);
                utils.showToast('Failed to initialize app', 'error', true);
            }
        }
        
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
