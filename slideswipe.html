<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no, maximum-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Orbital8 Goji Version (SlideSwipe Core)</title>
    <script src="https://alcdn.msauth.net/browser/2.28.1/js/msal-browser.min.js"></script>
    <style>
        /* Goji Base Variables */
        :root {
            --accent: #f59e0b;
            --glass: rgba(255, 255, 255, 0.1);
            --border: rgba(255, 255, 255, 0.3);
            --dark: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
            --glow: 0.6;
            --ripple: 1500ms;
        }

        * { box-sizing: border-box; }
        
        body, html {
            margin: 0; padding: 0; height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden; background: #000; overscroll-behavior: none; touch-action: none;
        }
        
        /* Goji Screen Styles (For Auth/Folder Screens) */
        .screen {
            position: fixed; inset: 0; background: var(--dark);
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000;
        }
        .screen.hidden { display: none; }
        
        .card {
            background: var(--glass); backdrop-filter: blur(20px);
            border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 20px;
            padding: 40px; text-align: center; max-width: 500px; width: 90%;
        }
        
        .title { color: white; font-size: 24px; font-weight: 600; margin-bottom: 16px; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8); }
        .subtitle { color: rgba(255, 255, 255, 0.7); font-size: 16px; margin-bottom: 24px; }
        
        .input, .notes-textarea {
            width: 100%; padding: 12px 16px; border: 1px solid var(--border); border-radius: 12px;
            background: var(--glass); color: white; font-size: 14px; margin-bottom: 16px; backdrop-filter: blur(10px);
        }
        .input::placeholder { color: rgba(255, 255, 255, 0.5); }
        .input:focus, .notes-textarea:focus, .tag-input:focus {
            outline: none; border-color: var(--accent); box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.2);
        }
        .button, .folder-button, .btn {
            background: linear-gradient(45deg, var(--accent), #d97706); border: none; border-radius: 15px;
            color: white; font-size: 18px; font-weight: 600; padding: 16px 32px; cursor: pointer;
            transition: all 0.3s ease; box-shadow: 0 4px 20px rgba(245, 158, 11, 0.4); width: 100%; margin-bottom: 16px;
        }
        .folder-button {
            flex: 1; padding: 12px 24px; border: 1px solid var(--border); background: var(--glass);
            font-size: 14px; backdrop-filter: blur(10px); width: auto;
        }
        .folder-button.danger { border-color: rgba(239, 68, 68, 0.3); color: #ef4444; }
        .provider-button {
            display: flex; align-items: center; justify-content: center; gap: 12px;
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px; padding: 20px; margin-bottom: 16px; color: white;
            font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        .status {
            padding: 12px; border-radius: 8px; margin-top: 16px; font-size: 14px; font-weight: 500;
        }
        .status.success { background: rgba(16, 185, 129, 0.2); color: #10b981; border: 1px solid rgba(16, 185, 129, 0.3); }
        .status.error { background: rgba(239, 68, 68, 0.2); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.3); }
        .status.info { background: rgba(59, 130, 246, 0.2); color: #3b82f6; border: 1px solid rgba(59, 130, 246, 0.3); }
        
        .folder-list { flex: 1; overflow-y: auto; margin-bottom: 20px; max-height: 400px; }
        .folder-item {
            display: flex; align-items: center; padding: 12px 16px; margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px; cursor: pointer; transition: all 0.2s ease; color: white; justify-content: space-between;
        }
        .folder-icon { width: 20px; height: 20px; margin-right: 12px; color: var(--accent); }
        .folder-info { flex: 1; }
        .folder-name { font-weight: 500; margin-bottom: 2px; }
        .folder-date { font-size: 12px; color: rgba(255, 255, 255, 0.6); }
        .folder-action-btn {
            padding: 6px 12px; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 8px;
            background: rgba(255, 255, 255, 0.1); color: white; font-size: 12px; cursor: pointer;
            transition: all 0.2s ease; backdrop-filter: blur(10px);
        }
        .folder-action-btn.drill-btn { border-color: rgba(245, 158, 11, 0.4); color: var(--accent); }
        .folder-action-btn.select-btn { border-color: rgba(16, 185, 129, 0.4); color: #10b981; }
        
        .spinner {
            width: 20px; height: 20px; border: 2px solid rgba(245, 158, 11, 0.3);
            border-radius: 50%; border-top-color: var(--accent); animation: spin 1s linear infinite; margin-right: 12px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* SLIDESWIPE APP-SPECIFIC STYLES - UI Cleanup */
        /* Overrides to restore SlideSwipe's white background / dark text UI */
        #app-screen {
            background: #fff;
            color: #1f2937;
        }
        /* Reset containers to fix sizing after Goji CSS injection */
        .ss-app-container {
             display: flex; flex-direction: column; height: 100vh;
        }
        .ss-header {
            background-color: #fff; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            padding: 12px 16px; display: flex; align-items: center; justify-content: space-between;
        }
        .ss-main-container {
             flex: 1; display: flex; overflow: hidden;
        }
        .ss-center-stage {
            flex: 1; min-height: 250px; position: relative; background: #fff;
            border-right: 1px solid #e5e7eb;
        }
        .ss-stacks-panel {
            width: 300px; max-height: 100vh; position: relative; background: #fff;
            overflow: hidden; display: flex; flex-direction: column;
        }
        .ss-image-container {
            position: relative; width: 100%; height: 100%; overflow: hidden; user-select: none; touch-action: none;
        }
        .ss-center-image { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            max-width: 100%; max-height: 100%; pointer-events: none; transition: transform 0.2s ease;
        }
        .ss-tabs { display: flex; border-bottom: 1px solid #e5e7eb; justify-content: space-around; }
        .ss-tab { padding: 12px 16px; cursor: pointer; border-bottom: 2px solid transparent; text-align: center; color: #6b7280; }
        .ss-tab.active { border-bottom-color: #3b82f6; color: #3b82f6; }
        .ss-tab-content { flex: 1; overflow-y: auto; position: relative; }
        .ss-tab-pane { padding: 1rem; display: none; }
        .ss-tab-pane.active { display: block; }
        .ss-stack-container { display: flex; flex-wrap: wrap; gap: 8px; }
        .ss-stack-thumbnail { 
            width: 90px; height: 90px; object-fit: cover; border-radius: 4px; 
            cursor: pointer; border: 2px solid transparent; transition: all 0.2s ease;
        }
        .ss-stack-thumbnail.selected { border-color: #3b82f6; }
        .zoom-controls { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(255, 255, 255, 0.8); border-radius: 8px; padding: 8px 12px; display: flex; align-items: center; z-index: 10; }
        .pill-counter {
            background-color: #e5e7eb; color: #4b5563; padding: 0.125rem 0.5rem; font-weight: 500;
            display: inline-block; min-width: 36px; text-align: center; border-radius: 9999px;
        }
        
        @media screen and (max-width: 1024px) and (orientation: landscape) {
            .ss-main-container { flex-direction: row; }
            .ss-center-stage { flex: 1; border-right: 1px solid #e5e7eb; }
            .ss-stacks-panel { width: 40%; }
        }
        @media screen and (max-width: 1024px) and (orientation: portrait) {
            .ss-main-container { flex-direction: column; }
            .ss-center-stage { height: 60%; border-right: none; border-bottom: 1px solid #e5e7eb; }
            .ss-stacks-panel { width: 100%; height: 40%; }
        }

    </style>
</head>
<body>
    <div class="screen" id="provider-screen">
        <div class="card">
            <h1 class="title" style="font-size: 32px;">Orbital8 / SlideSwipe</h1>
            <p class="subtitle">Select your cloud storage provider</p>
            <button class="provider-button" id="google-drive-btn">
                <svg style="width: 20px; height: 20px;" viewBox="0 0 24 24"><path fill="currentColor" d="M6.28 7L9.69 1h4.62l3.41 6zM16.05 7H7.95l4.05 7zM11.76 15h8.58L24 21H7.05z"/></svg>
                Google Drive
            </button>
            <button class="provider-button" id="onedrive-btn">
                <svg style="width: 20px; height: 20px;" viewBox="0 0 24 24"><path fill="currentColor" d="M17.75 8C16.82 8 16 8.82 16 9.75S16.82 11.5 17.75 11.5s1.75-.82 1.75-1.75S18.68 8 17.75 8z"/></svg>
                OneDrive
            </button>
            <div id="provider-status" class="status info">Choose your preferred cloud storage</div>
        </div>
    </div>
    
    <div class="screen hidden" id="auth-screen">
        <div class="card">
            <h1 class="title" id="auth-title">Provider</h1>
            <p class="subtitle" id="auth-subtitle">Connect to your account</p>
            <div id="gdrive-secret-container" class="hidden" style="margin-bottom: 16px;">
                <input type="password" id="gdrive-client-secret" class="input" placeholder="Enter Google Client Secret" style="margin-bottom: 0;">
            </div>
            <button class="button" id="auth-button">Connect</button>
            <button class="button" id="auth-back-button" style="background: rgba(128,128,128,0.3);">← Back</button>
            <div id="auth-status" class="status info"></div>
        </div>
    </div>
    
    <div class="screen hidden" id="folder-screen">
        <div class="card" style="max-height: 80vh; display: flex; flex-direction: column;">
            <h2 class="title" id="folder-title">Select Folder</h2>
            <div class="subtitle" id="folder-subtitle">Choose a folder containing images</div>
            <div class="folder-list" id="folder-list"></div>
            <div class="folder-actions">
                <button class="folder-button" id="folder-refresh-button">Refresh</button>
                <button class="folder-button" id="folder-back-button">← Provider</button>
                <button class="folder-button danger" id="folder-logout-button">Disconnect</button>
            </div>
        </div>
    </div>

    <div id="app-screen" class="ss-app-container hidden">
        <header class="ss-header">
            <button id="header-tags-btn" class="btn btn-secondary">Tags</button>
            <span id="header-filename" class="text-sm font-medium text-gray-800"></span>
            <button id="header-grid-btn" class="btn btn-secondary">Grid</button>
        </header>
        <div class="ss-main-container">
            <div class="ss-center-stage" id="center-stage">
                <div class="ss-image-container">
                    <div class="zoom-controls">
                        <label for="image-zoom" class="text-sm text-gray-700 mr-2">Zoom:</label>
                        <input type="range" id="image-zoom" min="50" max="150" value="100" class="w-24">
                        <span id="zoom-value" class="text-sm text-gray-700 ml-2">100%</span>
                    </div>
                    <img id="center-image" class="ss-center-image" src="" alt="No image selected">
                    <div id="empty-state" class="absolute inset-0 flex items-center justify-center bg-gray-100 hidden">
                        <div class="text-center">
                            <p class="text-gray-500 mb-2">No images to review</p>
                            <button id="select-another-folder" class="btn btn-primary">Select Another Folder</button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="stacks-panel" class="ss-stacks-panel">
                <div class="ss-tabs">
                    <div class="ss-tab active" data-stack="in">
                        <span class="text-sm font-medium">In</span>
                        <span class="pill-counter stack-count" data-stack="in">0</span>
                    </div>
                    <div class="ss-tab" data-stack="out">
                        <span class="text-sm font-medium">Out</span>
                        <span class="pill-counter stack-count" data-stack="out">0</span>
                    </div>
                    <div class="ss-tab" data-stack="priority">
                        <span class="text-sm font-medium">Priority</span>
                        <span class="pill-counter stack-count" data-stack="priority">0</span>
                    </div>
                    <div class="ss-tab" data-stack="trash">
                        <span class="text-sm font-medium">Trash</span>
                        <span class="pill-counter stack-count" data-stack="trash">0</span>
                    </div>
                </div>
                <div class="ss-tab-content">
                    <div class="ss-tab-pane active" data-stack="in">
                        <div class="ss-stack-container" data-stack="in"></div>
                    </div>
                    <div class="ss-tab-pane" data-stack="out">
                        <div class="ss-stack-container" data-stack="out"></div>
                    </div>
                    <div class="ss-tab-pane" data-stack="priority">
                        <div class="ss-stack-container" data-stack="priority"></div>
                    </div>
                    <div class="ss-tab-pane" data-stack="trash">
                        <div class="ss-stack-container" data-stack="trash"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="toast" class="toast"></div>

    <div id="grid-modal" class="modal hidden">
        <div class="bg-white rounded-lg shadow-md w-full h-full max-w-6xl max-h-[90vh] m-4 flex flex-col">
            <div class="p-4">Grid View - Not fully wired</div>
            <button id="close-grid" class="btn btn-secondary">Close</button>
        </div>
    </div>
    
    <div id="move-modal" class="modal hidden"></div>
    <div id="tag-modal" class="modal hidden"></div>
    <div id="delete-modal" class="modal hidden"></div>
    <div id="metadata-panel" class="modal hidden"></div>

    <script>
        // ===== Helper Functions =====
        const $ = id => document.getElementById(id);
        const $$ = selector => document.querySelectorAll(selector);

        const DEBUG = false;
        const debug = (...args) => { if (DEBUG) console.log(...args); };

        // ===== Configuration =====
        const CONFIG = {
            imgTypes: ['image/png', 'image/jpeg', 'image/webp', 'image/gif'],
            stacks: ['in', 'out', 'priority', 'trash'],
            defaults: { zoom: 100 }
        };

        // ===== Application State (Adapted for Goji) =====
        const appState = {
            providerType: null, // 'googledrive' or 'onedrive'
            provider: null, // Instance of a Goji provider
            currentFolder: {id: null, name: ''}, // Renamed from 'folder' to match Goji
            images: [],
            currentIdx: 0,
            currentStack: 'in',
            stacks: { in: [], out: [], priority: [], trash: [] },
            grid: { stack: null, selected: [] },
            tags: new Set(),
            zoom: CONFIG.defaults.zoom
        };

        // ===== Core utility module (Adapted for Goji) =====
        const utils = {
            showScreen(id) {
                ['provider-screen', 'auth-screen', 'folder-screen', 'app-screen'].forEach(screen =>
                    $(screen)?.classList.toggle('hidden', screen !== id)
                );
            },
            toast(message, type = 'info', important = false) { 
                const toast = $('toast');
                toast.textContent = message;
                toast.className = `toast ${type} show`;
                setTimeout(() => toast.classList.remove('show'), 3000);
            },
            setImageSrc(img, file) {
                let imageUrl = this.getPreferredImageUrl(file);
                img.src = imageUrl;
                img.alt = file.name || 'Image';
                img.loading = 'lazy';
                img.onerror = () => {
                    img.src = this.getFallbackImageUrl(file);
                    img.onerror = () => {
                         img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="150" height="150" viewBox="0 0 150 150" fill="none"%3E%3Crect width="150" height="150" fill="%23E5E7EB"/%3E%3Cpath d="M65 60H85V90H65V60Z" fill="%239CA3AF"/%3E%3Ccircle cx="75" cy="45" r="10" fill="%239CA3AF"/%3E%3C/svg%3E';
                         img.alt = 'Image not available';
                    }
                };
            },
            getPreferredImageUrl(file) {
                if (appState.providerType === 'googledrive') {
                    if (file.thumbnailLink) { return file.thumbnailLink.replace('=s220', '=s1000'); }
                    return `https://drive.google.com/thumbnail?id=${file.id}&sz=w1000`;
                } else { // OneDrive
                    if (file.thumbnails && file.thumbnails.large) { return file.thumbnails.large.url; }
                    return file.downloadUrl || `https://graph.microsoft.com/v1.0/me/drive/items/${file.id}/content`;
                }
            },
            getFallbackImageUrl(file) {
                if (appState.providerType === 'googledrive') {
                    return file.webContentLink || file.webViewLink || `https://www.googleapis.com/drive/v3/files/${file.id}?alt=media`;
                } else { // OneDrive
                    return file.downloadUrl || `https://graph.microsoft.com/v1.0/me/drive/items/${file.id}/content`;
                }
            },
            async handleApiError(response, defaultMsg) {
                if (response.ok) return response;
                const text = await response.text();
                try {
                    const data = JSON.parse(text);
                    throw new Error(data.error?.message || defaultMsg);
                } catch {
                    throw new Error(`${defaultMsg}: ${response.status} ${response.statusText}`);
                }
            },
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            },
        };

        // ===== Provider Implementations (Copied from goji.html) =====
        class BaseProvider {
            constructor() { if (this.constructor === BaseProvider) { throw new Error("Abstract classes can't be instantiated."); } }
            async authenticate() { throw new Error("Method 'authenticate()' must be implemented."); }
            async disconnect() { throw new Error("Method 'disconnect()' must be implemented."); }
            async getFolders() { throw new Error("Method 'getFolders()' must be implemented."); }
            async getFiles(folderId) { throw new Error("Method 'getFiles(folderId)' must be implemented."); }
            async drillIntoFolder(folder) { throw new Error("Method 'drillIntoFolder(folder)' must be implemented."); }
            async navigateToParent() { throw new Error("Method 'navigateToParent()' must be implemented."); }
            getCurrentPath() { return 'Root'; }
            canGoUp() { return false; }
            async updateFileMetadata(fileId, metadata) { throw new Error("Method 'updateFileMetadata(fileId, metadata)' must be implemented."); }
            async deleteFile(fileId) { throw new Error("Method 'deleteFile(fileId)' must be implemented."); }
            async getAccessToken() { throw new Error("Method 'getAccessToken()' must be implemented."); } 
        }

        class GoogleDriveProvider extends BaseProvider {
            constructor() {
                super(); this.name = 'googledrive';
                this.clientId = '567988062464-fa6c1ovesqeudqs5398vv4mbo6q068p9.apps.googleusercontent.com';
                this.redirectUri = window.location.origin + window.location.pathname;
                this.scope = 'https://www.googleapis.com/auth/drive.file'; 
                this.apiBase = 'https://www.googleapis.com/drive/v3';
                this.accessToken = null; this.refreshToken = null; this.clientSecret = null;
                this.isAuthenticated = false; this.currentParentId = 'root';
                this.loadStoredCredentials();
            }
            loadStoredCredentials() {
                this.accessToken = localStorage.getItem('slide_google_access_token');
                this.refreshToken = localStorage.getItem('slide_google_refresh_token');
                this.clientSecret = localStorage.getItem('slide_google_client_secret');
                this.isAuthenticated = !!(this.accessToken && this.refreshToken && this.clientSecret);
            }
            storeCredentials() {
                if (this.accessToken) localStorage.setItem('slide_google_access_token', this.accessToken);
                if (this.refreshToken) localStorage.setItem('slide_google_refresh_token', this.refreshToken);
                if (this.clientSecret) localStorage.setItem('slide_google_client_secret', this.clientSecret);
            }
            clearStoredCredentials() {
                localStorage.removeItem('slide_google_access_token');
                localStorage.removeItem('slide_google_refresh_token');
                localStorage.removeItem('slide_google_client_secret');
            }
            async authenticate(clientSecret) {
                if (clientSecret) { this.clientSecret = clientSecret; this.storeCredentials(); }
                if (!this.clientSecret) { throw new Error('Client secret is required for Google Drive authentication'); }
                if (this.accessToken && this.refreshToken) { try { await this.makeApiCall('/files?pageSize=1'); this.isAuthenticated = true; return true; } catch (error) { /* continue */ } }
                return new Promise((resolve, reject) => {
                    const authUrl = this.buildAuthUrl();
                    const popup = window.open(authUrl, 'google-auth', 'width=500,height=600,scrollbars=yes,resizable=yes');
                    if (!popup) { reject(new Error('Popup blocked by browser')); return; }
                    const checkClosed = setInterval(() => { if (popup.closed) { clearInterval(checkClosed); reject(new Error('Authentication cancelled')); } }, 1000);
                    const messageHandler = async (event) => {
                        if (event.origin !== window.location.origin) return;
                        if (event.data.type === 'GOOGLE_AUTH_SUCCESS') {
                            clearInterval(checkClosed); window.removeEventListener('message', messageHandler); popup.close();
                            try { await this.exchangeCodeForTokens(event.data.code); this.isAuthenticated = true; resolve(true); } catch (error) { reject(error); }
                        } else if (event.data.type === 'GOOGLE_AUTH_ERROR') {
                            clearInterval(checkClosed); window.removeEventListener('message', messageHandler); popup.close(); reject(new Error(event.data.error));
                        }
                    };
                    window.addEventListener('message', messageHandler);
                });
            }
            buildAuthUrl() {
                const params = new URLSearchParams({ client_id: this.clientId, redirect_uri: this.redirectUri, response_type: 'code', scope: this.scope, access_type: 'offline', prompt: 'consent' });
                return `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;
            }
            async exchangeCodeForTokens(code) {
                const response = await fetch('https://oauth2.googleapis.com/token', {
                    method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({ client_id: this.clientId, client_secret: this.clientSecret, code: code, grant_type: 'authorization_code', redirect_uri: this.redirectUri })
                });
                if (!response.ok) { throw new Error('Token exchange failed'); }
                const tokens = await response.json();
                this.accessToken = tokens.access_token; this.refreshToken = tokens.refresh_token;
                this.storeCredentials();
            }
            async refreshAccessToken() {
                if (!this.refreshToken || !this.clientSecret) { throw new Error('No refresh token or client secret available'); }
                const response = await fetch('https://oauth2.googleapis.com/token', {
                    method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({ client_id: this.clientId, client_secret: this.clientSecret, refresh_token: this.refreshToken, grant_type: 'refresh_token' })
                });
                if (!response.ok) { throw new Error('Failed to refresh access token'); }
                const tokens = await response.json(); this.accessToken = tokens.access_token; this.storeCredentials(); return this.accessToken;
            }
            async makeApiCall(endpoint, options = {}, isJson = true) {
                if (!this.accessToken) { throw new Error('Not authenticated'); }
                const url = endpoint.startsWith('https://') ? endpoint : `${this.apiBase}${endpoint}`;
                const headers = { 'Authorization': `Bearer ${this.accessToken}`, ...options.headers };
                if(isJson) { headers['Content-Type'] = 'application/json'; }
                let response = await fetch(url, { ...options, headers });
                if (response.status === 401 && this.refreshToken && this.clientSecret) {
                    try {
                        await this.refreshAccessToken();
                        headers['Authorization'] = `Bearer ${this.accessToken}`;
                        response = await fetch(url, { ...options, headers });
                    } catch (refreshError) { this.isAuthenticated = false; this.clearStoredCredentials(); throw new Error('Authentication expired. Please reconnect.'); }
                }
                await utils.handleApiError(response, 'Google Drive API call failed');
                if (isJson) { return await response.json(); } return response;
            }
            async getAccessToken() { return this.accessToken; }
            async getFolders() { // Initial load: only items that are folders in 'root'
                this.currentParentId = 'root';
                const query = `'root' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`;
                const url = `/files?q=${encodeURIComponent(query)}&fields=files(id,name,mimeType,size,createdTime,modifiedTime,thumbnailLink,webContentLink,webViewLink,appProperties,parents)&pageSize=1000&orderBy=name`;
                const response = await this.makeApiCall(url);
                return response.files.map(file => ({
                    id: file.id, name: file.name, type: 'folder', mimeType: file.mimeType, 
                    createdTime: file.createdTime, modifiedTime: file.modifiedTime, hasChildren: true
                }));
            }
            async getFiles(folderId) { // Gets only files for the SlideSwipe core logic
                 return (await this.loadItemsInFolder(folderId)).filter(item => item.type === 'file' && CONFIG.imgTypes.includes(item.mimeType));
            }
            async drillIntoFolder(folder) {
                this.currentParentId = folder.id;
                return this.loadItemsInFolder(folder.id);
            }
            async loadItemsInFolder(folderId) {
                 const query = `'${folderId}' in parents and trashed=false and (mimeType='application/vnd.google-apps.folder' or mimeType contains 'image/')`;
                 const url = `/files?q=${encodeURIComponent(query)}&fields=files(id,name,mimeType,size,createdTime,modifiedTime,thumbnailLink,webContentLink,webViewLink,appProperties,parents)&pageSize=1000&orderBy=folder,name`;
                 const response = await this.makeApiCall(url);
                 return response.files.map(file => {
                     const isFolder = file.mimeType === 'application/vnd.google-apps.folder';
                     return {
                        id: file.id, name: file.name, type: isFolder ? 'folder' : 'file', mimeType: file.mimeType, size: file.size ? parseInt(file.size) : 0,
                        createdTime: file.createdTime, modifiedTime: file.modifiedTime, thumbnailLink: file.thumbnailLink,
                        webContentLink: file.webContentLink, webViewLink: file.webViewLink, appProperties: file.appProperties || {},
                        hasChildren: isFolder
                     };
                 });
            }
            async navigateToParent() {
                if (this.currentParentId === 'root') return this.getFolders();
                const fileResponse = await this.makeApiCall(`/files/${this.currentParentId}?fields=parents`);
                const parentId = fileResponse.parents && fileResponse.parents.length > 0 ? fileResponse.parents[0] : 'root';
                this.currentParentId = parentId;
                if (parentId === 'root') return this.getFolders();
                return this.loadItemsInFolder(parentId);
            }
            getCurrentPath() { 
                if (this.currentParentId === 'root') return 'My Drive';
                return `Current Folder: ${this.currentParentId.substring(0, 8)}...`;
            }
            canGoUp() { return this.currentParentId !== 'root'; }
            async updateFileMetadata(fileId, metadata) { await this.makeApiCall(`/files/${fileId}`, { method: 'PATCH', body: JSON.stringify({ appProperties: metadata }) }); return true; }
            async deleteFile(fileId) { await this.makeApiCall(`/files/${fileId}`, { method: 'PATCH', body: JSON.stringify({ trashed: true }) }); return true; }
            async disconnect() {
                this.isAuthenticated = false; this.accessToken = null; this.refreshToken = null; this.clientSecret = null;
                this.clearStoredCredentials();
            }
        }

        class OneDriveProvider extends BaseProvider {
            constructor() {
                super(); this.name = 'onedrive';
                this.apiBase = 'https://graph.microsoft.com/v1.0'; this.isAuthenticated = false;
                this.activeAccount = null; this.msalInstance = null;
                this.breadcrumb = [{ id: 'root', name: 'Files' }];
                this.initMSAL();
                const accounts = this.msalInstance.getAllAccounts();
                if (accounts.length > 0) { this.msalInstance.setActiveAccount(accounts[0]); this.activeAccount = accounts[0]; this.isAuthenticated = true; }
            }
            initMSAL() {
                const msalConfig = {
                    auth: { clientId: 'b407fd45-c551-4dbb-9da5-cab3a2c5a949', authority: 'https://login.microsoftonline.com/common', redirectUri: window.location.origin + window.location.pathname },
                    cache: { cacheLocation: 'localStorage' }
                };
                this.msalInstance = new msal.PublicClientApplication(msalConfig);
            }
            async authenticate() {
                try {
                    const accounts = this.msalInstance.getAllAccounts();
                    if (accounts.length > 0) { this.msalInstance.setActiveAccount(accounts[0]); this.activeAccount = accounts[0]; }
                    else { const loginResponse = await this.msalInstance.loginPopup({ scopes: ['Files.ReadWrite.All', 'User.Read'] });
                        this.activeAccount = loginResponse.account; this.msalInstance.setActiveAccount(this.activeAccount);
                    }
                    this.isAuthenticated = true; return true;
                } catch (error) { this.isAuthenticated = false; throw new Error(`Authentication failed: ${error.message}`); }
            }
            async getAccessToken() {
                if (!this.activeAccount) { throw new Error('No active account'); }
                try {
                    const response = await this.msalInstance.acquireTokenSilent({ scopes: ['Files.ReadWrite.All'], account: this.activeAccount });
                    return response.accessToken;
                } catch (silentError) {
                    if (silentError instanceof msal.InteractionRequiredAuthError) {
                        const response = await this.msalInstance.acquireTokenPopup({ scopes: ['Files.ReadWrite.All'], account: this.activeAccount });
                        return response.accessToken;
                    } throw silentError;
                }
            }
            async makeApiCall(endpoint, options = {}) {
                const accessToken = await this.getAccessToken();
                const url = endpoint.startsWith('https://') ? endpoint : `${this.apiBase}${endpoint}`;
                const headers = { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json', ...options.headers };
                const response = await fetch(url, { ...options, headers });
                if (response.status === 401) { throw new Error('TOKEN_EXPIRED'); }
                await utils.handleApiError(response, 'OneDrive API call failed');
                return response.json();
            }
            async loadItemsInParent(parentId) {
                const endpoint = parentId === 'root' ? '/me/drive/root/children' : `/me/drive/items/${parentId}/children`;
                const data = await this.makeApiCall(endpoint);
                return data.value.map(item => ({
                    id: item.id, name: item.name, type: item.folder ? 'folder' : 'file',
                    mimeType: item.file?.mimeType || 'unknown', size: item.size || 0,
                    createdTime: item.createdDateTime, modifiedTime: item.lastModifiedDateTime,
                    thumbnails: item.thumbnails && item.thumbnails.length > 0 ? { large: item.thumbnails[0].large } : null,
                    downloadUrl: item['@microsoft.graph.downloadUrl'],
                    hasChildren: item.folder && (item.folder.childCount || 0) > 0
                })).sort((a, b) => {
                    if (a.type === 'folder' && b.type !== 'folder') return -1;
                    if (a.type !== 'folder' && b.type === 'folder') return 1;
                    return a.name.localeCompare(b.name);
                });
            }
            async getFiles(folderId) { return (await this.loadItemsInParent(folderId)).filter(item => item.type === 'file' && CONFIG.imgTypes.includes(item.mimeType)); }
            async getFolders() {
                this.breadcrumb = [{ id: 'root', name: 'Files' }];
                return this.loadItemsInParent('root');
            }
            async drillIntoFolder(folder) {
                this.breadcrumb.push({ id: folder.id, name: folder.name });
                return await this.loadItemsInParent(folder.id);
            }
            async navigateToParent() {
                if (this.breadcrumb.length <= 1) return this.getFolders();
                this.breadcrumb.pop();
                const parentFolder = this.breadcrumb[this.breadcrumb.length - 1];
                return await this.loadItemsInParent(parentFolder.id);
            }
            getCurrentPath() { return this.breadcrumb.map(b => b.name).join(' / '); }
            canGoUp() { return this.breadcrumb.length > 1; }
            async updateFileMetadata(fileId, metadata) { debug('OneDrive metadata update skipped.', metadata); return true; }
            async deleteFile(fileId) { await this.makeApiCall(`/me/drive/items/${fileId}`, { method: 'DELETE' }); return true; }
            async disconnect() {
                this.isAuthenticated = false; this.activeAccount = null;
                if (this.msalInstance) {
                    const accounts = this.msalInstance.getAllAccounts();
                    if (accounts.length > 0) { await this.msalInstance.logoutPopup({ account: accounts[0] }); }
                }
            }
        }
        
        // ===== API module (Rewired) =====
        const api = {
            async validateToken(token, clientSecret) {
                if (appState.providerType === 'googledrive') {
                    if (!appState.provider) appState.provider = new GoogleDriveProvider();
                    await appState.provider.authenticate(clientSecret);
                    return true;
                } else if (appState.providerType === 'onedrive') {
                    if (!appState.provider) appState.provider = new OneDriveProvider();
                    await appState.provider.authenticate();
                    return true;
                }
                throw new Error('No provider selected');
            },
            async fetchFolders() {
                if (!appState.provider) throw new Error('Provider not connected');
                return appState.provider.getFolders();
            },
            async fetchFiles(folderId) {
                if (!appState.provider) throw new Error('Provider not connected');
                return appState.provider.getFiles(folderId);
            },
            async updateMetadata(fileId, metadata) {
                if (!appState.provider) throw new Error('Provider not connected');
                const file = appState.images.find(f => f.id === fileId);
                if (!file) throw new Error(`File not found: ${fileId}`);
                const newAppProperties = { ...(file.appProperties || {}), ...metadata };
                file.appProperties = newAppProperties;
                await appState.provider.updateFileMetadata(fileId, metadata);
                return metadata;
            },
            async deleteFile(fileId) {
                if (!appState.provider) throw new Error('Provider not connected');
                await appState.provider.deleteFile(fileId);
                const fileIndex = appState.images.findIndex(f => f.id === fileId);
                if (fileIndex !== -1) { appState.images.splice(fileIndex, 1); }
                CONFIG.stacks.forEach(stack => {
                    const index = appState.stacks[stack].findIndex(f => f.id === fileId);
                    if (index !== -1) { appState.stacks[stack].splice(index, 1); }
                });
                return true;
            }
        };


        // ===== App Management (Rewired) =====
        const appManager = {
            selectProvider(type) {
                appState.providerType = type;
                const isGoogle = type === 'googledrive';
                appState.provider = isGoogle ? new GoogleDriveProvider() : new OneDriveProvider();
                const providerStatusEl = $('provider-status');

                if (appState.provider.isAuthenticated) {
                    utils.showScreen('folder-screen');
                    folderManager.loadFolders();
                } else {
                    $('auth-title').textContent = isGoogle ? 'Google Drive' : 'OneDrive';
                    $('auth-subtitle').textContent = `Connect to ${isGoogle ? 'Google Drive' : 'OneDrive'}`;
                    $('gdrive-secret-container').classList.toggle('hidden', !isGoogle);
                    $('auth-button').textContent = `Connect ${isGoogle ? 'Drive' : 'OneDrive'}`;
                    $('auth-status').textContent = isGoogle ? 'Enter your client secret to continue' : 'Click to sign in with your Microsoft account';
                    $('auth-status').className = 'status info';
                    utils.showScreen('auth-screen');
                }
                providerStatusEl.textContent = `Selected ${isGoogle ? 'Google Drive' : 'OneDrive'}`;
                providerStatusEl.className = 'status info';
            },
            async authenticateCurrentUser() {
                const isGoogle = appState.providerType === 'googledrive';
                const { authButton, authStatus, gdriveClientSecret } = { authButton: $('auth-button'), authStatus: $('auth-status'), gdriveClientSecret: $('gdrive-client-secret') };
                authButton.disabled = true; authButton.textContent = 'Connecting...';
                authStatus.textContent = `Connecting to ${isGoogle ? 'Google Drive' : 'OneDrive'}...`;
                authStatus.className = 'status info';

                try {
                    const clientSecret = isGoogle ? gdriveClientSecret.value.trim() : null;
                    await api.validateToken(null, clientSecret);

                    authStatus.textContent = `✅ Connected to ${isGoogle ? 'Google Drive' : 'OneDrive'}!`;
                    authStatus.className = 'status success';
                    if (isGoogle) gdriveClientSecret.value = '';

                    setTimeout(() => {
                        utils.showScreen('folder-screen');
                        folderManager.loadFolders();
                    }, 1000);
                } catch (error) {
                    authStatus.textContent = `Authentication failed: ${error.message}`;
                    authStatus.className = 'status error';
                } finally {
                    authButton.disabled = false;
                    authButton.textContent = `Connect ${isGoogle ? 'Drive' : 'OneDrive'}`;
                }
            },
            async disconnect() {
                if (appState.provider) {
                    await appState.provider.disconnect();
                }
                appState.provider = null;
                appState.providerType = null;
                utils.showScreen('provider-screen');
                utils.toast('Disconnected from cloud provider', 'info');
            },
            async backToProviderSelection() {
                appState.provider = null;
                appState.providerType = null;
                utils.showScreen('provider-screen');
            },
            async handleFolderRefresh() {
                try {
                    const provider = appState.provider;
                    if (provider && typeof provider.canGoUp === 'function' && provider.canGoUp()) {
                        const items = await provider.navigateToParent();
                        folderManager.displayItems(items);
                    } else {
                        await folderManager.loadFolders();
                    }
                    folderManager.updateNavigation();
                } catch (error) {
                    utils.toast(`Folder navigation failed: ${error.message}`, 'error');
                }
            },
            async handleFolderDrill(folder) {
                 try {
                    const provider = appState.provider;
                    const items = await provider.drillIntoFolder(folder);
                    folderManager.displayItems(items);
                    folderManager.updateNavigation();
                } catch (error) {
                     utils.toast(`Error browsing folder: ${error.message}`, 'error');
                }
            },
            async handleFolderSelect(folderId, folderName) {
                appState.currentFolder.id = folderId;
                appState.currentFolder.name = folderName;
                $('header-filename').textContent = folderName;
                $('header-filename').title = folderName;
                
                await folderManager.selectFolder(appState.currentFolder);
                
                utils.showScreen('app-screen');
            }
        };

        // ===== Folder Management Module (Goji Logic) =====
        const folderManager = {
            async loadFolders() {
                const { folderList } = { folderList: $('folder-list') };
                folderList.innerHTML = `<div style="display: flex; align-items: center; justify-content: center; padding: 40px; color: rgba(255, 255, 255, 0.7);"><div class="spinner"></div><span>Loading folders...</span></div>`;
                try {
                    const items = await appState.provider.getFolders();
                    this.displayItems(items);
                    this.updateNavigation();
                } catch (error) {
                    utils.toast(`Error loading folders: ${error.message}`, 'error');
                    folderList.innerHTML = `<div style="text-align: center; padding: 40px; color: #ef4444;">
                                                <span>Failed to load folders.</span>
                                                <button id="retry-folders" class="folder-action-btn" style="margin-top: 15px;">Retry</button>
                                            </div>`;
                    $('retry-folders').addEventListener('click', () => this.loadFolders());
                }
            },
            displayItems(items) {
                const { folderList } = { folderList: $('folder-list') };
                folderList.innerHTML = '';

                if (!items || items.length === 0) {
                    folderList.innerHTML = `<div style="text-align: center; padding: 40px; color: rgba(255, 255, 255, 0.7);"><span>No folders or files found</span></div>`;
                    return;
                }
                
                // Group folders first, then files
                const folders = items.filter(i => i.type === 'folder');
                const files = items.filter(i => i.type === 'file' && CONFIG.imgTypes.includes(i.mimeType));
                
                [...folders, ...files].forEach(item => {
                    const isFolder = item.type === 'folder';
                    const div = document.createElement('div');
                    div.className = 'folder-item';
                    div.dataset.id = item.id;
                    div.dataset.name = item.name;

                    let dateInfo = item.modifiedTime ? new Date(item.modifiedTime).toLocaleDateString() : '';
                    if (!isFolder && item.size) { dateInfo += ` • ${utils.formatFileSize(item.size)}`; }
                    
                    const iconColor = isFolder ? 'var(--accent)' : 'rgba(16, 185, 129, 0.7)'; // Greenish for files
                    const iconPath = isFolder ? 'M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z' : 'M4 16l4-4 4 4 4-4 4 4M4 4h16v12a2 2 0 01-2 2H6a2 2 0 01-2-2V4z';
                    
                    div.innerHTML = `
                        <svg class="folder-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="color: ${iconColor};">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${iconPath}"></path>
                        </svg>
                        <div class="folder-info">
                            <div class="folder-name">${item.name}</div>
                            <div class="folder-date">${dateInfo}</div>
                        </div>
                        <div class="folder-actions">
                            ${isFolder ? `<button class="folder-action-btn drill-btn" data-action="drill" data-id="${item.id}" data-name="${item.name}">Browse →</button>` : ''}
                            <button class="folder-action-btn select-btn" data-action="select" data-id="${item.id}" data-name="${item.name}">${isFolder ? 'Select Folder' : 'Select'}</button>
                        </div>`;
                    folderList.appendChild(div);
                });

                document.querySelectorAll('#folder-list button').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const { action, id, name } = e.target.dataset;
                        
                        if (action === 'drill') {
                            await appManager.handleFolderDrill({ id, name });
                        } else if (action === 'select') {
                            await appManager.handleFolderSelect(id, name);
                        }
                    });
                });
            },
            updateNavigation() {
                const { folderSubtitle, folderRefreshButton } = { folderSubtitle: $('folder-subtitle'), folderRefreshButton: $('folder-refresh-button') };
                const provider = appState.provider;

                if (provider && typeof provider.getCurrentPath === 'function') {
                    folderSubtitle.textContent = `Current: ${provider.getCurrentPath()}`;
                }

                if (provider && typeof provider.canGoUp === 'function' && provider.canGoUp()) {
                    folderRefreshButton.textContent = '← Go Up';
                } else {
                    folderRefreshButton.textContent = 'Refresh';
                }
            },
            async selectFolder(folder) {
                utils.toast(`Loading images from: ${folder.name}`, 'info');
                try {
                    const files = await api.fetchFiles(folder.id);
                    appState.images = files;
                    
                    if (!files || files.length === 0) {
                        utils.toast('No images found in this folder', 'error');
                        return;
                    }
                    
                    appState.currentIdx = 0; 
                    stackManager.updateStacks();
                    imageViewer.display();
                    
                    utils.toast(`Loaded ${files.length} images`, 'success');
                } catch (error) {
                    utils.toast(`Error loading images for SlideSwipe: ${error.message}`, 'error');
                }
            }
        };

        // ===== SlideSwipe Core Logic (Retained/Adapted) =====
        const imageViewer = {
            display() {
                if (appState.images.length === 0 || appState.currentIdx < 0 || appState.currentIdx >= appState.images.length) {
                    $('center-image').src = ''; $('center-image').alt = 'No image selected';
                    $('header-filename').textContent = ''; $('empty-state').classList.remove('hidden'); return;
                }
                $('empty-state').classList.add('hidden');
                const currentFile = appState.images[appState.currentIdx];
                if (!currentFile) {
                    $('center-image').src = ''; $('center-image').alt = 'Image not available';
                    $('header-filename').textContent = ''; utils.toast('Error: Image not available', 'error'); return;
                }
                $('center-image').src = '';
                const primaryUrl = utils.getPreferredImageUrl(currentFile);
                $('center-image').src = primaryUrl;
                $('center-image').alt = currentFile.name || 'Image';
                const filename = currentFile.name || '';
                const nameWithoutExtension = filename.lastIndexOf('.') > 0 ? filename.substring(0, filename.lastIndexOf('.')) : filename;
                $('header-filename').textContent = nameWithoutExtension;
                this.applyZoom(); stackManager.updateContainers();
            },
            applyZoom() {
                const scale = appState.zoom / 100;
                $('center-image').style.transform = `translate(-50%, -50%) scale(${scale})`;
            },
            findNextImage() {
                const currentFile = appState.images[appState.currentIdx];
                if (!currentFile) return -1;
                const stackImages = appState.stacks[appState.currentStack];
                const currentPositionInStack = stackImages.findIndex(f => f.id === currentFile.id);
                if (currentPositionInStack !== -1) {
                    if (currentPositionInStack < stackImages.length - 1) {
                        const nextImageInStack = stackImages[currentPositionInStack + 1];
                        return appState.images.findIndex(f => f.id === nextImageInStack.id);
                    } else if (stackImages.length > 0) {
                        const firstImageInStack = stackImages[0];
                        return appState.images.findIndex(f => f.id === firstImageInStack.id);
                    }
                }
                if (stackImages.length > 0) {
                    const firstImageInStack = stackImages[0];
                    return appState.images.findIndex(f => f.id === firstImageInStack.id);
                }
                return -1;
            },
            moveToNext() {
                if (appState.images.length === 0) return;
                const nextIndex = this.findNextImage();
                if (nextIndex === -1) {
                    $('empty-state').classList.remove('hidden'); $('center-image').src = '';
                    $('center-image').alt = 'No images to review'; $('header-filename').textContent = '';
                } else {
                    appState.currentIdx = nextIndex; this.display();
                }
            }
        };
        const stackManager = {
            getMetadata(file) {
                const props = file.appProperties || {};
                let meta = {
                    slideboxStack: props.slideboxStack || 'in',
                    slideboxTags: props.slideboxTags ? props.slideboxTags.split(',') : []
                };
                if (meta.slideboxStack === 'needs_review') meta.slideboxStack = 'in';
                else if (meta.slideboxStack === 'reviewed') meta.slideboxStack = 'out';
                return meta;
            },
            updateStacks() {
                for (const stack of CONFIG.stacks) { appState.stacks[stack] = []; }
                appState.images.forEach(file => {
                    const meta = this.getMetadata(file);
                    const stack = meta.slideboxStack;
                    if (CONFIG.stacks.includes(stack)) { appState.stacks[stack].push(file); }
                    else { appState.stacks.in.push(file); }
                });
                this.updateCounts(); this.updateContainers();
            },
            updateCounts() {
                for (const stack of CONFIG.stacks) {
                    const count = appState.stacks[stack].length;
                    $$('.stack-count[data-stack="' + stack + '"]').forEach(el => el.textContent = count > 999 ? ':-)' : count);
                }
                if (appState.grid.stack && $('select-all-btn')) {
                    $('select-all-btn').textContent = appState.stacks[appState.grid.stack].length;
                }
            },
            updateContainers() {
                CONFIG.stacks.forEach(stack => {
                    const container = document.querySelector(`.ss-stack-container[data-stack="${stack}"]`);
                    if (!container) return; 
                    container.innerHTML = '';
                    appState.stacks[stack].forEach((file, index) => {
                        const div = document.createElement('div');
                        div.className = 'relative'; div.dataset.fileId = file.id; div.dataset.stackIndex = index;
                        const img = document.createElement('img'); img.className = 'ss-stack-thumbnail';
                        const currentFile = appState.images[appState.currentIdx];
                        if (currentFile && currentFile.id === file.id) { img.classList.add('selected'); }
                        utils.setImageSrc(img, file);
                        img.addEventListener('click', () => this.handleThumbnailClick(file));
                        div.appendChild(img); container.appendChild(div);
                    });
                });
            },
            handleThumbnailClick(file) {
                const index = appState.images.findIndex(f => f.id === file.id);
                if (index !== -1) { appState.currentIdx = index; imageViewer.display(); }
            },
            async moveFileToStack(fileId, targetStack) {
                const file = appState.images.find(f => f.id === fileId);
                if (!file) throw new Error('File not found');
                const meta = this.getMetadata(file);
                const currentStack = meta.slideboxStack;
                if (currentStack === targetStack) return file;
                try {
                    await api.updateMetadata(fileId, { slideboxStack: targetStack });
                    const currentStackIndex = appState.stacks[currentStack].findIndex(f => f.id === fileId);
                    if (currentStackIndex !== -1) { appState.stacks[currentStack].splice(currentStackIndex, 1); }
                    appState.stacks[targetStack].unshift(file);
                    file.appProperties = file.appProperties || {};
                    file.appProperties.slideboxStack = targetStack;
                    this.updateCounts(); this.updateContainers();
                    utils.toast(`Moved to ${targetStack}`, 'info');
                    return file;
                } catch (error) { utils.toast(`Failed to move file: ${error.message}`, 'error'); throw error; }
            },
            async addTagsToFile(fileId, tags) {
                const file = appState.images.find(f => f.id === fileId);
                if (!file) throw new Error(`File not found: ${fileId}`);
                const meta = this.getMetadata(file);
                const currentTags = meta.slideboxTags || [];
                const newTags = [...new Set([...currentTags, ...tags])];
                tags.forEach(tag => appState.tags.add(tag));
                try {
                    await api.updateMetadata(fileId, { slideboxTags: newTags.join(',') });
                    file.appProperties.slideboxTags = newTags.join(',');
                    utils.toast(`Tags added: ${tags.join(', ')}`, 'success');
                    return newTags;
                } catch (error) { utils.toast('Failed to add tags', 'error'); return currentTags; }
            }
        };
        const gridView = {
            open(stack) { 
                $('grid-modal').classList.remove('hidden');
            },
            close() { $('grid-modal').classList.add('hidden'); },
        };
        const modalManager = {
            toggle(id, show = true) { const el = $(id); if (!el) return; el.classList.toggle('hidden', !show); },
            show(id) { this.toggle(id, true); }, hide(id) { this.toggle(id, false); },
            setup() { 
                $$('.ss-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        const stack = tab.dataset.stack;
                        $$('.ss-tab').forEach(t => t.classList.remove('active'));
                        $$('.ss-tab-pane').forEach(p => p.classList.remove('active'));
                        tab.classList.add('active');
                        document.querySelector(`.ss-tab-pane[data-stack="${stack}"]`).classList.add('active');
                        appState.currentStack = stack;
                        if (appState.stacks[stack].length > 0) {
                            const firstFile = appState.stacks[stack][0];
                            const index = appState.images.findIndex(f => f.id === firstFile.id);
                            if (index !== -1) { appState.currentIdx = index; imageViewer.display(); }
                        } else {
                            $('empty-state').classList.remove('hidden'); $('center-image').src = ''; $('center-image').alt = 'No images in this stack'; $('header-filename').textContent = '';
                        }
                    });
                });

                $('header-tags-btn').addEventListener('click', () => {
                    if (appState.images.length === 0) return;
                    this.show('tag-modal'); 
                    utils.toast('Tag Modal needs re-wiring.', 'error');
                });
            }
        };
        const gestureHandler = {
            setup() {
                const container = $('center-image').parentElement;
                let touchStartX = 0, touchStartY = 0, touchEndX = 0, touchEndY = 0;
                container.addEventListener('touchstart', e => { touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY; });
                container.addEventListener('touchmove', e => {
                    touchEndX = e.touches[0].clientX; touchEndY = e.touches[0].clientY;
                });
                container.addEventListener('touchend', () => {
                    const deltaX = touchEndX - touchStartX; const deltaY = touchEndY - touchStartY;
                    const minSwipeDistance = 100;
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        if (Math.abs(deltaX) >= minSwipeDistance) {
                            if (deltaX > 0) this.handleSwipe('out'); else this.handleSwipe('in');
                        }
                    } else {
                        if (Math.abs(deltaY) >= minSwipeDistance) {
                            if (deltaY > 0) this.handleSwipe('trash'); else this.handleSwipe('priority');
                        }
                    }
                });
                document.addEventListener('keydown', e => {
                    if ($('app-screen')?.classList.contains('hidden')) return;
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    switch (e.key) {
                        case 'ArrowUp': this.handleSwipe('priority'); break;
                        case 'ArrowDown': this.handleSwipe('trash'); break;
                        case 'ArrowLeft': this.handleSwipe('in'); break;
                        case 'ArrowRight': this.handleSwipe('out'); break;
                        case 'Escape': if ($('grid-modal')?.classList.contains('hidden')) { gridView.close(); } break;
                    }
                });
            },
            async handleSwipe(targetStack) {
                if (appState.images.length === 0) return;
                const currentFile = appState.images[appState.currentIdx];
                if (!currentFile) return;
                const meta = stackManager.getMetadata(currentFile);
                const currentStack = meta.slideboxStack;
                if (currentStack === targetStack) { imageViewer.moveToNext(); return; }
                try { await stackManager.moveFileToStack(currentFile.id, targetStack); imageViewer.moveToNext(); } catch (error) { debug('Swipe error:', error); }
            }
        };

        // ===== Master Initialization =====
        function initApp() {
            // New Goji UI handlers
            $('google-drive-btn').addEventListener('click', () => appManager.selectProvider('googledrive'));
            $('onedrive-btn').addEventListener('click', () => appManager.selectProvider('onedrive'));
            $('auth-button').addEventListener('click', () => appManager.authenticateCurrentUser());
            $('auth-back-button').addEventListener('click', () => appManager.backToProviderSelection());
            
            // Folder refresh/go up button
            $('folder-refresh-button').addEventListener('click', () => appManager.handleFolderRefresh());
            
            $('folder-back-button').addEventListener('click', () => appManager.backToProviderSelection());
            $('folder-logout-button').addEventListener('click', () => appManager.disconnect());
            
            // Goji Folder list handler - Delegation to appManager
            $('folder-list').addEventListener('click', (e) => {
                const target = e.target.closest('[data-id]');
                const actionBtn = e.target.closest('button');
                if (target && actionBtn) {
                    const { id, name } = actionBtn.dataset;
                    if (actionBtn.dataset.action === 'drill') {
                        appManager.handleFolderDrill({ id, name });
                    } else if (actionBtn.dataset.action === 'select') {
                        appManager.handleFolderSelect(id, name);
                    }
                }
            });

            // SlideSwipe handlers
            $('select-another-folder').addEventListener('click', () => { utils.showScreen('folder-screen'); folderManager.loadFolders(); });
            $('header-grid-btn').addEventListener('click', () => { gridView.open(appState.currentStack); });
            $('close-grid')?.addEventListener('click', () => gridView.close());
            $('image-zoom').addEventListener('input', () => {
                 appState.zoom = parseInt($('image-zoom').value); $('zoom-value').textContent = `${appState.zoom}%`;
                 imageViewer.applyZoom();
            });
            modalManager.setup();
            gestureHandler.setup();

            // Start the Goji provider selection flow
            utils.showScreen('provider-screen');
        }

        if (window.location.search.includes('code=') || window.location.search.includes('error=')) {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code'); const error = urlParams.get('error');
            if (window.opener) {
                if (error) { window.opener.postMessage({ type: 'GOOGLE_AUTH_ERROR', error: error }, window.location.origin);
                } else if (code) { window.opener.postMessage({ type: 'GOOGLE_AUTH_SUCCESS', code: code }, window.location.origin); }
                window.close();
            }
        }
        window.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>