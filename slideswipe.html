<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>SlideSwipe - Image Organizer v1.3n</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://alcdn.msauth.net/browser/2.28.1/js/msal-browser.min.js"></script>
    <style>
        /* ===== Base Styles ===== */
        body {
            margin: 0;
            padding: 0;
            overscroll-behavior: none;
            overflow: hidden;
        }

        /* ===== Goji.html Screen/Card/Button Styles translated to match Tailwind aesthetic ===== */
        .screen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%); /* Dark background from Goji */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .card {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 1rem;
            padding: 2.5rem;
            text-align: center;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .title { color: #1f2937; font-size: 1.5rem; font-weight: 600; margin-bottom: 0.5rem; }
        .subtitle { color: #4b5563; font-size: 1rem; margin-bottom: 1rem; }

        .input-text {
            width: 100%; padding: 0.75rem 1rem; border: 1px solid #d1d5db; border-radius: 0.5rem;
            background: #f9fafb; color: #111827; font-size: 0.875rem; margin-bottom: 1rem;
        }
        .input-text:focus {
            outline: none; border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .provider-button {
            display: flex; align-items: center; justify-content: center; gap: 0.75rem;
            background: #ffffff; border: 1px solid #d1d5db;
            border-radius: 0.75rem; padding: 1rem; margin-bottom: 1rem; color: #1f2937;
            font-size: 1rem; font-weight: 500; cursor: pointer; transition: all 0.3s ease;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .provider-button:hover {
            background: #f9fafb; border-color: #3b82f6;
            transform: translateY(-1px); box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        }

        .status-info { background: #dbeafe; color: #1e40af; border: 1px solid #93c5fd; padding: 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; }
        .status-success { background: #d1fae5; color: #065f46; border: 1px solid #6ee7b7; padding: 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; }
        .status-error { background: #fee2e2; color: #991b1b; border: 1px solid #fca5a5; padding: 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; }

        /* Folder List Items from Goji */
        .folder-list-item {
            display: flex; align-items: center; padding: 0.75rem 1rem; margin-bottom: 0.5rem;
            background: #f9fafb; border: 1px solid #e5e7eb;
            border-radius: 0.75rem; cursor: pointer; transition: all 0.2s ease; color: #1f2937; justify-content: space-between;
        }
        .folder-list-item:hover {
            background: #f3f4f6; border-color: #3b82f6; transform: translateY(-1px);
        }
        .folder-icon { width: 1.25rem; height: 1.25rem; margin-right: 0.75rem; color: #f59e0b; }
        .folder-info-text { flex: 1; text-align: left; }
        .folder-name-text { font-weight: 500; margin-bottom: 2px; }
        .folder-date-text { font-size: 0.75rem; color: #6b7280; }

        /* ===== Component Styles (SlideSwipe original) ===== */
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s;
            outline: none;
            border: none;
        }
        .btn-primary, .btn-danger { color: white; }
        .btn-primary { background-color: #3b82f6; }
        .btn-primary:hover { background-color: #2563eb; }
        .btn-secondary { background-color: #e5e7eb; color: #4b5563; }
        .btn-secondary:hover { background-color: #d1d5db; }
        .btn-danger { background-color: #ef4444; }
        .btn-danger:hover { background-color: #dc2626; }

        .pill {
            border-radius: 9999px;
            font-size: 0.875rem;
            transition: background-color 0.2s;
        }
        .pill-counter {
            background-color: #e5e7eb;
            color: #4b5563;
            padding: 0.125rem 0.5rem;
            font-weight: 500;
            display: inline-block;
            min-width: 36px;
            text-align: center;
            cursor: pointer;
        }
        .pill-counter:hover { background-color: #d1d5db; }
        /* ... other original SlideSwipe styles ... */
        .header-pill {
            background-color: #e0e7ff;
            color: #3730a3;
            padding: 6px 16px;
            font-size: 14px;
            cursor: pointer;
        }
        .header-pill:hover { background-color: #c7d2fe; }
        .folder-pill {
            background-color: #e0e7ff;
            color: #3730a3;
            padding: 4px 12px;
            font-size: 13px;
            cursor: pointer;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }
        .folder-pill:hover { background-color: #c7d2fe; }

        .stack-container { min-height: 100px; max-height: 200px; overflow-y: auto; }
        .image-container {
            position: relative;
            width: 100%;
            height: 60vh;
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }
        .center-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 100%;
            max-height: 100%;
            pointer-events: none;
            transition: transform 0.2s ease;
        }
        .stack-thumbnail {
            width: 90px;
            height: 90px;
            object-fit: cover;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
        }
        .stack-thumbnail.selected { border-color: #3b82f6; transform: scale(1.05); }

        .grid-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 16px; }
        .grid-item { position: relative; aspect-ratio: 1; overflow: hidden; border-radius: 8px; cursor: pointer; }
        .grid-image { width: 100%; height: 100%; object-fit: cover; }
        .grid-item.selected { box-shadow: 0 0 0 4px #3b82f6; }

        .swipe-indicator {
            position: absolute; font-size: 48px; color: white;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            pointer-events: none; opacity: 0; transition: opacity 0.3s ease;
        }
        .swipe-up, .swipe-down { left: 50%; transform: translateX(-50%); }
        .swipe-left, .swipe-right { top: 50%; transform: translateY(-50%); }
        .swipe-up { top: 20px; }
        .swipe-down { bottom: 20px; }
        .swipe-left { left: 20px; }
        .swipe-right { right: 20px; }

        .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 20px; border-radius: 8px; color: white; font-weight: 500; opacity: 0; transition: opacity 0.3s ease; z-index: 1000; }
        .toast.success { background-color: #10b981; }
        .toast.error { background-color: #ef4444; }
        .toast.show { opacity: 1; }

        .zoom-controls { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(255, 255, 255, 0.8); border-radius: 8px; padding: 8px 12px; display: flex; align-items: center; z-index: 10; }

        .main-container { display: flex; flex-direction: column; height: calc(100vh - 50px - 26px); }
        .center-stage {
            flex: 1;
            min-height: 250px;
            position: relative;
            border: none;
        }
        .stacks-panel {
            height: 250px;
            position: relative;
            background: white;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border: none;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid #e5e7eb;
            padding: 0 1rem;
            justify-content: center;
        }
        .tab { padding: 0.75rem 1rem; cursor: pointer; border-bottom: 2px solid transparent; position: relative; min-width: 80px; text-align: center; }
        .tab-label { display: block; margin-bottom: 4px; }
        .tab.active { border-bottom-color: #3b82f6; color: #3b82f6; }
        .tab.active .pill-counter { background-color: #bfdbfe; color: #1e40af; }
        .tab-content { flex: 1; overflow: hidden; position: relative; }
        .tab-pane { position: absolute; inset: 0; padding: 1rem; overflow-y: auto; display: none; }
        .tab-pane.active { display: block; }

        .version-strip {
            background-color: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
            padding: 6px 16px;
            padding-left: env(safe-area-inset-left, 16px);
            padding-right: env(safe-area-inset-right, 16px);
            padding-top: env(safe-area-inset-top, 6px);
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 14px;
            position: relative;
        }
        .version-strip-logo { font-weight: 600; color: #374151; }
        .version-number { color: #6b7280; font-size: 12px; }
        .header-filename { font-size: 12px; color: #374151; max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; text-align: center; flex: 1; margin: 0 12px; }

        footer {
            background-color: #4b5563;
            color: white;
            text-align: center;
            padding: 6px 0;
            font-size: 12px;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 40;
            padding-bottom: env(safe-area-inset-bottom, 6px);
        }

        .privacy-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 100vh;
            background-color: rgba(255, 255, 255, 0.97);
            backdrop-filter: blur(10px);
            padding: 20px;
            transform: translateY(-100%);
            transition: transform 0.3s ease;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
        }
        .privacy-panel.show { transform: translateY(0); }
        .privacy-panel-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 20px;
            border-bottom: 1px solid #e5e7eb;
        }
        .privacy-panel-datetime { font-size: 18px; font-weight: 500; color: #374151; }
        .privacy-panel-close { cursor: pointer; padding: 8px; border-radius: 8px; transition: background-color 0.2s ease; }
        .privacy-panel-close:hover { background-color: #f3f4f6; }
        .privacy-panel-close svg { width: 24px; height: 24px; color: #6b7280; }

        @media screen and (orientation: landscape) and (max-width: 1024px) {
            .main-container { flex-direction: row; height: calc(100vh - 32px - 26px); }
            .center-stage { width: 60%; height: 100%; border-right: none; }
            .stacks-panel { width: 40%; height: 100%; border: none; }
            .image-container { height: 100%; }
        }
        @media screen and (orientation: portrait) and (max-width: 1024px) {
            .version-strip, header { position: sticky; top: 0; z-index: 40; }
        }

        .metadata-panel {
            position: absolute;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 12px;
            z-index: 100;
            min-width: 250px; max-width: 300px;
        }
        .metadata-close {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }
        .metadata-close:hover { background-color: #f3f4f6; }
        .metadata-close svg { width: 14px; height: 14px; color: #6b7280; }
    </style>
</head>
<body class="bg-gray-100 font-sans min-h-screen">
    <div class="version-strip">
        <span class="version-strip-logo">SlideSwipe</span>
        <span id="version-folder-pill" class="folder-pill"></span>
        <span class="version-number">v1.3n</span>
    </div>

    <div class="screen" id="provider-screen">
        <div class="card">
            <h1 class="title" style="font-size: 2rem;">SlideSwipe</h1>
            <p class="subtitle">Select your cloud storage provider</p>
            <button class="provider-button" id="google-drive-btn">
                <svg style="width: 1.25rem; height: 1.25rem;" viewBox="0 0 24 24"><path fill="currentColor" d="M6.28 7L9.69 1h4.62l3.41 6zM16.05 7H7.95l4.05 7zM11.76 15h8.58L24 21H7.05z"/></svg>
                Google Drive
            </button>
            <button class="provider-button" id="onedrive-btn">
                <svg style="width: 1.25rem; height: 1.25rem;" viewBox="0 0 24 24"><path fill="currentColor" d="M17.75 8C16.82 8 16 8.82 16 9.75S16.82 11.5 17.75 11.5s1.75-.82 1.75-1.75S18.68 8 17.75 8zM12.25 10.5h-5c-.93 0-1.75.82-1.75 1.75s.82 1.75 1.75 1.75h5c.93 0 1.75-.82 1.75-1.75s-.82-1.75-1.75-1.75zM12 18.5c-.93 0-1.75.82-1.75 1.75s.82 1.75 1.75 1.75h5c.93 0 1.75-.82 1.75-1.75s-.82-1.75-1.75-1.75h-5zM12 15.5H7.25c-.93 0-1.75.82-1.75 1.75s.82 1.75 1.75 1.75H12c.93 0 1.75-.82 1.75-1.75s-.82-1.75-1.75-1.75zM15.5 12.5H7.25c-.93 0-1.75.82-1.75 1.75s.82 1.75 1.75 1.75H15.5c.93 0 1.75-.82 1.75-1.75s-.82-1.75-1.75-1.75zM12.25 7.5c-.93 0-1.75.82-1.75 1.75s.82 1.75 1.75 1.75h5c.93 0 1.75-.82 1.75-1.75s-.82-1.75-1.75-1.75h-5zM17.75 5.5c-.93 0-1.75.82-1.75 1.75s.82 1.75 1.75 1.75s1.75-.82 1.75-1.75s-.82-1.75-1.75-1.75zM12 2.5c-.93 0-1.75.82-1.75 1.75s.82 1.75 1.75 1.75h5c.93 0 1.75-.82 1.75-1.75s-.82-1.75-1.75-1.75h-5z"/></svg>
                OneDrive
            </button>
            <div id="provider-status" class="status-info mt-4">Choose your preferred cloud storage</div>
        </div>
    </div>

    <div class="screen hidden" id="auth-screen">
        <div class="card">
            <h1 class="title" id="auth-title">Provider</h1>
            <p class="subtitle" id="auth-subtitle">Connect to your account</p>
            <div id="gdrive-secret-container" class="hidden mb-4">
                <input type="password" id="gdrive-client-secret" class="input-text" placeholder="Enter Google Client Secret" style="margin-bottom: 0;">
            </div>
            <button class="btn btn-primary w-full mb-3" id="auth-button">Connect</button>
            <button class="btn btn-secondary w-full" id="auth-back-button">← Back</button>
            <div id="auth-status" class="status-info mt-4"></div>
        </div>
    </div>

    <div class="screen hidden" id="folder-screen">
        <div class="card" style="max-height: 90vh; display: flex; flex-direction: column;">
            <h2 class="title" id="folder-title">Select Folder</h2>
            <div class="subtitle" id="folder-subtitle">Choose a folder containing images</div>
            <div class="flex-1 overflow-y-auto mb-4 p-2" id="folder-list">
                <div class="flex items-center justify-center py-8 text-gray-400">
                    <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span>Loading folders...</span>
                </div>
            </div>
            <div class="flex gap-2">
                <button class="btn btn-secondary flex-1" id="folder-refresh-button">Refresh</button>
                <button class="btn btn-secondary flex-1" id="folder-back-button">← Provider</button>
                <button class="btn btn-danger flex-1" id="folder-logout-button">Disconnect</button>
            </div>
        </div>
    </div>

    <div id="privacy-panel" class="privacy-panel">
        <div class="privacy-panel-content">
            <div id="privacy-datetime" class="privacy-panel-datetime"></div>
            <div class="privacy-panel-close" id="privacy-panel-close">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18 6L6 18M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
        </div>
        <div class="flex-1 p-4 overflow-auto">
            <h2 class="text-xl font-semibold mb-4">Privacy Mode</h2>
            <p class="mb-4">Your screen is now covered to protect sensitive information.</p>
            <p>Tap the X button to return to your work.</p>
        </div>
    </div>

    <div id="app-screen" class="hidden">
        <header class="bg-white shadow-sm">
            <div class="container mx-auto px-4 py-3 flex items-center justify-between">
                <button id="header-tags-btn" class="header-pill">Tags</button>
                <span id="header-filename" class="header-filename"></span>
                <button id="header-grid-btn" class="header-pill">Grid</button>
            </div>
        </header>
        <div class="main-container">
            <div class="center-stage bg-white rounded-lg shadow-md m-4 mb-0">
                <div class="image-container">
                    <div class="zoom-controls">
                        <label for="image-zoom" class="text-sm text-gray-700 mr-2">Zoom:</label>
                        <input type="range" id="image-zoom" min="50" max="150" value="100" class="w-24">
                        <span id="zoom-value" class="text-sm text-gray-700 ml-2">100%</span>
                    </div>
                    <img id="center-image" class="center-image" src="" alt="No image selected">
                    <div class="swipe-indicator swipe-up">⬆️</div>
                    <div class="swipe-indicator swipe-down">⬇️</div>
                    <div class="swipe-indicator swipe-left">⬅️</div>
                    <div class="swipe-indicator swipe-right">➡️</div>
                    <div id="empty-state" class="absolute inset-0 flex items-center justify-center bg-gray-100 hidden">
                        <div class="text-center">
                            <p class="text-gray-500 mb-2">No images to review</p>
                            <button id="select-another-folder" class="btn btn-primary">Select Another Folder</button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="stacks-panel" class="stacks-panel mx-4 mb-4 rounded-lg shadow-md">
                <div class="tabs">
                    <div class="tab active" data-stack="in">
                        <span class="tab-label">In</span>
                        <span class="pill-counter stack-count" data-stack="in">0</span>
                    </div>
                    <div class="tab" data-stack="out">
                        <span class="tab-label">Out</span>
                        <span class="pill-counter stack-count" data-stack="out">0</span>
                    </div>
                    <div class="tab" data-stack="priority">
                        <span class="tab-label">Priority</span>
                        <span class="pill-counter stack-count" data-stack="priority">0</span>
                    </div>
                    <div class="tab" data-stack="trash">
                        <span class="tab-label">Trash</span>
                        <span class="pill-counter stack-count" data-stack="trash">0</span>
                    </div>
                </div>
                <div class="tab-content">
                    <div class="tab-pane active" data-stack="in">
                        <div class="stack-container flex flex-wrap gap-2" data-stack="in"></div>
                    </div>
                    <div class="tab-pane" data-stack="out">
                        <div class="stack-container flex flex-wrap gap-2" data-stack="out"></div>
                    </div>
                    <div class="tab-pane" data-stack="priority">
                        <div class="stack-container flex flex-wrap gap-2" data-stack="priority"></div>
                    </div>
                    <div class="tab-pane" data-stack="trash">
                        <div class="stack-container flex flex-wrap gap-2" data-stack="trash"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="grid-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
        <div class="bg-white rounded-lg shadow-md w-full h-full max-w-6xl max-h-[90vh] m-4 flex flex-col">
            <div class="sticky top-0 bg-white z-10 border-b border-gray-200">
                <div class="p-4 border-b border-gray-100">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-3">
                            <h2 id="grid-title" class="text-xl font-medium text-gray-800">Grid View</h2>
                            <button id="select-all-btn" class="pill-counter text-sm font-medium cursor-pointer">0</button>
                        </div>
                        <button id="close-grid" class="text-gray-500 hover:text-gray-700 transition duration-200">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="px-4 py-2 border-b border-gray-100 min-h-[48px] flex items-center">
                    <div id="selection-info" class="flex items-center gap-2">
                        <span id="selection-count" class="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm flex items-center gap-2">
                            <span id="selection-text">0 selected</span>
                            <button id="deselect-all-btn" class="ml-1 hover:text-blue-900">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        </span>
                    </div>
                </div>
                <div class="px-4 py-3 border-b border-gray-100">
                    <div class="flex flex-wrap gap-4 items-center justify-between">
                        <div class="flex items-center">
                            <span class="mr-2 text-sm text-gray-600">Grid Size:</span>
                            <input type="range" id="grid-size" min="1" max="10" value="4" class="w-24">
                            <span id="grid-size-value" class="ml-2 text-sm text-gray-600">4</span>
                        </div>
                        <div class="flex gap-2">
                            <button id="tag-selected" class="btn btn-primary py-1 px-3 text-sm hidden">Tag</button>
                            <button id="move-selected" class="btn btn-primary py-1 px-3 text-sm hidden">Move</button>
                            <button id="delete-selected" class="btn btn-danger py-1 px-3 text-sm hidden">Delete</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="flex-1 overflow-y-auto p-4">
                <div id="grid-container" class="grid-container"></div>
            </div>
        </div>
    </div>

    <div id="move-modal" class="modal hidden">
        <div class="bg-white rounded-lg shadow-md p-6 w-full max-w-md">
            <h3 class="text-lg font-medium text-gray-800 mb-4">Move to Stack</h3>
            <div class="space-y-2 mb-4">
                <button class="move-option w-full text-left px-4 py-2 rounded-md hover:bg-gray-100" data-stack="in">In</button>
                <button class="move-option w-full text-left px-4 py-2 rounded-md hover:bg-gray-100" data-stack="out">Out</button>
                <button class="move-option w-full text-left px-4 py-2 rounded-md hover:bg-gray-100" data-stack="priority">Priority</button>
                <button class="move-option w-full text-left px-4 py-2 rounded-md hover:bg-gray-100" data-stack="trash">Trash</button>
            </div>
            <div class="flex justify-end">
                <button id="cancel-move" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div id="tag-modal" class="modal hidden">
        <div class="bg-white rounded-lg shadow-md p-6 w-full max-w-md">
            <h3 class="text-lg font-medium text-gray-800 mb-4">Add Tags</h3>
            <div class="mb-4">
                <label for="tag-input" class="block text-sm font-medium text-gray-700 mb-1">Enter tags (comma separated)</label>
                <input type="text" id="tag-input" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="nature, landscape, vacation">
            </div>
            <div id="tag-suggestions" class="flex flex-wrap gap-2 mb-4"></div>
            <div class="flex justify-end">
                <button id="cancel-tag" class="btn btn-secondary mr-2">Cancel</button>
                <button id="apply-tag" class="btn btn-primary">Apply</button>
            </div>
        </div>
    </div>

    <div id="delete-modal" class="modal hidden">
        <div class="bg-white rounded-lg shadow-md p-6 w-full max-w-md">
            <h3 class="text-lg font-medium text-gray-800 mb-4">Confirm Delete</h3>
            <p id="delete-message" class="text-gray-600 mb-4">Are you sure you want to move the selected images to Trash?</p>
            <div class="flex justify-end">
                <button id="cancel-delete" class="btn btn-secondary mr-2">Cancel</button>
                <button id="confirm-delete" class="btn btn-danger">Confirm</button>
            </div>
        </div>
    </div>

    <div id="metadata-panel" class="metadata-panel hidden">
        <div class="metadata-close" id="metadata-close">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M18 6L6 18M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </div>
        <h4 class="text-sm font-medium text-gray-800 mb-2 pr-6">File Details</h4>
        <div id="metadata-content" class="text-xs text-gray-600 space-y-1"></div>
    </div>

    <div id="toast" class="toast"></div>

    <footer id="app-footer">
        Made with ❤️ by SlideSwipe Team
    </footer>

    <script>
        // ===== Helper Functions =====
        const $ = id => document.getElementById(id);
        const $$ = selector => document.querySelectorAll(selector);

        const DEBUG = false;
        const debug = (...args) => {
            if (DEBUG) console.log(...args);
        };

        // ===== Configuration =====
        const CONFIG = {
            imgTypes: ['image/png', 'image/jpeg', 'image/webp', 'image/gif'],
            stacks: ['in', 'out', 'priority', 'trash'],
            defaults: {
                zoom: 100,
                panelHeight: 250
            }
        };

        // ===== Application State =====
        const appState = {
            providerType: null, // 'googledrive' or 'onedrive'
            provider: null,
            folder: {id: null, name: ''},
            images: [],
            currentIdx: 0,
            currentStack: 'in',
            stacks: { in: [], out: [], priority: [], trash: [] },
            grid: { stack: null, selected: [] },
            tags: new Set(),
            zoom: CONFIG.defaults.zoom,
            panelHeight: CONFIG.defaults.panelHeight,
            privacyTimer: null
        };

        // ===== Core utility module =====
        const utils = {
            showScreen(id) {
                ['provider-screen', 'auth-screen', 'folder-screen', 'app-screen'].forEach(screen =>
                    $(screen).classList.toggle('hidden', screen !== id)
                );

                if (id !== 'auth-screen') this.enableImmersiveMode();
                if (id === 'app-screen') this.applyOptimalLayout();
            },

            toast(message, type = 'success') {
                const toast = $('toast');
                toast.textContent = message;
                toast.className = `toast ${type}`;
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), 3000);
            },

            enableImmersiveMode() {
                if (window.innerWidth < 768) {
                    setTimeout(() => window.scrollTo(0, 1), 100);
                }
            },

            applyOptimalLayout() {
                const isLandscape = window.innerWidth > window.innerHeight;
                const isTablet = window.innerWidth >= 768;

                const container = document.querySelector('.main-container');
                const stage = document.querySelector('.center-stage');
                const panel = $('stacks-panel');

                if (isLandscape) {
                    container.style.flexDirection = 'row';
                    stage.style.width = isTablet ? '70%' : '60%';
                    panel.style.width = isTablet ? '30%' : '40%';
                    stage.style.height = '100%';
                    panel.style.height = '100%';
                    panel.style.borderRight = '1px solid #e5e7eb';
                    panel.style.borderTop = 'none';
                } else {
                    container.style.flexDirection = 'column';
                    stage.style.height = isTablet ? '70%' : '60%';
                    panel.style.height = isTablet ? '30%' : '40%';
                    stage.style.width = '100%';
                    panel.style.width = '100%';
                    panel.style.borderTop = '1px solid #e5e7eb';
                    panel.style.borderRight = 'none';
                }
            },

            updatePrivacyTime() {
                const now = new Date();
                const options = {
                    weekday: 'long', year: 'numeric', month: 'long', day: 'numeric',
                    hour: '2-digit', minute: '2-digit', second: '2-digit'
                };
                $('privacy-datetime').textContent = now.toLocaleDateString('en-US', options);
            },

            setImageSrc(img, file) {
                const thumbnailLink = appState.providerType === 'googledrive'
                    ? (file.thumbnailLink ? file.thumbnailLink.replace('=s220', '=s400') : file.webContentLink)
                    : (file.thumbnails ? file.thumbnails.large.url : file.downloadUrl);

                img.src = thumbnailLink || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="150" height="150" viewBox="0 0 150 150" fill="none"%3E%3Crect width="150" height="150" fill="%23E5E7EB"/%3E%3Cpath d="M65 60H85V90H65V60Z" fill="%239CA3AF"/%3E%3Ccircle cx="75" cy="45" r="10" fill="%239CA3AF"/%3E%3C/svg%3E';
                img.alt = file.name || 'Image';
                img.loading = 'lazy';
                img.addEventListener('error', function() {
                    this.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="150" height="150" viewBox="0 0 150 150" fill="none"%3E%3Crect width="150" height="150" fill="%23E5E7EB"/%3E%3Cpath d="M65 60H85V90H65V60Z" fill="%239CA3AF"/%3E%3Ccircle cx="75" cy="45" r="10" fill="%239CA3AF"/%3E%3C/svg%3E';
                    this.alt = 'Image not available';
                });
            },

            async handleApiError(response, defaultMsg) {
                if (response.ok) return response;
                const text = await response.text();
                try {
                    const data = JSON.parse(text);
                    throw new Error(data.error?.message || defaultMsg);
                } catch {
                    throw new Error(`${defaultMsg}: ${response.status} ${response.statusText}`);
                }
            },
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            },
        };
        
        // ===== Provider Abstraction (from goji.html) =====
        class BaseProvider {
            constructor() { if (this.constructor === BaseProvider) { throw new Error("Abstract classes can't be instantiated."); } }
            async authenticate() { throw new Error("Method 'authenticate()' must be implemented."); }
            async disconnect() { throw new Error("Method 'disconnect()' must be implemented."); }
            async getFolders() { throw new Error("Method 'getFolders()' must be implemented."); }
            async getFiles(folderId) { throw new Error("Method 'getFiles(folderId)' must be implemented."); }
            async drillIntoFolder(folder) { throw new Error("Method 'drillIntoFolder(folder)' must be implemented."); }
            async navigateToParent() { throw new Error("Method 'navigateToParent()' must be implemented."); }
            getCurrentPath() { return 'Root'; }
            canGoUp() { return false; }
            async updateFileMetadata(fileId, metadata) { throw new Error("Method 'updateFileMetadata(fileId, metadata)' must be implemented."); }
            async deleteFile(fileId) { throw new Error("Method 'deleteFile(fileId)' must be implemented."); }
        }

        class GoogleDriveProvider extends BaseProvider {
            constructor() {
                super(); this.name = 'googledrive';
                this.clientId = '567988062464-fa6c1ovesqeudqs5398vv4mbo6q068p9.apps.googleusercontent.com';
                this.redirectUri = window.location.origin + window.location.pathname;
                this.scope = 'https://www.googleapis.com/auth/drive.file'; // Use 'drive.file' for less permission
                this.apiBase = 'https://www.googleapis.com/drive/v3';
                this.accessToken = null; this.refreshToken = null; this.clientSecret = null;
                this.isAuthenticated = false; this.currentParentId = 'root';
                this.loadStoredCredentials();
            }
            loadStoredCredentials() {
                this.accessToken = localStorage.getItem('slide_google_access_token');
                this.refreshToken = localStorage.getItem('slide_google_refresh_token');
                this.clientSecret = localStorage.getItem('slide_google_client_secret');
                this.isAuthenticated = !!(this.accessToken && this.refreshToken && this.clientSecret);
            }
            storeCredentials() {
                if (this.accessToken) localStorage.setItem('slide_google_access_token', this.accessToken);
                if (this.refreshToken) localStorage.setItem('slide_google_refresh_token', this.refreshToken);
                if (this.clientSecret) localStorage.setItem('slide_google_client_secret', this.clientSecret);
            }
            clearStoredCredentials() {
                localStorage.removeItem('slide_google_access_token');
                localStorage.removeItem('slide_google_refresh_token');
                localStorage.removeItem('slide_google_client_secret');
            }
            async authenticate(clientSecret) {
                if (clientSecret) { this.clientSecret = clientSecret; this.storeCredentials(); }
                if (!this.clientSecret) { throw new Error('Client secret is required for Google Drive authentication'); }
                if (this.accessToken && this.refreshToken) { try { await this.makeApiCall('/files?pageSize=1'); this.isAuthenticated = true; return true; } catch (error) { /* continue */ } }
                return new Promise((resolve, reject) => {
                    const authUrl = this.buildAuthUrl();
                    const popup = window.open(authUrl, 'google-auth', 'width=500,height=600,scrollbars=yes,resizable=yes');
                    if (!popup) { reject(new Error('Popup blocked by browser')); return; }
                    const checkClosed = setInterval(() => { if (popup.closed) { clearInterval(checkClosed); reject(new Error('Authentication cancelled')); } }, 1000);
                    const messageHandler = async (event) => {
                        if (event.origin !== window.location.origin) return;
                        if (event.data.type === 'GOOGLE_AUTH_SUCCESS') {
                            clearInterval(checkClosed); window.removeEventListener('message', messageHandler); popup.close();
                            try { await this.exchangeCodeForTokens(event.data.code); this.isAuthenticated = true; resolve(true); } catch (error) { reject(error); }
                        } else if (event.data.type === 'GOOGLE_AUTH_ERROR') {
                            clearInterval(checkClosed); window.removeEventListener('message', messageHandler); popup.close(); reject(new Error(event.data.error));
                        }
                    };
                    window.addEventListener('message', messageHandler);
                });
            }
            buildAuthUrl() {
                const params = new URLSearchParams({ client_id: this.clientId, redirect_uri: this.redirectUri, response_type: 'code', scope: this.scope, access_type: 'offline', prompt: 'consent' });
                return `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;
            }
            async exchangeCodeForTokens(code) {
                const response = await fetch('https://oauth2.googleapis.com/token', {
                    method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({ client_id: this.clientId, client_secret: this.clientSecret, code: code, grant_type: 'authorization_code', redirect_uri: this.redirectUri })
                });
                if (!response.ok) { throw new Error('Token exchange failed'); }
                const tokens = await response.json();
                this.accessToken = tokens.access_token; this.refreshToken = tokens.refresh_token;
                this.storeCredentials();
            }
            async refreshAccessToken() {
                if (!this.refreshToken || !this.clientSecret) { throw new Error('No refresh token or client secret available'); }
                const response = await fetch('https://oauth2.googleapis.com/token', {
                    method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({ client_id: this.clientId, client_secret: this.clientSecret, refresh_token: this.refreshToken, grant_type: 'refresh_token' })
                });
                if (!response.ok) { throw new Error('Failed to refresh access token'); }
                const tokens = await response.json(); this.accessToken = tokens.access_token; this.storeCredentials(); return this.accessToken;
            }
            async makeApiCall(endpoint, options = {}, isJson = true) {
                if (!this.accessToken) { throw new Error('Not authenticated'); }
                const url = endpoint.startsWith('https://') ? endpoint : `${this.apiBase}${endpoint}`;
                const headers = { 'Authorization': `Bearer ${this.accessToken}`, ...options.headers };
                if(isJson) { headers['Content-Type'] = 'application/json'; }
                let response = await fetch(url, { ...options, headers });
                if (response.status === 401 && this.refreshToken && this.clientSecret) {
                    try {
                        await this.refreshAccessToken();
                        headers['Authorization'] = `Bearer ${this.accessToken}`;
                        response = await fetch(url, { ...options, headers });
                    } catch (refreshError) { this.isAuthenticated = false; this.clearStoredCredentials(); throw new Error('Authentication expired. Please reconnect.'); }
                }
                await utils.handleApiError(response, 'Google Drive API call failed');
                if (isJson) { return await response.json(); } return response;
            }
            async getFolders() {
                this.currentParentId = 'root';
                const response = await this.makeApiCall(`/files?q='root' in parents and mimeType='application/vnd.google-apps.folder'&fields=files(id,name,createdTime,modifiedTime)&orderBy=modifiedTime desc`);
                return response.files.map(folder => ({ id: folder.id, name: folder.name, type: 'folder', createdTime: folder.createdTime, modifiedTime: folder.modifiedTime, hasChildren: true }));
            }
            async getFiles(folderId) {
                const allFiles = []; let nextPageToken = null;
                do {
                    const query = `'${folderId}' in parents and trashed=false and (mimeType contains 'image/')`;
                    let url = `/files?q=${encodeURIComponent(query)}&fields=files(id,name,mimeType,size,createdTime,modifiedTime,thumbnailLink,webContentLink,webViewLink,appProperties,parents),nextPageToken&pageSize=100`;
                    if (nextPageToken) { url += `&pageToken=${nextPageToken}`; }
                    const response = await this.makeApiCall(url);
                    const files = response.files
                        .filter(file => file.mimeType && file.mimeType.startsWith('image/'))
                        .map(file => ({
                            id: file.id, name: file.name, type: 'file', mimeType: file.mimeType, size: file.size ? parseInt(file.size) : 0,
                            createdTime: file.createdTime, modifiedTime: file.modifiedTime, thumbnailLink: file.thumbnailLink,
                            webContentLink: file.webContentLink, appProperties: file.appProperties || {}
                        }));
                    allFiles.push(...files);
                    nextPageToken = response.nextPageToken;
                } while (nextPageToken);
                return allFiles;
            }
            async drillIntoFolder(folder) {
                this.currentParentId = folder.id;
                const response = await this.makeApiCall(`/files?q='${folder.id}' in parents and mimeType='application/vnd.google-apps.folder'&fields=files(id,name,createdTime,modifiedTime)&orderBy=modifiedTime desc`);
                const folders = response.files.map(f => ({ id: f.id, name: f.name, type: 'folder', createdTime: f.createdTime, modifiedTime: f.modifiedTime, hasChildren: true }));
                const files = await this.getFiles(folder.id);
                return [...folders, ...files];
            }
            async navigateToParent() {
                if (this.currentParentId === 'root') return this.getFolders();
                const fileResponse = await this.makeApiCall(`/files/${this.currentParentId}?fields=parents`);
                const parentId = fileResponse.parents && fileResponse.parents.length > 0 ? fileResponse.parents[0] : 'root';
                this.currentParentId = parentId;
                if (parentId === 'root') return this.getFolders();
                const response = await this.makeApiCall(`/files?q='${parentId}' in parents and mimeType='application/vnd.google-apps.folder'&fields=files(id,name,createdTime,modifiedTime)&orderBy=modifiedTime desc`);
                const folders = response.files.map(f => ({ id: f.id, name: f.name, type: 'folder', createdTime: f.createdTime, modifiedTime: f.modifiedTime, hasChildren: true }));
                const files = await this.getFiles(parentId);
                return [...folders, ...files];
            }
            canGoUp() { return this.currentParentId !== 'root'; }
            async updateFileMetadata(fileId, metadata) {
                await this.makeApiCall(`/files/${fileId}`, { method: 'PATCH', body: JSON.stringify({ appProperties: metadata }) });
                return true;
            }
            async deleteFile(fileId) {
                await this.makeApiCall(`/files/${fileId}`, { method: 'PATCH', body: JSON.stringify({ trashed: true }) });
                return true;
            }
            async disconnect() {
                this.isAuthenticated = false; this.accessToken = null; this.refreshToken = null; this.clientSecret = null;
                this.clearStoredCredentials();
            }
        }

        class OneDriveProvider extends BaseProvider {
            constructor() {
                super(); this.name = 'onedrive';
                this.apiBase = 'https://graph.microsoft.com/v1.0'; this.isAuthenticated = false;
                this.activeAccount = null; this.msalInstance = null;
                this.breadcrumb = [{ id: 'root', name: 'Files' }];
                this.initMSAL();
                const accounts = this.msalInstance.getAllAccounts();
                if (accounts.length > 0) { this.msalInstance.setActiveAccount(accounts[0]); this.activeAccount = accounts[0]; this.isAuthenticated = true; }
            }
            initMSAL() {
                const msalConfig = {
                    auth: { clientId: 'b407fd45-c551-4dbb-9da5-cab3a2c5a949', authority: 'https://login.microsoftonline.com/common', redirectUri: window.location.origin + window.location.pathname },
                    cache: { cacheLocation: 'localStorage' }
                };
                this.msalInstance = new msal.PublicClientApplication(msalConfig);
            }
            async authenticate() {
                try {
                    const accounts = this.msalInstance.getAllAccounts();
                    if (accounts.length > 0) { this.msalInstance.setActiveAccount(accounts[0]); this.activeAccount = accounts[0]; }
                    else { const loginResponse = await this.msalInstance.loginPopup({ scopes: ['Files.ReadWrite.All', 'User.Read'] });
                        this.activeAccount = loginResponse.account; this.msalInstance.setActiveAccount(this.activeAccount);
                    }
                    this.isAuthenticated = true; return true;
                } catch (error) { this.isAuthenticated = false; throw new Error(`Authentication failed: ${error.message}`); }
            }
            async getAccessToken() {
                if (!this.activeAccount) { throw new Error('No active account'); }
                try {
                    const response = await this.msalInstance.acquireTokenSilent({ scopes: ['Files.ReadWrite.All'], account: this.activeAccount });
                    return response.accessToken;
                } catch (silentError) {
                    if (silentError instanceof msal.InteractionRequiredAuthError) {
                        const response = await this.msalInstance.acquireTokenPopup({ scopes: ['Files.ReadWrite.All'], account: this.activeAccount });
                        return response.accessToken;
                    } throw silentError;
                }
            }
            async makeApiCall(endpoint, options = {}) {
                const accessToken = await this.getAccessToken();
                const url = endpoint.startsWith('https://') ? endpoint : `${this.apiBase}${endpoint}`;
                const headers = { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json', ...options.headers };
                const response = await fetch(url, { ...options, headers });
                if (response.status === 401) { throw new Error('TOKEN_EXPIRED'); }
                await utils.handleApiError(response, 'OneDrive API call failed');
                return response.json();
            }
            async getFiles(folderId) {
                const endpoint = folderId === 'root' ? '/me/drive/root/children' : `/me/drive/items/${folderId}/children`;
                const data = await this.makeApiCall(endpoint);
                return data.value.filter(item => item.file && item.file.mimeType && item.file.mimeType.startsWith('image/'))
                    .map(item => ({
                        id: item.id, name: item.name, type: 'file', mimeType: item.file.mimeType, size: item.size || 0,
                        createdTime: item.createdDateTime, modifiedTime: item.lastModifiedDateTime,
                        thumbnails: item.thumbnails && item.thumbnails.length > 0 ? { large: item.thumbnails[0].large } : null,
                        downloadUrl: item['@microsoft.graph.downloadUrl']
                    }));
            }
            async loadItemsInParent(parentId) {
                const endpoint = parentId === 'root' ? '/me/drive/root/children' : `/me/drive/items/${parentId}/children`;
                const data = await this.makeApiCall(endpoint);
                const folders = data.value.filter(item => item.folder).map(folder => ({ id: folder.id, name: folder.name, type: 'folder', createdTime: folder.createdDateTime, modifiedTime: folder.lastModifiedDateTime, hasChildren: (folder.folder.childCount || 0) > 0 }));
                const files = data.value.filter(item => item.file && item.file.mimeType && item.file.mimeType.startsWith('image/'))
                    .map(item => ({
                        id: item.id, name: item.name, type: 'file', mimeType: item.file.mimeType, size: item.size || 0,
                        createdTime: item.createdDateTime, modifiedTime: item.lastModifiedDateTime,
                        thumbnails: item.thumbnails && item.thumbnails.length > 0 ? { large: item.thumbnails[0].large } : null,
                        downloadUrl: item['@microsoft.graph.downloadUrl']
                    }));
                return [...folders.sort((a, b) => a.name.localeCompare(b.name)), ...files];
            }
            async getFolders() {
                this.breadcrumb = [{ id: 'root', name: 'Files' }];
                return (await this.loadItemsInParent('root')).filter(item => item.type === 'folder');
            }
            async drillIntoFolder(folder) {
                this.breadcrumb.push({ id: folder.id, name: folder.name });
                return await this.loadItemsInParent(folder.id);
            }
            async navigateToParent() {
                if (this.breadcrumb.length <= 1) return this.getFolders();
                this.breadcrumb.pop();
                const parentFolder = this.breadcrumb[this.breadcrumb.length - 1];
                return await this.loadItemsInParent(parentFolder.id);
            }
            getCurrentPath() { return this.breadcrumb.map(b => b.name).join(' / '); }
            canGoUp() { return this.breadcrumb.length > 1; }
            async updateFileMetadata(fileId, metadata) {
                // OneDrive API does not support appProperties like Drive. Need a separate metadata file.
                // For now, this is a no-op as complex sync is out of scope.
                debug('OneDrive metadata update skipped (out of scope for this simple implementation).', metadata);
                return true;
            }
            async deleteFile(fileId) {
                await this.makeApiCall(`/me/drive/items/${fileId}`, { method: 'DELETE' });
                return true;
            }
            async disconnect() {
                this.isAuthenticated = false; this.activeAccount = null;
                if (this.msalInstance) {
                    const accounts = this.msalInstance.getAllAccounts();
                    if (accounts.length > 0) { await this.msalInstance.logoutPopup({ account: accounts[0] }); }
                }
            }
        }
        
        // ===== API module (Refactored to use Providers) =====
        const api = {
            async validateToken(token, clientSecret) {
                if (appState.providerType === 'googledrive') {
                    // GoogleDriveProvider handles its own token management
                    if (!appState.provider) appState.provider = new GoogleDriveProvider();
                    await appState.provider.authenticate(clientSecret);
                    appState.token = appState.provider.accessToken;
                    return true;
                } else if (appState.providerType === 'onedrive') {
                    if (!appState.provider) appState.provider = new OneDriveProvider();
                    await appState.provider.authenticate();
                    return true;
                }
                throw new Error('No provider selected');
            },

            async fetchFolders() {
                if (!appState.provider) throw new Error('Provider not connected');
                return appState.provider.getFolders();
            },

            async fetchFiles(folderId) {
                if (!appState.provider) throw new Error('Provider not connected');
                return appState.provider.getFiles(folderId);
            },

            async updateMetadata(fileId, metadata) {
                if (!appState.provider) throw new Error('Provider not connected');
                const file = appState.images.find(f => f.id === fileId);
                if (!file) throw new Error(`File not found: ${fileId}`);
                
                // Update local state first (no DB, so permanent until refresh)
                const newAppProperties = { ...(file.appProperties || {}), ...metadata };
                file.appProperties = newAppProperties;
                
                // Update remote
                await appState.provider.updateFileMetadata(fileId, metadata);
                return metadata;
            },

            async deleteFile(fileId) {
                if (!appState.provider) throw new Error('Provider not connected');
                await appState.provider.deleteFile(fileId);
                
                // Update local state
                const fileIndex = appState.images.findIndex(f => f.id === fileId);
                if (fileIndex !== -1) { appState.images.splice(fileIndex, 1); }
                CONFIG.stacks.forEach(stack => {
                    const index = appState.stacks[stack].findIndex(f => f.id === fileId);
                    if (index !== -1) { appState.stacks[stack].splice(index, 1); }
                });
                return true;
            }
        };

        // ===== App Management (Refactored) =====
        const appManager = {
            selectProvider(type) {
                appState.providerType = type;
                const isGoogle = type === 'googledrive';
                appState.provider = isGoogle ? new GoogleDriveProvider() : new OneDriveProvider();

                if (appState.provider.isAuthenticated) {
                    utils.showScreen('folder-screen');
                    folderManager.loadFolders();
                } else {
                    $('auth-title').textContent = isGoogle ? 'Google Drive' : 'OneDrive';
                    $('auth-subtitle').textContent = `Connect to ${isGoogle ? 'Google Drive' : 'OneDrive'}`;
                    $('gdrive-secret-container').classList.toggle('hidden', !isGoogle);
                    $('auth-button').textContent = `Connect ${isGoogle ? 'Drive' : 'OneDrive'}`;
                    $('auth-status').textContent = isGoogle ? 'Enter your client secret to continue' : 'Click to sign in with your Microsoft account';
                    $('auth-status').className = 'status-info mt-4';
                    utils.showScreen('auth-screen');
                }
            },
            async authenticateCurrentUser() {
                const isGoogle = appState.providerType === 'googledrive';
                const { authButton, authStatus, gdriveClientSecret } = { authButton: $('auth-button'), authStatus: $('auth-status'), gdriveClientSecret: $('gdrive-client-secret') };
                authButton.disabled = true; authButton.textContent = 'Connecting...';
                authStatus.textContent = `Connecting to ${isGoogle ? 'Google Drive' : 'OneDrive'}...`;
                authStatus.className = 'status-info mt-4';

                try {
                    const clientSecret = isGoogle ? gdriveClientSecret.value.trim() : null;
                    await api.validateToken(null, clientSecret);

                    authStatus.textContent = `✅ Connected to ${isGoogle ? 'Google Drive' : 'OneDrive'}!`;
                    authStatus.className = 'status-success mt-4';
                    if (isGoogle) gdriveClientSecret.value = '';

                    setTimeout(() => {
                        utils.showScreen('folder-screen');
                        folderManager.loadFolders();
                    }, 1000);
                } catch (error) {
                    authStatus.textContent = `Authentication failed: ${error.message}`;
                    authStatus.className = 'status-error mt-4';
                } finally {
                    authButton.disabled = false;
                    authButton.textContent = `Connect ${isGoogle ? 'Drive' : 'OneDrive'}`;
                }
            },
            async disconnect() {
                if (appState.provider) {
                    await appState.provider.disconnect();
                }
                appState.provider = null;
                appState.providerType = null;
                utils.showScreen('provider-screen');
            },
            async backToProviderSelection() {
                appState.provider = null;
                appState.providerType = null;
                utils.showScreen('provider-screen');
            },
            
            // Refactored folder manager from goji.html to fit SlideSwipe
            async handleFolderRefresh() {
                try {
                    const provider = appState.provider;
                    if (provider && typeof provider.canGoUp === 'function' && provider.canGoUp()) {
                        const items = await provider.navigateToParent();
                        folderManager.displayItems(items);
                    } else {
                        await folderManager.loadFolders();
                    }
                    folderManager.updateNavigation();
                } catch (error) {
                    utils.toast(`Folder navigation failed: ${error.message}`, 'error');
                }
            },

            async handleFolderSelect(folder) {
                await folderManager.selectFolder(folder);
            },
            
            async handleFolderDrill(folder) {
                 try {
                    const provider = appState.provider;
                    const items = await provider.drillIntoFolder(folder);
                    folderManager.displayItems(items);
                    folderManager.updateNavigation();
                } catch (error) {
                     utils.toast(`Error browsing folder: ${error.message}`, 'error');
                }
            }
        };


        // ===== Image Viewer module (SlideSwipe original) =====
        const imageViewer = {
            // Display current image
            display() {
                if (appState.images.length === 0 || appState.currentIdx < 0 || appState.currentIdx >= appState.images.length) {
                    $('center-image').src = '';
                    $('center-image').alt = 'No image selected';
                    $('header-filename').textContent = '';
                    $('empty-state').classList.remove('hidden');
                    return;
                }

                $('empty-state').classList.add('hidden');
                const currentFile = appState.images[appState.currentIdx];

                if (!currentFile) {
                    $('center-image').src = '';
                    $('center-image').alt = 'Image not available';
                    $('header-filename').textContent = '';
                    utils.toast('Error: Image not available', 'error');
                    return;
                }

                $('center-image').src = '';

                // Get preferred image URL
                const primaryUrl = appState.providerType === 'googledrive'
                    ? (currentFile.webContentLink || `https://drive.google.com/uc?export=view&id=${currentFile.id}`)
                    : currentFile.downloadUrl;
                
                $('center-image').src = primaryUrl;
                $('center-image').alt = currentFile.name || 'Image';
                const filename = currentFile.name || '';
                const nameWithoutExtension = filename.lastIndexOf('.') > 0
                    ? filename.substring(0, filename.lastIndexOf('.'))
                    : filename;
                $('header-filename').textContent = nameWithoutExtension;

                this.applyZoom();
                stackManager.updateContainers();
            },

            // Apply zoom level to image
            applyZoom() {
                const scale = appState.zoom / 100;
                $('center-image').style.transform = `translate(-50%, -50%) scale(${scale})`;
            },

            // Find next image in current stack
            findNextImage() {
                const currentFile = appState.images[appState.currentIdx];
                if (!currentFile) return -1;

                const sourceStack = appState.currentStack;
                const stackImages = appState.stacks[sourceStack];
                const currentPositionInStack = stackImages.findIndex(f => f.id === currentFile.id);

                if (currentPositionInStack !== -1) {
                    if (currentPositionInStack < stackImages.length - 1) {
                        const nextImageInStack = stackImages[currentPositionInStack + 1];
                        return appState.images.findIndex(f => f.id === nextImageInStack.id);
                    }
                    else if (stackImages.length > 0) {
                        const firstImageInStack = stackImages[0];
                        return appState.images.findIndex(f => f.id === firstImageInStack.id);
                    }
                }

                if (stackImages.length > 0) {
                    const firstImageInStack = stackImages[0];
                    return appState.images.findIndex(f => f.id === firstImageInStack.id);
                }

                return -1;
            },

            // Move to next image
            moveToNext() {
                if (appState.images.length === 0) return;

                const nextIndex = this.findNextImage();
                if (nextIndex === -1) {
                    $('empty-state').classList.remove('hidden');
                    $('center-image').src = '';
                    $('center-image').alt = 'No images to review';
                    $('header-filename').textContent = '';
                } else {
                    appState.currentIdx = nextIndex;
                    this.display();
                }
            }
        };
        
        // ===== Stack Manager module (SlideSwipe original) =====
        const stackManager = {
            getMetadata(file) {
                const props = file.appProperties || {};
                let meta = {
                    slideboxStack: props.slideboxStack || 'in',
                    slideboxTags: props.slideboxTags ? props.slideboxTags.split(',') : []
                };
                if (meta.slideboxStack === 'needs_review') meta.slideboxStack = 'in';
                else if (meta.slideboxStack === 'reviewed') meta.slideboxStack = 'out';
                return meta;
            },
            updateStacks() {
                for (const stack of CONFIG.stacks) { appState.stacks[stack] = []; }
                appState.images.forEach(file => {
                    const meta = this.getMetadata(file);
                    const stack = meta.slideboxStack;
                    if (CONFIG.stacks.includes(stack)) { appState.stacks[stack].push(file); }
                    else { appState.stacks.in.push(file); }
                });
                this.updateCounts();
                this.updateContainers();
            },
            updateCounts() {
                for (const stack of CONFIG.stacks) {
                    const count = appState.stacks[stack].length;
                    $$('.stack-count[data-stack="' + stack + '"]').forEach(el =>
                        el.textContent = count > 999 ? ':-)' : count);
                }
                if (appState.grid.stack && $('select-all-btn')) {
                    $('select-all-btn').textContent = appState.stacks[appState.grid.stack].length;
                }
            },
            updateContainers() {
                CONFIG.stacks.forEach(stack => {
                    const container = document.querySelector(`.stack-container[data-stack="${stack}"]`);
                    container.innerHTML = '';
                    appState.stacks[stack].forEach((file, index) => {
                        const div = document.createElement('div');
                        div.className = 'relative'; div.dataset.fileId = file.id; div.dataset.stackIndex = index;
                        const img = document.createElement('img'); img.className = 'stack-thumbnail';
                        const currentFile = appState.images[appState.currentIdx];
                        if (currentFile && currentFile.id === file.id) { img.classList.add('selected'); }
                        utils.setImageSrc(img, file);
                        img.addEventListener('click', () => this.handleThumbnailClick(file));
                        div.appendChild(img); container.appendChild(div);
                    });
                });
            },
            handleThumbnailClick(file) {
                const index = appState.images.findIndex(f => f.id === file.id);
                if (index !== -1) { appState.currentIdx = index; imageViewer.display(); }
            },
            async moveFileToStack(fileId, targetStack) {
                const file = appState.images.find(f => f.id === fileId);
                if (!file) throw new Error('File not found');
                const meta = this.getMetadata(file);
                const currentStack = meta.slideboxStack;
                if (currentStack === targetStack) return file;
                try {
                    await api.updateMetadata(fileId, { slideboxStack: targetStack });
                    const currentStackIndex = appState.stacks[currentStack].findIndex(f => f.id === fileId);
                    if (currentStackIndex !== -1) { appState.stacks[currentStack].splice(currentStackIndex, 1); }
                    appState.stacks[targetStack].unshift(file);
                    file.appProperties = file.appProperties || {};
                    file.appProperties.slideboxStack = targetStack;
                    this.updateCounts(); this.updateContainers();
                    utils.toast(`Moved to ${targetStack}`);
                    return file;
                } catch (error) { utils.toast(`Failed to move file: ${error.message}`, 'error'); throw error; }
            },
            async addTagsToFile(fileId, tags) {
                const file = appState.images.find(f => f.id === fileId);
                if (!file) throw new Error(`File not found: ${fileId}`);
                const meta = this.getMetadata(file);
                const currentTags = meta.slideboxTags || [];
                const newTags = [...new Set([...currentTags, ...tags])];
                tags.forEach(tag => appState.tags.add(tag));
                try {
                    await api.updateMetadata(fileId, { slideboxTags: newTags.join(',') });
                    file.appProperties.slideboxTags = newTags.join(','); // Local update
                    utils.toast(`Tags added: ${tags.join(', ')}`);
                    return newTags;
                } catch (error) { utils.toast('Failed to add tags', 'error'); return currentTags; }
            }
        };
        
        // ===== Grid View module (SlideSwipe original) =====
        const gridView = {
            open(stack) {
                $('grid-modal').classList.remove('hidden');
                const stackNames = { 'in': 'In', 'out': 'Out', 'priority': 'Priority', 'trash': 'Trash' };
                $('grid-title').textContent = stackNames[stack] || stack;
                $('select-all-btn').textContent = appState.stacks[stack].length;
                appState.grid.stack = stack;
                appState.grid.selected = [];
                this.updateSelectionUI();
                this.populate(stack);
            },
            close() {
                $('grid-modal').classList.add('hidden');
                appState.grid.stack = null;
                appState.grid.selected = [];
            },
            populate(stack) {
                const container = $('grid-container'); container.innerHTML = '';
                container.style.gridTemplateColumns = `repeat(${$('grid-size').value}, 1fr)`;
                appState.stacks[stack].forEach(file => {
                    const div = document.createElement('div');
                    div.className = 'grid-item'; div.dataset.fileId = file.id;
                    const img = document.createElement('img'); img.className = 'grid-image'; img.loading = 'lazy';
                    utils.setImageSrc(img, file);
                    div.addEventListener('click', e => { e.stopPropagation(); this.toggleSelection(e, file.id); });
                    div.appendChild(img); container.appendChild(div);
                });
            },
            toggleSelection(e, fileId) {
                const gridItem = e.currentTarget;
                const index = appState.grid.selected.indexOf(fileId);
                if (index === -1) { appState.grid.selected.push(fileId); gridItem.classList.add('selected'); }
                else { appState.grid.selected.splice(index, 1); gridItem.classList.remove('selected'); }
                this.updateSelectionUI();
                if (appState.grid.selected.length === 1) { this.focusOnSelectedItem(appState.grid.selected[0]); }
            },
            focusOnSelectedItem(fileId) {
                const selectedItem = document.querySelector(`.grid-item[data-file-id="${fileId}"]`);
                if (selectedItem) { selectedItem.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
            },
            updateSelectionUI() {
                const count = appState.grid.selected.length;
                const buttons = [$('tag-selected'), $('move-selected'), $('delete-selected')];
                $('selection-text').textContent = `${count} selected`;
                buttons.forEach(btn => { if (btn) btn.classList.toggle('hidden', count === 0); });
            },
            selectAll() {
                const gridItems = $$('#grid-container .grid-item');
                appState.grid.selected = [];
                gridItems.forEach(item => {
                    const fileId = item.dataset.fileId;
                    if (fileId) { appState.grid.selected.push(fileId); item.classList.add('selected'); }
                });
                this.updateSelectionUI();
            },
            deselectAll() {
                $$('#grid-container .grid-item').forEach(item => item.classList.remove('selected') );
                appState.grid.selected = [];
                this.updateSelectionUI();
            }
        };

        // ===== Folder Management Module (Refactored from goji.html) =====
        const folderManager = {
            async loadFolders() {
                const { folderList } = { folderList: $('folder-list') };
                folderList.innerHTML = `<div class="flex items-center justify-center py-8 text-gray-400">
                    <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-blue-500" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                    <span>Loading folders...</span>
                </div>`;
                try {
                    const folders = await api.fetchFolders();
                    this.displayItems(folders.map(f => ({ ...f, hasChildren: true }))); // Assume all Drive folders have children for simplicity
                    this.updateNavigation();
                } catch (error) {
                    utils.toast(`Error loading folders: ${error.message}`, 'error');
                    folderList.innerHTML = `<div class="text-center py-8 text-red-500"><span>Failed to load folders.</span><button id="retry-folders" class="btn btn-primary mt-3">Retry</button></div>`;
                    $('retry-folders').addEventListener('click', () => this.loadFolders());
                }
            },
            displayItems(items) {
                const { folderList } = { folderList: $('folder-list') };
                folderList.innerHTML = '';
                const folders = items.filter(item => item.type === 'folder');
                const files = items.filter(item => item.type === 'file');

                if (folders.length === 0 && files.length === 0) {
                    folderList.innerHTML = `<div class="text-center py-8 text-gray-500"><span>No items found</span></div>`;
                    return;
                }

                [...folders, ...files].forEach(item => {
                    const isFolder = item.type === 'folder';
                    const div = document.createElement('div');
                    div.className = 'folder-list-item';

                    let dateInfo = item.modifiedTime ? new Date(item.modifiedTime).toLocaleDateString() : '';
                    if (!isFolder && item.size) { dateInfo += ` • ${utils.formatFileSize(item.size)}`; }

                    div.innerHTML = `
                        <svg class="folder-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="color: ${isFolder ? '#f59e0b' : '#3b82f6'};">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${isFolder ? 'M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z' : 'M4 16l4-4 4 4 4-4 4 4M4 4h16v12a2 2 0 01-2 2H6a2 2 0 01-2-2V4z'}"></path>
                        </svg>
                        <div class="folder-info-text">
                            <div class="folder-name-text">${item.name}</div>
                            <div class="folder-date-text">${dateInfo}</div>
                        </div>
                        <div class="flex gap-2">
                            ${isFolder ? `<button class="btn btn-secondary py-1 px-3 text-sm" data-action="drill" data-id="${item.id}" data-name="${item.name}">Browse →</button>` : ''}
                            ${!isFolder && CONFIG.imgTypes.includes(item.mimeType) ? `<button class="btn btn-primary py-1 px-3 text-sm" data-action="select" data-id="${item.id}" data-name="${item.name}">Select</button>` : ''}
                            ${isFolder && files.length > 0 ? `<button class="btn btn-primary py-1 px-3 text-sm" data-action="select" data-id="${item.id}" data-name="${item.name}">Select Folder</button>` : ''}
                        </div>`;
                    folderList.appendChild(div);
                });

                document.querySelectorAll('#folder-list button').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const { action, id, name } = e.target.dataset;
                        if (action === 'drill') {
                            await appManager.handleFolderDrill({ id, name });
                        } else if (action === 'select' || action === 'select folder') {
                            await folderManager.selectFolder({ id, name });
                        }
                    });
                });
            },
            updateNavigation() {
                const { folderSubtitle, folderRefreshButton } = { folderSubtitle: $('folder-subtitle'), folderRefreshButton: $('folder-refresh-button') };
                const provider = appState.provider;

                if (provider && typeof provider.getCurrentPath === 'function') {
                    folderSubtitle.textContent = provider.getCurrentPath();
                }

                if (provider && typeof provider.canGoUp === 'function' && provider.canGoUp()) {
                    folderRefreshButton.textContent = '← Go Up';
                } else {
                    folderRefreshButton.textContent = 'Refresh';
                }
            },
            async selectFolder(folder) {
                appState.folder.id = folder.id;
                appState.folder.name = folder.name;
                $('version-folder-pill').textContent = folder.name;
                $('center-image').src = ''; $('center-image').alt = 'Loading...';
                $('header-filename').textContent = ''; $('empty-state').classList.add('hidden');
                utils.toast('Loading images...');
                const defaults = CONFIG.defaults; appState.zoom = defaults.zoom; appState.currentStack = 'in';
                $('image-zoom').value = defaults.zoom; $('zoom-value').textContent = `${defaults.zoom}%`;
                CONFIG.stacks.forEach(stack => {
                    appState.stacks[stack] = [];
                    document.querySelector(`.stack-container[data-stack="${stack}"]`).innerHTML = '';
                    const isActive = stack === 'in';
                    document.querySelector(`.tab[data-stack="${stack}"]`).classList.toggle('active', isActive);
                    document.querySelector(`.tab-pane[data-stack="${stack}"]`).classList.toggle('active', isActive);
                });
                try {
                    const files = await api.fetchFiles(folder.id);
                    appState.images = files;
                    if (!files || files.length === 0) {
                        utils.toast('No images found in this folder');
                        $('empty-state').classList.remove('hidden');
                        stackManager.updateCounts(); return;
                    }
                    appState.currentIdx = 0; stackManager.updateStacks();
                    if (appState.stacks.in.length > 0) {
                        const inStackIndex = appState.images.findIndex(file => file.id === appState.stacks.in[0].id);
                        if (inStackIndex !== -1) { appState.currentIdx = inStackIndex; appState.currentStack = 'in'; imageViewer.display(); }
                    } else { $('empty-state').classList.remove('hidden'); $('center-image').src = ''; $('center-image').alt = 'No images to review'; $('header-filename').textContent = ''; }
                    utils.showScreen('app-screen');
                } catch (error) { utils.toast('Error loading images', 'error'); $('empty-state').classList.remove('hidden'); }
            }
        };


        // ===== Remaining Modules (SlideSwipe original or minimal update) =====
        const gestureHandler = {
            setup() {
                const container = $('center-image').parentElement;
                let touchStartX = 0, touchStartY = 0, touchEndX = 0, touchEndY = 0;
                container.addEventListener('touchstart', e => {
                    touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY;
                });
                container.addEventListener('touchmove', e => {
                    touchEndX = e.touches[0].clientX; touchEndY = e.touches[0].clientY;
                    const deltaX = touchEndX - touchStartX; const deltaY = touchEndY - touchStartY;
                    $$('.swipe-indicator').forEach(i => i.style.opacity = '0');
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        if (deltaX > 50) document.querySelector('.swipe-right').style.opacity = '1';
                        else if (deltaX < -50) document.querySelector('.swipe-left').style.opacity = '1';
                    } else {
                        if (deltaY > 50) document.querySelector('.swipe-down').style.opacity = '1';
                        else if (deltaY < -50) document.querySelector('.swipe-up').style.opacity = '1';
                    }
                });
                container.addEventListener('touchend', () => {
                    $$('.swipe-indicator').forEach(i => i.style.opacity = '0');
                    const deltaX = touchEndX - touchStartX; const deltaY = touchEndY - touchStartY;
                    const minSwipeDistance = 100;
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        if (Math.abs(deltaX) >= minSwipeDistance) {
                            if (deltaX > 0) this.handleSwipe('out'); else this.handleSwipe('in');
                        }
                    } else {
                        if (Math.abs(deltaY) >= minSwipeDistance) {
                            if (deltaY > 0) this.handleSwipe('trash'); else this.handleSwipe('priority');
                        }
                    }
                });
                this.setupMouseDrag(container);
                document.addEventListener('keydown', e => {
                    if ($('app-screen').classList.contains('hidden')) return;
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    switch (e.key) {
                        case 'ArrowUp': this.handleSwipe('priority'); break;
                        case 'ArrowDown': this.handleSwipe('trash'); break;
                        case 'ArrowLeft': this.handleSwipe('in'); break;
                        case 'ArrowRight': this.handleSwipe('out'); break;
                        case 'Escape':
                            if (!$('grid-modal').classList.contains('hidden')) { gridView.close();
                            } else if (!$('metadata-panel').classList.contains('hidden')) { $('metadata-panel').classList.add('hidden'); }
                            break;
                    }
                });
            },
            setupMouseDrag(container) {
                let isDragging = false, dragStartX = 0, dragStartY = 0;
                container.addEventListener('mousedown', e => { isDragging = true; dragStartX = e.clientX; dragStartY = e.clientY; });
                container.addEventListener('mousemove', e => {
                    if (!isDragging) return;
                    const deltaX = e.clientX - dragStartX; const deltaY = e.clientY - dragStartY;
                    $$('.swipe-indicator').forEach(i => i.style.opacity = '0');
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        if (deltaX > 50) document.querySelector('.swipe-right').style.opacity = '1';
                        else if (deltaX < -50) document.querySelector('.swipe-left').style.opacity = '1';
                    } else {
                        if (deltaY > 50) document.querySelector('.swipe-down').style.opacity = '1';
                        else if (deltaY < -50) document.querySelector('.swipe-up').style.opacity = '1';
                    }
                });
                container.addEventListener('mouseup', e => {
                    if (!isDragging) return;
                    $$('.swipe-indicator').forEach(i => i.style.opacity = '0');
                    const deltaX = e.clientX - dragStartX; const deltaY = e.clientY - dragStartY;
                    const minDragDistance = 100;
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        if (Math.abs(deltaX) >= minDragDistance) {
                            if (deltaX > 0) this.handleSwipe('out'); else this.handleSwipe('in');
                        }
                    } else {
                        if (Math.abs(deltaY) >= minDragDistance) {
                            if (deltaY > 0) this.handleSwipe('trash'); else this.handleSwipe('priority');
                        }
                    }
                    isDragging = false;
                });
                container.addEventListener('mouseleave', () => { isDragging = false; $$('.swipe-indicator').forEach(i => i.style.opacity = '0'); });
            },
            async handleSwipe(targetStack) {
                if (appState.images.length === 0) return;
                const currentFile = appState.images[appState.currentIdx];
                if (!currentFile) return;
                const meta = stackManager.getMetadata(currentFile);
                const currentStack = meta.slideboxStack;
                if (currentStack === targetStack) { imageViewer.moveToNext(); return; }
                try {
                    await stackManager.moveFileToStack(currentFile.id, targetStack);
                    imageViewer.moveToNext();
                } catch (error) { debug('Swipe error:', error); }
            }
        };

        const modalManager = {
            toggle(id, show = true) { const el = $(id); if (!el) return; el.classList.toggle('hidden', !show); },
            show(id) { this.toggle(id, true); },
            hide(id) { this.toggle(id, false); },
            setup() {
                const setupCloseButtons = () => {
                    ['move', 'tag', 'delete'].forEach(type => { $(`cancel-${type}`)?.addEventListener('click', () => this.hide(`${type}-modal`)); });
                    $('metadata-close')?.addEventListener('click', () => $('metadata-panel').classList.add('hidden'));
                };
                $$('.move-option').forEach(option => {
                    option.addEventListener('click', () => {
                        const targetStack = option.dataset.stack;
                        const promises = appState.grid.selected.map(fileId => stackManager.moveFileToStack(fileId, targetStack));
                        Promise.all(promises).then(() => {
                            utils.toast(`Moved ${promises.length} images to ${targetStack}`); this.hide('move-modal');
                            if (appState.grid.stack) { gridView.populate(appState.grid.stack); }
                            appState.grid.selected = []; gridView.updateSelectionUI(); stackManager.updateCounts();
                        }).catch(() => { utils.toast('Failed to move some images', 'error'); this.hide('move-modal'); });
                    });
                });
                $('apply-tag')?.addEventListener('click', () => {
                    const tagInput = $('tag-input').value.trim();
                    if (!tagInput) { this.hide('tag-modal'); return; }
                    const tags = tagInput.split(',').map(tag => tag.trim()).filter(tag => tag);
                    if ($('grid-modal').classList.contains('hidden')) {
                        const currentFile = appState.images[appState.currentIdx];
                        stackManager.addTagsToFile(currentFile.id, tags).then(() => this.hide('tag-modal'));
                    } else {
                        const promises = appState.grid.selected.map(fileId => stackManager.addTagsToFile(fileId, tags));
                        Promise.all(promises).then(() => {
                            utils.toast(`Tags added to ${promises.length} images`); this.hide('tag-modal');
                        }).catch(() => { utils.toast('Failed to add tags to some images', 'error'); this.hide('tag-modal'); });
                    }
                });
                $('confirm-delete')?.addEventListener('click', () => {
                    const currentStack = appState.grid.stack; $('confirm-delete').disabled = true; $('confirm-delete').textContent = 'Processing...';
                    const isTrash = currentStack === 'trash';
                    const promises = appState.grid.selected.map(fileId => isTrash ? api.deleteFile(fileId) : stackManager.moveFileToStack(fileId, 'trash'));
                    Promise.all(promises).then(() => {
                        utils.toast(`${isTrash ? 'Permanently deleted' : 'Moved to trash'} ${promises.length} images`); this.hide('delete-modal');
                        if (appState.grid.stack) { gridView.populate(appState.grid.stack); }
                        appState.grid.selected = []; gridView.updateSelectionUI(); stackManager.updateCounts();
                    }).catch(() => {
                        utils.toast(`Failed to ${isTrash ? 'delete' : 'move to trash'} some images`, 'error'); this.hide('delete-modal');
                    }).finally(() => { $('confirm-delete').disabled = false; $('confirm-delete').textContent = isTrash ? 'Permanently Delete' : 'Move to Trash'; });
                });
                $('delete-selected')?.addEventListener('click', () => {
                    const selectedCount = appState.grid.selected.length; const currentStack = appState.grid.stack;
                    if (currentStack === 'trash') {
                        $('delete-message').textContent = `Are you sure you want to permanently delete ${selectedCount} image${selectedCount > 1 ? 's' : ''}? This action cannot be undone.`;
                        $('confirm-delete').textContent = 'Permanently Delete';
                    } else {
                        $('delete-message').textContent = `Are you sure you want to move ${selectedCount} image${selectedCount > 1 ? 's' : ''} to Trash?`;
                        $('confirm-delete').textContent = 'Move to Trash';
                    }
                    this.show('delete-modal');
                });
                $('tag-selected')?.addEventListener('click', () => {
                    $('tag-suggestions').innerHTML = ''; $('tag-input').value = '';
                    appState.tags.forEach(tag => {
                        const button = document.createElement('button'); button.className = 'bg-gray-200 text-gray-700 px-2 py-1 rounded-md text-xs hover:bg-gray-300';
                        button.textContent = tag; button.addEventListener('click', () => { $('tag-input').value += ($('tag-input').value ? ', ' : '') + tag; });
                        $('tag-suggestions').appendChild(button);
                    });
                    this.show('tag-modal'); $('tag-input').focus();
                });
                $('move-selected')?.addEventListener('click', () => { this.show('move-modal'); });
                setupCloseButtons();
            }
        };

        const privacyMode = {
            show() {
                $('privacy-panel').classList.add('show'); utils.updatePrivacyTime();
                appState.privacyTimer = setInterval(utils.updatePrivacyTime, 1000);
            },
            hide() {
                $('privacy-panel').classList.remove('show');
                if (appState.privacyTimer) { clearInterval(appState.privacyTimer); appState.privacyTimer = null; }
            },
            setup() {
                $('privacy-panel-close').addEventListener('click', () => this.hide());
                document.addEventListener('touchstart', e => {
                    const touch = e.touches[0]; const edgeThreshold = 20;
                    if (touch.clientX < edgeThreshold || touch.clientX > window.innerWidth - edgeThreshold) {
                        const startX = touch.clientX;
                        const checkSwipe = moveEvent => {
                            const moveX = moveEvent.touches[0].clientX; const deltaX = Math.abs(moveX - startX);
                            if (deltaX > 50) { this.show(); document.removeEventListener('touchmove', checkSwipe); }
                        };
                        document.addEventListener('touchmove', checkSwipe);
                        document.addEventListener('touchend', () => { document.removeEventListener('touchmove', checkSwipe); }, { once: true });
                    }
                });
            }
        };

        const metadataPanel = {
            show(file, x, y) {
                const panel = $('metadata-panel'); const meta = stackManager.getMetadata(file);
                $('metadata-content').innerHTML = `
                    <p><strong>Name:</strong> ${file.name}</p>
                    <p><strong>Type:</strong> ${file.mimeType}</p>
                    <p><strong>Stack:</strong> ${meta.slideboxStack || 'None'}</p>
                    <p><strong>Tags:</strong> ${meta.slideboxTags.length ? meta.slideboxTags.join(', ') : 'None'}</p>
                    <p><strong>Created:</strong> ${new Date(file.createdTime).toLocaleString()}</p>
                `;
                panel.style.left = `${x}px`; panel.style.top = `${y}px`;
                const rect = panel.getBoundingClientRect();
                if (rect.right > window.innerWidth) { panel.style.left = `${window.innerWidth - rect.width - 10}px`; }
                if (rect.bottom > window.innerHeight) { panel.style.top = `${y - rect.height}px`; }
                panel.classList.remove('hidden');
            },
            hide() { $('metadata-panel').classList.add('hidden'); }
        };

        // ===== App Initialization (Updated) =====
        function initApp() {
            // New provider selection handlers
            $('google-drive-btn').addEventListener('click', () => appManager.selectProvider('googledrive'));
            $('onedrive-btn').addEventListener('click', () => appManager.selectProvider('onedrive'));

            // New auth screen handlers
            $('auth-button').addEventListener('click', () => appManager.authenticateCurrentUser());
            $('auth-back-button').addEventListener('click', () => appManager.backToProviderSelection());

            // New folder screen handlers
            $('folder-refresh-button').addEventListener('click', () => appManager.handleFolderRefresh());
            $('folder-back-button').addEventListener('click', () => appManager.backToProviderSelection());
            $('folder-logout-button').addEventListener('click', () => appManager.disconnect());

            // Original SlideSwipe handlers
            $('version-folder-pill').addEventListener('click', () => {
                if (appState.provider) {
                    utils.showScreen('folder-screen');
                    folderManager.loadFolders();
                } else {
                    utils.showScreen('provider-screen');
                }
            });
            $('select-another-folder').addEventListener('click', () => { utils.showScreen('folder-screen'); });
            $('image-zoom').addEventListener('input', () => {
                appState.zoom = parseInt($('image-zoom').value); $('zoom-value').textContent = `${appState.zoom}%`;
                imageViewer.applyZoom();
                if (!$('grid-modal').classList.contains('hidden') && appState.grid.selected.length === 1) {
                    gridView.focusOnSelectedItem(appState.grid.selected[0]);
                }
            });
            $('header-tags-btn').addEventListener('click', () => {
                if (appState.images.length === 0) return;
                $('tag-suggestions').innerHTML = '';
                appState.tags.forEach(tag => {
                    const button = document.createElement('button'); button.className = 'bg-gray-200 text-gray-700 px-2 py-1 rounded-md text-xs hover:bg-gray-300';
                    button.textContent = tag; button.addEventListener('click', () => { $('tag-input').value += ($('tag-input').value ? ', ' : '') + tag; });
                    $('tag-suggestions').appendChild(button);
                });
                modalManager.show('tag-modal'); $('tag-input').value = ''; $('tag-input').focus();
            });
            $('header-grid-btn').addEventListener('click', () => { gridView.open(appState.currentStack); });
            $('close-grid').addEventListener('click', () => gridView.close());
            $('grid-size').addEventListener('input', () => {
                const value = $('grid-size').value; $('grid-size-value').textContent = value;
                $('grid-container').style.gridTemplateColumns = `repeat(${value}, 1fr)`;
                if (appState.grid.selected.length === 1) { setTimeout(() => gridView.focusOnSelectedItem(appState.grid.selected[0]), 100); }
            });
            $('select-all-btn').addEventListener('click', () => gridView.selectAll());
            $('deselect-all-btn').addEventListener('click', () => gridView.deselectAll());
            $('grid-container')?.addEventListener('click', e => { if (e.target === $('grid-container')) { e.stopPropagation(); } });
            $('center-image').addEventListener('error', function(e) {
                if (!e.target.src || e.target.src === 'data:,' || e.target.src === window.location.href) return;
                utils.toast('Failed to load image', 'error');
                const currentFile = appState.images[appState.currentIdx];
                if (currentFile) {
                    const fallbackUrl = appState.providerType === 'googledrive' ? currentFile.webContentLink : currentFile.downloadUrl;
                    if (fallbackUrl && e.target.src !== fallbackUrl) { e.target.src = fallbackUrl;
                    } else { e.target.src = ''; e.target.alt = 'Image failed to load'; }
                } else { e.target.src = ''; e.target.alt = 'No image available'; }
            });
            $$('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const stack = tab.dataset.stack;
                    $$('.tab').forEach(t => t.classList.remove('active')); $$('.tab-pane').forEach(p => p.classList.remove('active'));
                    tab.classList.add('active');
                    document.querySelector(`.tab-pane[data-stack="${stack}"]`).classList.add('active');
                    appState.currentStack = stack;
                    if (appState.stacks[stack].length > 0) {
                        const firstFile = appState.stacks[stack][0];
                        const index = appState.images.findIndex(f => f.id === firstFile.id);
                        if (index !== -1) { appState.currentIdx = index; imageViewer.display(); }
                    } else { $('empty-state').classList.remove('hidden'); $('center-image').src = ''; $('center-image').alt = 'No images in this stack'; $('header-filename').textContent = ''; }
                });
            });

            gestureHandler.setup(); modalManager.setup(); privacyMode.setup();
            window.addEventListener('orientationchange', () => { setTimeout(utils.applyOptimalLayout, 250); });
            window.addEventListener('resize', utils.applyOptimalLayout);

            // Start with provider selection
            utils.showScreen('provider-screen');
            utils.applyOptimalLayout();
        }

        if (window.location.search.includes('code=') || window.location.search.includes('error=')) {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code'); const error = urlParams.get('error');
            if (window.opener) {
                if (error) { window.opener.postMessage({ type: 'GOOGLE_AUTH_ERROR', error: error }, window.location.origin);
                } else if (code) { window.opener.postMessage({ type: 'GOOGLE_AUTH_SUCCESS', code: code }, window.location.origin); }
                window.close();
            }
        }
        window.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>