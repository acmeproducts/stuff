<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thai Transcriber & Translator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');
        
        :root {
            --bg-deep: #0a0a0f;
            --bg-surface: #12121a;
            --bg-elevated: #1a1a25;
            --bg-hover: #22222f;
            --border-subtle: #2a2a3a;
            --border-accent: #4a4a6a;
            --text-primary: #e8e8f0;
            --text-secondary: #9090a8;
            --text-muted: #606078;
            --accent-gold: #d4a853;
            --accent-gold-dim: #a88a43;
            --accent-thai: #2d7d9a;
            --accent-thai-light: #3a9fc4;
            --accent-english: #7d5ba6;
            --accent-english-light: #9a7bc4;
            --success: #4a9d6a;
            --warning: #c4883a;
            --error: #c45a5a;
            --gradient-gold: linear-gradient(135deg, #d4a853 0%, #a88a43 100%);
            --gradient-surface: linear-gradient(180deg, #1a1a25 0%, #12121a 100%);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Sarabun', sans-serif;
            background: var(--bg-deep);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }
        
        .app-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            min-height: 100vh;
        }
        
        /* Header */
        .app-header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem 0;
            border-bottom: 1px solid var(--border-subtle);
        }
        
        .app-title {
            font-size: 2.5rem;
            font-weight: 300;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
            background: var(--gradient-gold);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .app-subtitle {
            color: var(--text-secondary);
            font-weight: 300;
            font-size: 1.1rem;
        }
        
        .thai-script {
            font-size: 0.9rem;
            color: var(--accent-thai-light);
            margin-top: 0.25rem;
        }
        
        /* Main Layout */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }
        
        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Panels */
        .panel {
            background: var(--gradient-surface);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            overflow: hidden;
        }
        
        .panel-header {
            padding: 1.25rem 1.5rem;
            background: var(--bg-elevated);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .panel-title {
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--text-secondary);
        }
        
        .panel-content {
            padding: 1.5rem;
        }
        
        /* Upload Zone */
        .upload-zone {
            border: 2px dashed var(--border-accent);
            border-radius: 8px;
            padding: 3rem 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(42, 42, 58, 0.2);
        }
        
        .upload-zone:hover,
        .upload-zone.dragover {
            border-color: var(--accent-gold);
            background: rgba(212, 168, 83, 0.05);
        }
        
        .upload-zone.has-file {
            border-color: var(--success);
            background: rgba(74, 157, 106, 0.05);
        }
        
        .upload-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.6;
        }
        
        .upload-text {
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }
        
        .upload-hint {
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        .file-input {
            display: none;
        }
        
        /* File Info */
        .file-info {
            margin-top: 1.5rem;
            padding: 1rem;
            background: var(--bg-elevated);
            border-radius: 8px;
            display: none;
        }
        
        .file-info.visible {
            display: block;
        }
        
        .file-name {
            font-weight: 500;
            color: var(--accent-gold);
            margin-bottom: 0.5rem;
            word-break: break-all;
        }
        
        .file-meta {
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        /* Audio Player */
        .audio-player {
            margin-top: 1.5rem;
            display: none;
        }
        
        .audio-player.visible {
            display: block;
        }
        
        .audio-player audio {
            width: 100%;
            height: 40px;
            border-radius: 8px;
        }
        
        /* Controls */
        .controls-section {
            margin-top: 1.5rem;
        }
        
        .control-group {
            margin-bottom: 1.25rem;
        }
        
        .control-label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .control-row {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        
        /* Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-primary {
            background: var(--gradient-gold);
            color: var(--bg-deep);
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(212, 168, 83, 0.3);
        }
        
        .btn-secondary {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border: 1px solid var(--border-accent);
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: var(--bg-hover);
            border-color: var(--accent-gold-dim);
        }
        
        .btn-danger {
            background: var(--error);
            color: white;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-icon {
            font-size: 1.1rem;
        }
        
        /* Toggle Switch */
        .toggle-group {
            display: flex;
            background: var(--bg-elevated);
            border-radius: 6px;
            padding: 4px;
            border: 1px solid var(--border-subtle);
        }
        
        .toggle-btn {
            padding: 0.5rem 1rem;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 0.85rem;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .toggle-btn.active {
            background: var(--accent-thai);
            color: white;
        }
        
        .toggle-btn.active.english {
            background: var(--accent-english);
        }
        
        /* Progress */
        .progress-section {
            margin-top: 1.5rem;
            display: none;
        }
        
        .progress-section.visible {
            display: block;
        }
        
        .progress-bar-container {
            height: 8px;
            background: var(--bg-elevated);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 0.75rem;
        }
        
        .progress-bar {
            height: 100%;
            background: var(--gradient-gold);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }
        
        .progress-text {
            font-size: 0.85rem;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
        }
        
        /* Transcript Panel */
        .transcript-container {
            max-height: 600px;
            overflow-y: auto;
            padding-right: 0.5rem;
        }
        
        .transcript-container::-webkit-scrollbar {
            width: 6px;
        }
        
        .transcript-container::-webkit-scrollbar-track {
            background: var(--bg-elevated);
            border-radius: 3px;
        }
        
        .transcript-container::-webkit-scrollbar-thumb {
            background: var(--border-accent);
            border-radius: 3px;
        }
        
        .transcript-empty {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-muted);
        }
        
        .transcript-empty-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.4;
        }
        
        /* Transcript Segments */
        .segment {
            padding: 1rem;
            margin-bottom: 0.75rem;
            border-radius: 8px;
            border-left: 3px solid;
            background: var(--bg-elevated);
            transition: all 0.2s ease;
        }
        
        .segment:hover {
            background: var(--bg-hover);
        }
        
        .segment.thai {
            border-color: var(--accent-thai);
        }
        
        .segment.english {
            border-color: var(--accent-english);
        }
        
        .segment-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
        }
        
        .segment-lang {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
        }
        
        .segment.thai .segment-lang {
            background: rgba(45, 125, 154, 0.2);
            color: var(--accent-thai-light);
        }
        
        .segment.english .segment-lang {
            background: rgba(125, 91, 166, 0.2);
            color: var(--accent-english-light);
        }
        
        .segment-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .segment-original {
            margin-bottom: 0.5rem;
            line-height: 1.8;
        }
        
        .segment-translation {
            color: var(--accent-gold);
            font-style: italic;
            padding-left: 1rem;
            border-left: 2px solid var(--accent-gold-dim);
            margin-top: 0.5rem;
        }
        
        /* Status Messages */
        .status-bar {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 1rem 2rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border-accent);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: none;
            z-index: 100;
        }
        
        .status-bar.visible {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .status-bar.error {
            border-color: var(--error);
        }
        
        .status-bar.success {
            border-color: var(--success);
        }
        
        .status-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-accent);
            border-top-color: var(--accent-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Export Panel */
        .export-section {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-subtle);
        }
        
        /* Info Box */
        .info-box {
            background: rgba(45, 125, 154, 0.1);
            border: 1px solid var(--accent-thai);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1.5rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .info-box-title {
            font-weight: 600;
            color: var(--accent-thai-light);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        /* Model Loading */
        .model-status {
            padding: 1rem;
            background: var(--bg-elevated);
            border-radius: 8px;
            margin-bottom: 1rem;
            border: 1px solid var(--border-subtle);
        }
        
        .model-status-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        
        .model-status-row:last-child {
            margin-bottom: 0;
        }
        
        .model-name {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .model-badge {
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            font-weight: 500;
        }
        
        .model-badge.loading {
            background: rgba(196, 136, 58, 0.2);
            color: var(--warning);
        }
        
        .model-badge.ready {
            background: rgba(74, 157, 106, 0.2);
            color: var(--success);
        }
        
        .model-badge.error {
            background: rgba(196, 90, 90, 0.2);
            color: var(--error);
        }
        
        /* Tabs */
        .tab-container {
            margin-bottom: 1rem;
        }
        
        .tab-buttons {
            display: flex;
            gap: 0;
            border-bottom: 1px solid var(--border-subtle);
        }
        
        .tab-btn {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-family: inherit;
            font-size: 0.85rem;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }
        
        .tab-btn:hover {
            color: var(--text-secondary);
        }
        
        .tab-btn.active {
            color: var(--accent-gold);
        }
        
        .tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent-gold);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Settings */
        .settings-grid {
            display: grid;
            gap: 1rem;
        }
        
        .setting-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            background: var(--bg-elevated);
            border-radius: 6px;
        }
        
        .setting-label {
            font-size: 0.9rem;
        }
        
        .setting-select {
            background: var(--bg-deep);
            border: 1px solid var(--border-accent);
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.85rem;
        }
        
        /* Live Recording */
        .recording-indicator {
            display: none;
            align-items: center;
            gap: 0.5rem;
            color: var(--error);
            font-weight: 500;
        }
        
        .recording-indicator.visible {
            display: flex;
        }
        
        .recording-dot {
            width: 10px;
            height: 10px;
            background: var(--error);
            border-radius: 50%;
            animation: pulse 1s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
        
        /* Full width for single column on small screens */
        .full-width-panel {
            grid-column: 1 / -1;
        }
        
        /* Instructions Panel */
        .instructions {
            background: var(--bg-surface);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
        }
        
        .instructions h3 {
            color: var(--accent-gold);
            margin-bottom: 1rem;
            font-weight: 500;
        }
        
        .instructions ol {
            padding-left: 1.5rem;
            color: var(--text-secondary);
        }
        
        .instructions li {
            margin-bottom: 0.75rem;
        }
        
        .instructions code {
            background: var(--bg-elevated);
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--accent-thai-light);
        }
        
        /* Chunk indicator */
        .chunk-info {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            <h1 class="app-title">THAI TRANSCRIBER</h1>
            <p class="app-subtitle">Audio Transcription & Translation</p>
            <p class="thai-script">‡∏ñ‡∏≠‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏•‡∏∞‡πÅ‡∏õ‡∏•‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢</p>
        </header>

        <div class="instructions">
            <h3>‚ö° Quick Start Guide</h3>
            <ol>
                <li><strong>For best results:</strong> This app uses the <a href="https://github.com/openai/whisper" style="color: var(--accent-thai-light);">Whisper</a> model via Transformers.js - runs entirely in your browser, no server needed!</li>
                <li><strong>First load:</strong> The AI models will download (~150MB) and cache in your browser. This only happens once.</li>
                <li><strong>Large files:</strong> Audio is processed in chunks. 100MB files work fine - just be patient!</li>
                <li><strong>Offline capable:</strong> After first load, works offline (except translation API fallback)</li>
            </ol>
        </div>

        <div class="main-grid">
            <!-- Input Panel -->
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">üìÅ Audio Input</span>
                    <div class="recording-indicator" id="recordingIndicator">
                        <span class="recording-dot"></span>
                        <span>Recording...</span>
                    </div>
                </div>
                <div class="panel-content">
                    <!-- Tab Navigation -->
                    <div class="tab-container">
                        <div class="tab-buttons">
                            <button class="tab-btn active" data-tab="file">Upload File</button>
                            <button class="tab-btn" data-tab="record">Live Record</button>
                            <button class="tab-btn" data-tab="settings">Settings</button>
                        </div>
                    </div>

                    <!-- File Upload Tab -->
                    <div class="tab-content active" id="tab-file">
                        <div class="upload-zone" id="uploadZone">
                            <div class="upload-icon">üéµ</div>
                            <p class="upload-text">Drop audio file here or click to browse</p>
                            <p class="upload-hint">Supports: MP3, M4A, WAV, OGG, WEBM, FLAC (up to 500MB)</p>
                            <input type="file" class="file-input" id="fileInput" accept="audio/*,.m4a,.mp3,.wav,.ogg,.webm,.flac">
                        </div>

                        <div class="file-info" id="fileInfo">
                            <div class="file-name" id="fileName"></div>
                            <div class="file-meta" id="fileMeta"></div>
                        </div>

                        <div class="audio-player" id="audioPlayer">
                            <audio id="audioElement" controls></audio>
                        </div>
                    </div>

                    <!-- Live Record Tab -->
                    <div class="tab-content" id="tab-record">
                        <div class="control-row" style="justify-content: center; padding: 2rem 0;">
                            <button class="btn btn-primary" id="startRecordBtn">
                                <span class="btn-icon">üé§</span> Start Recording
                            </button>
                            <button class="btn btn-danger" id="stopRecordBtn" disabled>
                                <span class="btn-icon">‚èπ</span> Stop
                            </button>
                        </div>
                        <div class="info-box">
                            <div class="info-box-title">‚ÑπÔ∏è Live Recording</div>
                            <p>Records from your microphone and transcribes in real-time. Make sure to allow microphone access when prompted.</p>
                        </div>
                    </div>

                    <!-- Settings Tab -->
                    <div class="tab-content" id="tab-settings">
                        <div class="settings-grid">
                            <div class="setting-item">
                                <span class="setting-label">Whisper Model Size</span>
                                <select class="setting-select" id="modelSize">
                                    <option value="tiny">Tiny (fastest, less accurate)</option>
                                    <option value="base" selected>Base (balanced)</option>
                                    <option value="small">Small (more accurate, slower)</option>
                                </select>
                            </div>
                            <div class="setting-item">
                                <span class="setting-label">Chunk Duration (seconds)</span>
                                <select class="setting-select" id="chunkDuration">
                                    <option value="30">30s (faster processing)</option>
                                    <option value="60" selected>60s (balanced)</option>
                                    <option value="120">120s (better context)</option>
                                </select>
                            </div>
                            <div class="setting-item">
                                <span class="setting-label">Translation Service</span>
                                <select class="setting-select" id="translationService">
                                    <option value="transformers" selected>Transformers.js (offline)</option>
                                    <option value="libretranslate">LibreTranslate (online)</option>
                                    <option value="none">No Translation</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="model-status" id="modelStatus">
                            <div class="model-status-row">
                                <span class="model-name">Whisper Model</span>
                                <span class="model-badge" id="whisperStatus">Not Loaded</span>
                            </div>
                            <div class="model-status-row">
                                <span class="model-name">Translation Model</span>
                                <span class="model-badge" id="translationStatus">Not Loaded</span>
                            </div>
                        </div>
                        
                        <button class="btn btn-secondary" id="loadModelsBtn" style="width: 100%;">
                            <span class="btn-icon">‚¨áÔ∏è</span> Pre-load Models
                        </button>
                    </div>

                    <!-- Controls -->
                    <div class="controls-section">
                        <div class="control-group">
                            <span class="control-label">Source Language</span>
                            <div class="toggle-group">
                                <button class="toggle-btn active" data-lang="th">üáπüá≠ Thai</button>
                                <button class="toggle-btn" data-lang="en">üá∫üá∏ English</button>
                                <button class="toggle-btn" data-lang="auto">üîÑ Auto-detect</button>
                            </div>
                        </div>

                        <div class="control-row">
                            <button class="btn btn-primary" id="transcribeBtn" disabled>
                                <span class="btn-icon">‚ñ∂Ô∏è</span> Transcribe
                            </button>
                            <button class="btn btn-secondary" id="clearBtn">
                                <span class="btn-icon">üóëÔ∏è</span> Clear All
                            </button>
                        </div>
                    </div>

                    <!-- Progress -->
                    <div class="progress-section" id="progressSection">
                        <div class="progress-bar-container">
                            <div class="progress-bar" id="progressBar"></div>
                        </div>
                        <div class="progress-text">
                            <span id="progressStatus">Initializing...</span>
                            <span id="progressPercent">0%</span>
                        </div>
                        <div class="chunk-info" id="chunkInfo"></div>
                    </div>
                </div>
            </div>

            <!-- Output Panel -->
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">üìù Transcript</span>
                    <div class="control-row">
                        <button class="btn btn-secondary" id="copyBtn" style="padding: 0.5rem 1rem; font-size: 0.8rem;">
                            üìã Copy
                        </button>
                        <button class="btn btn-secondary" id="exportBtn" style="padding: 0.5rem 1rem; font-size: 0.8rem;">
                            üíæ Export
                        </button>
                    </div>
                </div>
                <div class="panel-content">
                    <div class="transcript-container" id="transcriptContainer">
                        <div class="transcript-empty">
                            <div class="transcript-empty-icon">üéß</div>
                            <p>Upload an audio file and click "Transcribe" to begin</p>
                            <p style="margin-top: 0.5rem; font-size: 0.85rem;">Thai speech will be automatically detected and translated to English</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar" id="statusBar">
        <div class="status-spinner"></div>
        <span id="statusText">Processing...</span>
    </div>

    <script type="module">
        // ============================================
        // THAI TRANSCRIBER - Main Application
        // Uses Transformers.js for local AI processing
        // ============================================

        // State Management
        const state = {
            audioFile: null,
            audioContext: null,
            audioBuffer: null,
            whisperPipeline: null,
            translatorPipeline: null,
            isProcessing: false,
            isRecording: false,
            mediaRecorder: null,
            recordedChunks: [],
            segments: [],
            sourceLang: 'th',
            modelSize: 'base',
            chunkDuration: 60,
            translationService: 'transformers'
        };

        // DOM Elements
        const elements = {
            uploadZone: document.getElementById('uploadZone'),
            fileInput: document.getElementById('fileInput'),
            fileInfo: document.getElementById('fileInfo'),
            fileName: document.getElementById('fileName'),
            fileMeta: document.getElementById('fileMeta'),
            audioPlayer: document.getElementById('audioPlayer'),
            audioElement: document.getElementById('audioElement'),
            transcribeBtn: document.getElementById('transcribeBtn'),
            clearBtn: document.getElementById('clearBtn'),
            copyBtn: document.getElementById('copyBtn'),
            exportBtn: document.getElementById('exportBtn'),
            progressSection: document.getElementById('progressSection'),
            progressBar: document.getElementById('progressBar'),
            progressStatus: document.getElementById('progressStatus'),
            progressPercent: document.getElementById('progressPercent'),
            chunkInfo: document.getElementById('chunkInfo'),
            transcriptContainer: document.getElementById('transcriptContainer'),
            statusBar: document.getElementById('statusBar'),
            statusText: document.getElementById('statusText'),
            startRecordBtn: document.getElementById('startRecordBtn'),
            stopRecordBtn: document.getElementById('stopRecordBtn'),
            recordingIndicator: document.getElementById('recordingIndicator'),
            loadModelsBtn: document.getElementById('loadModelsBtn'),
            whisperStatus: document.getElementById('whisperStatus'),
            translationStatus: document.getElementById('translationStatus'),
            modelSize: document.getElementById('modelSize'),
            chunkDuration: document.getElementById('chunkDuration'),
            translationService: document.getElementById('translationService')
        };

        // ============================================
        // Transformers.js Loading
        // ============================================
        
        let transformers = null;
        
        async function loadTransformers() {
            if (transformers) return transformers;
            
            showStatus('Loading AI framework...', false);
            
            try {
                // Dynamic import of transformers.js
                transformers = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2');
                console.log('Transformers.js loaded successfully');
                return transformers;
            } catch (error) {
                console.error('Failed to load Transformers.js:', error);
                throw new Error('Failed to load AI framework. Please check your internet connection.');
            }
        }

        // ============================================
        // Whisper Model Loading & Transcription
        // ============================================

        async function loadWhisperModel() {
            const tf = await loadTransformers();
            
            if (state.whisperPipeline) {
                return state.whisperPipeline;
            }

            const modelName = `Xenova/whisper-${state.modelSize}`;
            updateModelStatus('whisperStatus', 'loading', 'Loading...');
            showStatus(`Loading Whisper ${state.modelSize} model...`, false);

            try {
                state.whisperPipeline = await tf.pipeline(
                    'automatic-speech-recognition',
                    modelName,
                    {
                        quantized: true,
                        progress_callback: (progress) => {
                            if (progress.status === 'downloading') {
                                const percent = Math.round((progress.loaded / progress.total) * 100);
                                updateProgress(percent, `Downloading model: ${progress.file}`);
                            }
                        }
                    }
                );
                
                updateModelStatus('whisperStatus', 'ready', 'Ready');
                hideStatus();
                return state.whisperPipeline;
            } catch (error) {
                updateModelStatus('whisperStatus', 'error', 'Error');
                throw error;
            }
        }

        async function loadTranslationModel() {
            if (state.translationService !== 'transformers') {
                updateModelStatus('translationStatus', 'ready', state.translationService === 'none' ? 'Disabled' : 'API');
                return null;
            }

            const tf = await loadTransformers();
            
            if (state.translatorPipeline) {
                return state.translatorPipeline;
            }

            updateModelStatus('translationStatus', 'loading', 'Loading...');
            showStatus('Loading translation model...', false);

            try {
                // Using Helsinki-NLP translation model
                state.translatorPipeline = await tf.pipeline(
                    'translation',
                    'Xenova/opus-mt-th-en',
                    {
                        quantized: true,
                        progress_callback: (progress) => {
                            if (progress.status === 'downloading') {
                                const percent = Math.round((progress.loaded / progress.total) * 100);
                                updateProgress(percent, `Downloading translation model: ${progress.file}`);
                            }
                        }
                    }
                );
                
                updateModelStatus('translationStatus', 'ready', 'Ready');
                hideStatus();
                return state.translatorPipeline;
            } catch (error) {
                console.warn('Translation model failed to load:', error);
                updateModelStatus('translationStatus', 'error', 'Error');
                // Don't throw - translation is optional
                return null;
            }
        }

        // ============================================
        // Audio Processing
        // ============================================

        async function loadAudioFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        state.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                            sampleRate: 16000 // Whisper expects 16kHz
                        });
                        state.audioBuffer = await state.audioContext.decodeAudioData(e.target.result);
                        resolve(state.audioBuffer);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        function getAudioChunks(audioBuffer, chunkDurationSec) {
            const sampleRate = audioBuffer.sampleRate;
            const totalSamples = audioBuffer.length;
            const chunkSamples = chunkDurationSec * sampleRate;
            const chunks = [];
            
            for (let start = 0; start < totalSamples; start += chunkSamples) {
                const end = Math.min(start + chunkSamples, totalSamples);
                const chunkLength = end - start;
                const chunkBuffer = new Float32Array(chunkLength);
                
                // Get mono audio (use first channel)
                audioBuffer.copyFromChannel(chunkBuffer, 0, start);
                
                chunks.push({
                    audio: chunkBuffer,
                    startTime: start / sampleRate,
                    endTime: end / sampleRate
                });
            }
            
            return chunks;
        }

        function resampleAudio(audioData, fromSampleRate, toSampleRate) {
            if (fromSampleRate === toSampleRate) {
                return audioData;
            }
            
            const ratio = fromSampleRate / toSampleRate;
            const newLength = Math.round(audioData.length / ratio);
            const result = new Float32Array(newLength);
            
            for (let i = 0; i < newLength; i++) {
                const srcIndex = i * ratio;
                const srcIndexFloor = Math.floor(srcIndex);
                const srcIndexCeil = Math.min(srcIndexFloor + 1, audioData.length - 1);
                const t = srcIndex - srcIndexFloor;
                result[i] = audioData[srcIndexFloor] * (1 - t) + audioData[srcIndexCeil] * t;
            }
            
            return result;
        }

        // ============================================
        // Transcription & Translation
        // ============================================

        async function transcribeChunk(audioData, language) {
            const whisper = await loadWhisperModel();
            
            // Resample to 16kHz if needed
            const targetSampleRate = 16000;
            const currentSampleRate = state.audioContext?.sampleRate || 16000;
            const resampledAudio = resampleAudio(audioData, currentSampleRate, targetSampleRate);
            
            const options = {
                language: language === 'auto' ? null : language,
                task: 'transcribe',
                return_timestamps: true,
                chunk_length_s: 30,
                stride_length_s: 5
            };

            const result = await whisper(resampledAudio, options);
            return result;
        }

        async function translateText(text, fromLang) {
            if (!text || text.trim() === '') return '';
            if (fromLang === 'en') return ''; // No need to translate English
            
            if (state.translationService === 'none') {
                return '';
            }
            
            if (state.translationService === 'transformers') {
                try {
                    const translator = await loadTranslationModel();
                    if (!translator) return '';
                    
                    const result = await translator(text, {
                        max_length: 512
                    });
                    
                    return result[0]?.translation_text || '';
                } catch (error) {
                    console.warn('Translation failed:', error);
                    return '';
                }
            }
            
            if (state.translationService === 'libretranslate') {
                try {
                    // Try public LibreTranslate instance
                    const response = await fetch('https://libretranslate.com/translate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            q: text,
                            source: 'th',
                            target: 'en',
                            format: 'text'
                        })
                    });
                    
                    if (!response.ok) throw new Error('API error');
                    const data = await response.json();
                    return data.translatedText || '';
                } catch (error) {
                    console.warn('LibreTranslate failed:', error);
                    return '';
                }
            }
            
            return '';
        }

        function detectLanguage(text) {
            // Simple Thai detection based on character ranges
            const thaiPattern = /[\u0E00-\u0E7F]/;
            const thaiChars = (text.match(/[\u0E00-\u0E7F]/g) || []).length;
            const totalChars = text.replace(/\s/g, '').length;
            
            if (totalChars === 0) return 'unknown';
            
            const thaiRatio = thaiChars / totalChars;
            return thaiRatio > 0.3 ? 'th' : 'en';
        }

        // ============================================
        // Main Processing Pipeline
        // ============================================

        async function processAudio() {
            if (state.isProcessing || !state.audioFile) return;
            
            state.isProcessing = true;
            state.segments = [];
            elements.transcribeBtn.disabled = true;
            elements.progressSection.classList.add('visible');
            clearTranscript();

            try {
                // Load audio
                updateProgress(5, 'Loading audio file...');
                const audioBuffer = await loadAudioFile(state.audioFile);
                
                // Load models
                updateProgress(10, 'Loading AI models...');
                await loadWhisperModel();
                if (state.translationService === 'transformers') {
                    await loadTranslationModel();
                }
                
                // Chunk audio
                const chunks = getAudioChunks(audioBuffer, state.chunkDuration);
                const totalChunks = chunks.length;
                
                updateProgress(15, `Processing ${totalChunks} chunks...`);
                elements.chunkInfo.textContent = `Total duration: ${formatTime(audioBuffer.duration)} | ${totalChunks} chunks`;
                
                // Process each chunk
                for (let i = 0; i < chunks.length; i++) {
                    const chunk = chunks[i];
                    const chunkProgress = 15 + ((i / totalChunks) * 75);
                    
                    updateProgress(
                        chunkProgress,
                        `Transcribing chunk ${i + 1}/${totalChunks}...`
                    );
                    elements.chunkInfo.textContent = `Chunk ${i + 1}/${totalChunks} | ${formatTime(chunk.startTime)} - ${formatTime(chunk.endTime)}`;
                    
                    // Transcribe
                    const result = await transcribeChunk(chunk.audio, state.sourceLang);
                    
                    if (result && result.text) {
                        const text = result.text.trim();
                        if (text) {
                            const detectedLang = state.sourceLang === 'auto' 
                                ? detectLanguage(text) 
                                : state.sourceLang;
                            
                            // Translate if Thai
                            let translation = '';
                            if (detectedLang === 'th' && state.translationService !== 'none') {
                                updateProgress(chunkProgress + 2, `Translating chunk ${i + 1}...`);
                                translation = await translateText(text, detectedLang);
                            }
                            
                            const segment = {
                                startTime: chunk.startTime,
                                endTime: chunk.endTime,
                                text: text,
                                language: detectedLang,
                                translation: translation
                            };
                            
                            state.segments.push(segment);
                            appendSegment(segment);
                        }
                    }
                }
                
                updateProgress(100, 'Complete!');
                showStatus('Transcription complete!', false, 'success');
                
                setTimeout(() => {
                    elements.progressSection.classList.remove('visible');
                    hideStatus();
                }, 2000);
                
            } catch (error) {
                console.error('Processing error:', error);
                showStatus(`Error: ${error.message}`, true);
            } finally {
                state.isProcessing = false;
                elements.transcribeBtn.disabled = false;
            }
        }

        // ============================================
        // Live Recording
        // ============================================

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                state.mediaRecorder = new MediaRecorder(stream);
                state.recordedChunks = [];
                
                state.mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        state.recordedChunks.push(e.data);
                    }
                };
                
                state.mediaRecorder.onstop = async () => {
                    const blob = new Blob(state.recordedChunks, { type: 'audio/webm' });
                    state.audioFile = new File([blob], 'recording.webm', { type: 'audio/webm' });
                    
                    // Update UI
                    elements.fileInfo.classList.add('visible');
                    elements.fileName.textContent = 'recording.webm';
                    elements.fileMeta.textContent = `Size: ${formatFileSize(blob.size)} | Recorded just now`;
                    
                    elements.audioElement.src = URL.createObjectURL(blob);
                    elements.audioPlayer.classList.add('visible');
                    elements.transcribeBtn.disabled = false;
                    
                    // Stop all tracks
                    stream.getTracks().forEach(track => track.stop());
                };
                
                state.mediaRecorder.start(1000); // Collect data every second
                state.isRecording = true;
                
                elements.startRecordBtn.disabled = true;
                elements.stopRecordBtn.disabled = false;
                elements.recordingIndicator.classList.add('visible');
                
            } catch (error) {
                console.error('Recording error:', error);
                showStatus('Could not access microphone. Please check permissions.', true);
            }
        }

        function stopRecording() {
            if (state.mediaRecorder && state.isRecording) {
                state.mediaRecorder.stop();
                state.isRecording = false;
                
                elements.startRecordBtn.disabled = false;
                elements.stopRecordBtn.disabled = true;
                elements.recordingIndicator.classList.remove('visible');
            }
        }

        // ============================================
        // UI Helpers
        // ============================================

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function updateProgress(percent, status) {
            elements.progressBar.style.width = percent + '%';
            elements.progressPercent.textContent = Math.round(percent) + '%';
            if (status) {
                elements.progressStatus.textContent = status;
            }
        }

        function showStatus(message, isError = false, type = null) {
            elements.statusBar.classList.add('visible');
            elements.statusBar.classList.remove('error', 'success');
            if (isError) elements.statusBar.classList.add('error');
            if (type === 'success') elements.statusBar.classList.add('success');
            elements.statusText.textContent = message;
        }

        function hideStatus() {
            elements.statusBar.classList.remove('visible');
        }

        function updateModelStatus(elementId, status, text) {
            const el = document.getElementById(elementId);
            el.textContent = text;
            el.className = 'model-badge ' + status;
        }

        function clearTranscript() {
            elements.transcriptContainer.innerHTML = `
                <div class="transcript-empty">
                    <div class="transcript-empty-icon">üéß</div>
                    <p>Upload an audio file and click "Transcribe" to begin</p>
                    <p style="margin-top: 0.5rem; font-size: 0.85rem;">Thai speech will be automatically detected and translated to English</p>
                </div>
            `;
        }

        function appendSegment(segment) {
            // Remove empty state if present
            const emptyState = elements.transcriptContainer.querySelector('.transcript-empty');
            if (emptyState) emptyState.remove();
            
            const div = document.createElement('div');
            div.className = `segment ${segment.language}`;
            
            let html = `
                <div class="segment-header">
                    <span class="segment-lang">${segment.language === 'th' ? 'üáπüá≠ Thai' : 'üá∫üá∏ English'}</span>
                    <span class="segment-time">${formatTime(segment.startTime)} - ${formatTime(segment.endTime)}</span>
                </div>
                <div class="segment-original">${escapeHtml(segment.text)}</div>
            `;
            
            if (segment.translation) {
                html += `<div class="segment-translation">${escapeHtml(segment.translation)}</div>`;
            }
            
            div.innerHTML = html;
            elements.transcriptContainer.appendChild(div);
            
            // Scroll to bottom
            elements.transcriptContainer.scrollTop = elements.transcriptContainer.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============================================
        // Export Functions
        // ============================================

        function copyToClipboard() {
            if (state.segments.length === 0) {
                showStatus('No transcript to copy', true);
                return;
            }
            
            const text = state.segments.map(s => {
                let line = `[${formatTime(s.startTime)}] ${s.text}`;
                if (s.translation) {
                    line += `\n    ‚Üí ${s.translation}`;
                }
                return line;
            }).join('\n\n');
            
            navigator.clipboard.writeText(text).then(() => {
                showStatus('Copied to clipboard!', false, 'success');
                setTimeout(hideStatus, 2000);
            }).catch(err => {
                showStatus('Failed to copy', true);
            });
        }

        function exportTranscript() {
            if (state.segments.length === 0) {
                showStatus('No transcript to export', true);
                return;
            }
            
            const data = {
                exportDate: new Date().toISOString(),
                fileName: state.audioFile?.name || 'recording',
                segments: state.segments
            };
            
            // JSON export
            const jsonBlob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const jsonUrl = URL.createObjectURL(jsonBlob);
            
            // Text export
            const textContent = state.segments.map(s => {
                let line = `[${formatTime(s.startTime)} - ${formatTime(s.endTime)}] (${s.language.toUpperCase()})\n${s.text}`;
                if (s.translation) {
                    line += `\n‚Üí English: ${s.translation}`;
                }
                return line;
            }).join('\n\n---\n\n');
            
            const textBlob = new Blob([textContent], { type: 'text/plain' });
            const textUrl = URL.createObjectURL(textBlob);
            
            // Create download links
            const baseName = (state.audioFile?.name || 'transcript').replace(/\.[^/.]+$/, '');
            
            const jsonLink = document.createElement('a');
            jsonLink.href = jsonUrl;
            jsonLink.download = `${baseName}_transcript.json`;
            jsonLink.click();
            
            setTimeout(() => {
                const textLink = document.createElement('a');
                textLink.href = textUrl;
                textLink.download = `${baseName}_transcript.txt`;
                textLink.click();
                
                showStatus('Exported JSON and TXT files', false, 'success');
                setTimeout(hideStatus, 2000);
            }, 500);
        }

        // ============================================
        // Event Listeners
        // ============================================

        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                btn.classList.add('active');
                document.getElementById(`tab-${btn.dataset.tab}`).classList.add('active');
            });
        });

        // Language toggle
        document.querySelectorAll('.toggle-btn[data-lang]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.toggle-btn[data-lang]').forEach(b => {
                    b.classList.remove('active', 'english');
                });
                btn.classList.add('active');
                if (btn.dataset.lang === 'en') btn.classList.add('english');
                state.sourceLang = btn.dataset.lang;
            });
        });

        // File upload
        elements.uploadZone.addEventListener('click', () => elements.fileInput.click());
        
        elements.uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.uploadZone.classList.add('dragover');
        });
        
        elements.uploadZone.addEventListener('dragleave', () => {
            elements.uploadZone.classList.remove('dragover');
        });
        
        elements.uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.uploadZone.classList.remove('dragover');
            
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('audio/')) {
                handleFileSelect(file);
            }
        });
        
        elements.fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                handleFileSelect(e.target.files[0]);
            }
        });

        function handleFileSelect(file) {
            state.audioFile = file;
            
            elements.uploadZone.classList.add('has-file');
            elements.fileInfo.classList.add('visible');
            elements.fileName.textContent = file.name;
            elements.fileMeta.textContent = `Size: ${formatFileSize(file.size)} | Type: ${file.type || 'audio'}`;
            
            elements.audioElement.src = URL.createObjectURL(file);
            elements.audioPlayer.classList.add('visible');
            elements.transcribeBtn.disabled = false;
        }

        // Settings
        elements.modelSize.addEventListener('change', (e) => {
            state.modelSize = e.target.value;
            state.whisperPipeline = null; // Force reload
            updateModelStatus('whisperStatus', '', 'Not Loaded');
        });
        
        elements.chunkDuration.addEventListener('change', (e) => {
            state.chunkDuration = parseInt(e.target.value);
        });
        
        elements.translationService.addEventListener('change', (e) => {
            state.translationService = e.target.value;
            state.translatorPipeline = null;
            updateModelStatus('translationStatus', '', state.translationService === 'none' ? 'Disabled' : 'Not Loaded');
        });

        // Buttons
        elements.transcribeBtn.addEventListener('click', processAudio);
        
        elements.clearBtn.addEventListener('click', () => {
            state.audioFile = null;
            state.segments = [];
            elements.uploadZone.classList.remove('has-file');
            elements.fileInfo.classList.remove('visible');
            elements.audioPlayer.classList.remove('visible');
            elements.transcribeBtn.disabled = true;
            elements.progressSection.classList.remove('visible');
            clearTranscript();
        });
        
        elements.copyBtn.addEventListener('click', copyToClipboard);
        elements.exportBtn.addEventListener('click', exportTranscript);
        
        elements.loadModelsBtn.addEventListener('click', async () => {
            elements.loadModelsBtn.disabled = true;
            elements.loadModelsBtn.innerHTML = '<span class="btn-icon">‚è≥</span> Loading...';
            
            try {
                elements.progressSection.classList.add('visible');
                await loadWhisperModel();
                if (state.translationService === 'transformers') {
                    await loadTranslationModel();
                }
                elements.progressSection.classList.remove('visible');
                showStatus('Models loaded successfully!', false, 'success');
                setTimeout(hideStatus, 2000);
            } catch (error) {
                showStatus(`Failed to load models: ${error.message}`, true);
            } finally {
                elements.loadModelsBtn.disabled = false;
                elements.loadModelsBtn.innerHTML = '<span class="btn-icon">‚¨áÔ∏è</span> Pre-load Models';
            }
        });
        
        elements.startRecordBtn.addEventListener('click', startRecording);
        elements.stopRecordBtn.addEventListener('click', stopRecording);

        // Initialize
        console.log('Thai Transcriber initialized');
        console.log('Using Transformers.js for local AI processing');
    </script>
</body>
</html>
