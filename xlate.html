<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thai Transcriber v7</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap');
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-primary: #0a0a0f; --bg-secondary: #12121a; --bg-tertiary: #1a1a24; --bg-elevated: #22222e;
            --border-primary: #2a2a3a; --border-secondary: #363648;
            --text-primary: #e8e8f0; --text-secondary: #a0a0b8; --text-muted: #606078;
            --accent-gold: #d4a853; --accent-gold-dim: #a07830;
            --accent-thai: #4a90c2; --accent-english: #9a70c2;
            --status-success: #48a068; --status-warning: #c08840; --status-error: #c05050;
        }
        html, body { height: 100%; overflow: hidden; }
        body { font-family: 'Sarabun', sans-serif; background: var(--bg-primary); color: var(--text-primary); line-height: 1.6; font-size: 14px; }
        .app-container { display: flex; flex-direction: column; height: 100vh; }
        .app-header { display: flex; align-items: center; justify-content: space-between; padding: 0.75rem 1rem; background: var(--bg-secondary); border-bottom: 1px solid var(--border-primary); }
        .app-logo { font-size: 1rem; font-weight: 300; letter-spacing: 0.2em; background: linear-gradient(135deg, var(--accent-gold), var(--accent-gold-dim)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .header-controls { display: flex; align-items: center; gap: 0.75rem; }
        .worker-status { display: flex; align-items: center; gap: 0.5rem; padding: 0.35rem 0.75rem; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: 20px; font-size: 0.7rem; font-family: 'JetBrains Mono', monospace; }
        .worker-dots { display: flex; gap: 3px; }
        .worker-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--border-secondary); }
        .worker-dot.loading { background: var(--status-warning); animation: pulse 1s infinite; }
        .worker-dot.ready { background: var(--status-success); }
        .worker-dot.working { background: var(--accent-gold); animation: pulse 0.5s infinite; }
        .worker-dot.error { background: var(--status-error); }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        .app-main { display: flex; flex: 1; overflow: hidden; }
        .sidebar { width: 220px; background: var(--bg-secondary); border-right: 1px solid var(--border-primary); display: flex; flex-direction: column; }
        .sidebar.collapsed { width: 0; overflow: hidden; }
        .sidebar-header { display: flex; justify-content: space-between; padding: 0.75rem 1rem; border-bottom: 1px solid var(--border-primary); font-size: 0.65rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); }
        .sidebar-sessions { flex: 1; overflow-y: auto; padding: 0.5rem; }
        .session-card { padding: 0.6rem 0.75rem; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: 6px; margin-bottom: 0.5rem; cursor: pointer; position: relative; }
        .session-card:hover { border-color: var(--border-secondary); }
        .session-card.active { border-color: var(--accent-gold); background: rgba(212, 168, 83, 0.08); }
        .session-card-date { font-size: 0.7rem; color: var(--text-secondary); }
        .session-card-name { font-size: 0.75rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .session-card-progress { display: flex; gap: 2px; margin-top: 0.3rem; }
        .session-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--border-secondary); }
        .session-dot.filled { background: var(--status-success); }
        .session-card-delete { position: absolute; top: 0.4rem; right: 0.4rem; width: 18px; height: 18px; border: none; background: var(--status-error); color: white; border-radius: 3px; font-size: 0.7rem; cursor: pointer; opacity: 0; }
        .session-card:hover .session-card-delete { opacity: 1; }
        .sidebar-footer { padding: 0.75rem; border-top: 1px solid var(--border-primary); }
        .new-btn { width: 100%; padding: 0.6rem; background: var(--bg-tertiary); border: 2px dashed var(--border-secondary); border-radius: 6px; color: var(--text-secondary); font-family: inherit; font-size: 0.75rem; cursor: pointer; }
        .new-btn:hover { border-color: var(--accent-gold); color: var(--accent-gold); }
        .content-area { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .content-header { display: flex; align-items: center; justify-content: space-between; padding: 0.75rem 1rem; background: var(--bg-secondary); border-bottom: 1px solid var(--border-primary); gap: 1rem; flex-wrap: wrap; }
        .content-header-left { display: flex; align-items: center; gap: 0.75rem; flex: 1; min-width: 0; }
        .sidebar-toggle { width: 32px; height: 32px; border: 1px solid var(--border-primary); background: var(--bg-tertiary); color: var(--text-secondary); border-radius: 6px; cursor: pointer; font-size: 1rem; }
        .session-info { flex: 1; min-width: 0; }
        .session-name-input { background: transparent; border: none; font-family: inherit; font-size: 0.95rem; font-weight: 500; color: var(--text-primary); width: 100%; padding: 0.2rem 0; border-bottom: 1px solid transparent; }
        .session-name-input:focus { outline: none; border-bottom-color: var(--accent-gold); }
        .session-meta { font-size: 0.7rem; color: var(--text-muted); font-family: 'JetBrains Mono', monospace; }
        .content-actions { display: flex; gap: 0.5rem; }
        .btn { padding: 0.5rem 1rem; border: none; border-radius: 5px; font-family: inherit; font-size: 0.75rem; font-weight: 500; cursor: pointer; display: inline-flex; align-items: center; gap: 0.35rem; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background: linear-gradient(135deg, var(--accent-gold), var(--accent-gold-dim)); color: var(--bg-primary); }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-primary); }
        .btn-danger { background: var(--status-warning); color: white; }
        .btn-ghost { background: transparent; color: var(--text-secondary); padding: 0.35rem 0.5rem; }
        .btn-sm { padding: 0.35rem 0.6rem; font-size: 0.7rem; }
        .btn-xs { padding: 0.2rem 0.4rem; font-size: 0.65rem; }
        .btn-icon { width: 32px; height: 32px; padding: 0; }
        .transcript-container { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .transcript-header { display: grid; grid-template-columns: 1fr 1fr; border-bottom: 1px solid var(--border-primary); background: var(--bg-secondary); }
        .column-header { display: flex; align-items: center; justify-content: space-between; padding: 0.6rem 1rem; }
        .column-header:first-child { border-right: 1px solid var(--border-primary); }
        .column-title { font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); }
        .transcript-scroll { flex: 1; overflow-y: auto; }
        .chunk-row { display: grid; grid-template-columns: 1fr 1fr; border-bottom: 1px solid var(--border-primary); }
        .chunk-row:hover { background: rgba(255, 255, 255, 0.02); }
        .chunk-row.filtered { opacity: 0.5; }
        .chunk-cell { padding: 0.75rem 1rem; min-height: 80px; }
        .chunk-cell:first-child { border-right: 1px solid var(--border-primary); }
        .chunk-header { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; flex-wrap: wrap; }
        .chunk-id { font-family: 'JetBrains Mono', monospace; font-size: 0.6rem; color: var(--text-muted); background: var(--bg-tertiary); padding: 0.15rem 0.4rem; border-radius: 3px; }
        .chunk-time { font-family: 'JetBrains Mono', monospace; font-size: 0.6rem; color: var(--text-muted); }
        .chunk-lang { font-size: 0.6rem; font-weight: 600; padding: 0.1rem 0.35rem; border-radius: 3px; }
        .chunk-lang.th { background: rgba(74, 144, 194, 0.15); color: var(--accent-thai); }
        .chunk-lang.en { background: rgba(154, 112, 194, 0.15); color: var(--accent-english); }
        .chunk-play { width: 22px; height: 22px; border: 1px solid var(--border-secondary); background: var(--bg-tertiary); color: var(--text-secondary); border-radius: 50%; font-size: 0.6rem; cursor: pointer; }
        .chunk-play:hover { background: var(--accent-gold); border-color: var(--accent-gold); color: var(--bg-primary); }
        .chunk-text { font-size: 0.9rem; line-height: 1.7; }
        .chunk-text.empty { color: var(--text-muted); font-style: italic; }
        .chunk-text.filtered { color: var(--status-warning); font-size: 0.8rem; }
        .chunk-actions { display: flex; gap: 0.3rem; margin-top: 0.5rem; opacity: 0; }
        .chunk-row:hover .chunk-actions { opacity: 1; }
        .chunk-action { padding: 0.2rem 0.4rem; font-size: 0.6rem; background: var(--bg-tertiary); border: 1px solid var(--border-primary); color: var(--text-secondary); border-radius: 3px; cursor: pointer; }
        .chunk-action:hover { background: var(--bg-elevated); color: var(--text-primary); }
        .back-translation { margin-top: 0.6rem; padding: 0.5rem 0.6rem; background: var(--bg-tertiary); border-radius: 4px; border-left: 2px solid var(--accent-gold-dim); }
        .back-translation-label { font-size: 0.6rem; color: var(--text-muted); margin-bottom: 0.25rem; display: flex; justify-content: space-between; }
        .back-translation-text { font-size: 0.8rem; color: var(--accent-gold); font-style: italic; }
        .empty-state { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; color: var(--text-muted); padding: 2rem; }
        .empty-icon { font-size: 3rem; margin-bottom: 1rem; opacity: 0.3; }
        .empty-title { font-size: 1rem; margin-bottom: 0.5rem; color: var(--text-secondary); }
        .drop-zone { margin-top: 1.5rem; padding: 2rem 3rem; border: 2px dashed var(--border-secondary); border-radius: 10px; cursor: pointer; text-align: center; }
        .drop-zone:hover { border-color: var(--accent-gold); background: rgba(212, 168, 83, 0.05); }
        .drop-zone.dragover { border-color: var(--accent-gold); background: rgba(212, 168, 83, 0.1); }
        .progress-bar-container { background: var(--bg-secondary); border-top: 1px solid var(--border-primary); padding: 0.6rem 1rem; display: none; }
        .progress-bar-container.visible { display: block; }
        .progress-header { display: flex; justify-content: space-between; margin-bottom: 0.4rem; font-size: 0.7rem; }
        .progress-stats { display: flex; gap: 1rem; font-size: 0.65rem; font-family: 'JetBrains Mono', monospace; color: var(--text-muted); }
        .progress-track { height: 6px; background: var(--bg-tertiary); border-radius: 3px; overflow: hidden; display: flex; }
        .progress-fill { height: 100%; transition: width 0.3s; }
        .progress-fill.transcribe { background: var(--accent-thai); }
        .progress-fill.translate { background: var(--accent-gold); }
        .overlay { position: fixed; inset: 0; background: rgba(10, 10, 15, 0.95); z-index: 1000; display: flex; align-items: center; justify-content: center; padding: 1rem; }
        .overlay.hidden { display: none; }
        .setup-modal { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: 12px; width: 100%; max-width: 480px; }
        .setup-header { padding: 1.25rem; border-bottom: 1px solid var(--border-primary); text-align: center; }
        .setup-title { font-size: 1.1rem; color: var(--accent-gold); }
        .setup-subtitle { font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem; }
        .setup-body { padding: 1.25rem; }
        .setup-step { display: none; }
        .setup-step.active { display: block; }
        .setup-label { font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.75rem; }
        .setup-option { padding: 0.75rem 1rem; background: var(--bg-tertiary); border: 2px solid var(--border-primary); border-radius: 8px; margin-bottom: 0.5rem; cursor: pointer; }
        .setup-option:hover { border-color: var(--border-secondary); }
        .setup-option.selected { border-color: var(--accent-gold); background: rgba(212, 168, 83, 0.08); }
        .setup-option-title { font-weight: 500; font-size: 0.9rem; }
        .setup-option-desc { font-size: 0.75rem; color: var(--text-muted); }
        .setup-slider-container { margin: 1.5rem 0; }
        .setup-slider-header { display: flex; justify-content: space-between; margin-bottom: 0.75rem; }
        .setup-slider-value { font-family: 'JetBrains Mono', monospace; font-size: 1.1rem; font-weight: 600; color: var(--accent-gold); }
        .setup-slider { width: 100%; height: 8px; border-radius: 4px; background: var(--bg-tertiary); -webkit-appearance: none; }
        .setup-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 22px; height: 22px; border-radius: 50%; background: var(--accent-gold); cursor: pointer; }
        .setup-estimate { margin-top: 0.75rem; padding: 0.75rem; background: var(--bg-primary); border-radius: 6px; font-size: 0.75rem; color: var(--text-muted); text-align: center; }
        .setup-workers-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; margin-top: 1rem; }
        .setup-worker-card { background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: 8px; padding: 0.75rem; }
        .setup-worker-header { display: flex; justify-content: space-between; margin-bottom: 0.5rem; }
        .setup-worker-id { font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; font-weight: 600; color: var(--text-secondary); }
        .setup-worker-status { font-size: 0.65rem; color: var(--text-muted); }
        .setup-worker-card.loading .setup-worker-status { color: var(--status-warning); }
        .setup-worker-card.ready .setup-worker-status { color: var(--status-success); }
        .setup-worker-card.error .setup-worker-status { color: var(--status-error); }
        .setup-worker-progress { height: 4px; background: var(--bg-primary); border-radius: 2px; overflow: hidden; margin-bottom: 0.3rem; }
        .setup-worker-progress-fill { height: 100%; background: var(--accent-gold); width: 0%; transition: width 0.2s; }
        .setup-worker-card.ready .setup-worker-progress-fill { background: var(--status-success); width: 100%; }
        .setup-worker-task { font-size: 0.65rem; color: var(--text-muted); font-family: 'JetBrains Mono', monospace; }
        .setup-complete { text-align: center; padding: 1rem 0; }
        .setup-complete-icon { font-size: 3rem; margin-bottom: 0.75rem; }
        .setup-complete-title { font-size: 1.1rem; color: var(--status-success); margin-bottom: 0.5rem; }
        .setup-complete-summary { font-size: 0.8rem; color: var(--text-muted); }
        .setup-footer { padding: 1rem 1.25rem; border-top: 1px solid var(--border-primary); display: flex; justify-content: space-between; }
        .ingest-modal { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: 12px; width: 100%; max-width: 400px; padding: 2rem; text-align: center; }
        .ingest-icon { font-size: 2.5rem; margin-bottom: 1rem; }
        .ingest-title { font-size: 1rem; margin-bottom: 0.5rem; }
        .ingest-status { font-size: 0.8rem; color: var(--text-muted); margin-bottom: 1rem; }
        .ingest-progress { height: 6px; background: var(--bg-tertiary); border-radius: 3px; overflow: hidden; margin-bottom: 0.5rem; }
        .ingest-progress-fill { height: 100%; background: var(--accent-gold); width: 0%; transition: width 0.3s; }
        .ingest-detail { font-size: 0.7rem; font-family: 'JetBrains Mono', monospace; color: var(--text-muted); }
        .toast-container { position: fixed; bottom: 1rem; right: 1rem; z-index: 2000; }
        .toast { padding: 0.75rem 1rem; background: var(--bg-elevated); border: 1px solid var(--border-primary); border-radius: 8px; margin-top: 0.5rem; font-size: 0.8rem; animation: toastIn 0.2s; }
        @keyframes toastIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        .toast.success { border-color: var(--status-success); }
        .toast.error { border-color: var(--status-error); }
        .toast.warning { border-color: var(--status-warning); }
        .hidden { display: none !important; }
        input[type="file"] { display: none; }
        @media (max-width: 768px) {
            .sidebar { position: fixed; left: 0; top: 0; bottom: 0; z-index: 100; transform: translateX(-100%); width: 280px; }
            .sidebar.open { transform: translateX(0); }
            .chunk-row { grid-template-columns: 1fr; }
            .chunk-cell:first-child { border-right: none; border-bottom: 1px solid var(--border-primary); }
            .transcript-header { grid-template-columns: 1fr; }
            .column-header:first-child { border-right: none; border-bottom: 1px solid var(--border-primary); }
        }
    </style>
</head>
<body>
    <div class="overlay" id="setupOverlay">
        <div class="setup-modal">
            <div class="setup-header"><div class="setup-title">Thai Transcriber Setup</div><div class="setup-subtitle">Configure transcription environment</div></div>
            <div class="setup-body">
                <div class="setup-step active" data-step="1">
                    <div class="setup-label">Select Whisper Model</div>
                    <div class="setup-option" data-value="tiny"><div class="setup-option-title">üöÄ Tiny (~40 MB/worker)</div><div class="setup-option-desc">Fastest, less accurate</div></div>
                    <div class="setup-option selected" data-value="base"><div class="setup-option-title">‚öñÔ∏è Base (~75 MB/worker)</div><div class="setup-option-desc">Recommended balance</div></div>
                    <div class="setup-option" data-value="small"><div class="setup-option-title">üéØ Small (~250 MB/worker)</div><div class="setup-option-desc">Most accurate, slower</div></div>
                </div>
                <div class="setup-step" data-step="2">
                    <div class="setup-label">Parallel Workers (1-8)</div>
                    <div class="setup-slider-container">
                        <div class="setup-slider-header"><span>Workers</span><span class="setup-slider-value" id="setupWorkerCount">4</span></div>
                        <input type="range" class="setup-slider" id="setupWorkerSlider" min="1" max="8" value="4">
                    </div>
                    <div class="setup-estimate" id="setupEstimate">~500 MB RAM ‚Ä¢ 4√ó parallel</div>
                </div>
                <div class="setup-step" data-step="3"><div class="setup-label">Initializing Workers...</div><div class="setup-workers-grid" id="setupWorkersGrid"></div></div>
                <div class="setup-step" data-step="4"><div class="setup-complete"><div class="setup-complete-icon">‚úÖ</div><div class="setup-complete-title">Setup Complete</div><div class="setup-complete-summary" id="setupSummary">Ready</div></div></div>
            </div>
            <div class="setup-footer"><button class="btn btn-secondary hidden" id="setupBackBtn">‚Üê Back</button><div style="flex:1"></div><button class="btn btn-primary" id="setupNextBtn">Next ‚Üí</button></div>
        </div>
    </div>
    <div class="overlay hidden" id="ingestOverlay"><div class="ingest-modal"><div class="ingest-icon">üìÇ</div><div class="ingest-title">Processing Audio</div><div class="ingest-status" id="ingestStatus">Reading...</div><div class="ingest-progress"><div class="ingest-progress-fill" id="ingestProgressFill"></div></div><div class="ingest-detail" id="ingestDetail">0%</div></div></div>
    <div class="app-container">
        <header class="app-header"><div class="app-logo">THAI TRANSCRIBER</div><div class="header-controls"><div class="worker-status"><div class="worker-dots" id="workerDots"></div><span id="workerStatusText">Setup required</span></div><button class="btn btn-ghost btn-icon" id="restartBtn" title="Restart">üîÑ</button><button class="btn btn-ghost btn-icon" id="settingsBtn" title="Settings">‚öôÔ∏è</button></div></header>
        <div class="app-main"><aside class="sidebar" id="sidebar"><div class="sidebar-header"><span>Sessions</span><span id="sessionCount">0</span></div><div class="sidebar-sessions" id="sessionsList"></div><div class="sidebar-footer"><button class="new-btn" id="newSessionBtn">+ New Recording</button></div></aside><main class="content-area" id="contentArea"></main></div>
        <div class="progress-bar-container" id="progressBar"><div class="progress-header"><span id="progressLabel">Processing...</span><div class="progress-stats"><span id="progressTranscribe">Transcribe: 0/0</span><span id="progressTranslate">Translate: 0/0</span></div></div><div class="progress-track"><div class="progress-fill transcribe" id="progressFillTranscribe"></div><div class="progress-fill translate" id="progressFillTranslate"></div></div></div>
    </div>
    <input type="file" id="fileInput" accept="audio/*,.m4a,.mp3,.wav,.ogg,.flac">
    <div class="toast-container" id="toastContainer"></div>

    <script id="workerCode" type="text/js-worker">
        let workerId = null, whisper = null, thEn = null, enTh = null;
        
        self.onmessage = async function(e) {
            const { type, data } = e.data;
            
            if (type === 'init') {
                workerId = data.workerId;
                try {
                    send('status', 'loading', 'Importing...');
                    const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2');
                    
                    send('status', 'loading', 'Whisper...');
                    whisper = await pipeline('automatic-speech-recognition', 'Xenova/whisper-' + data.model, {
                        quantized: true,
                        progress_callback: p => p.status === 'progress' && send('progress', 'whisper', p.progress)
                    });
                    send('progress', 'whisper', 100);
                    
                    send('status', 'loading', 'TH‚ÜíEN...');
                    thEn = await pipeline('translation', 'Xenova/opus-mt-th-en', {
                        quantized: true,
                        progress_callback: p => p.status === 'progress' && send('progress', 'th-en', p.progress)
                    });
                    send('progress', 'th-en', 100);
                    
                    send('status', 'loading', 'EN‚ÜíTH...');
                    try { enTh = await pipeline('translation', 'Xenova/opus-mt-en-th', { quantized: true, progress_callback: p => p.status === 'progress' && send('progress', 'en-th', p.progress) }); } catch(err) { enTh = null; }
                    send('progress', 'en-th', 100);
                    
                    self.postMessage({ type: 'ready', workerId });
                } catch (err) { self.postMessage({ type: 'error', workerId, error: err.message }); }
            }
            
            if (type === 'transcribe') {
                const { sessionId, chunkIndex, audioData } = data;
                try {
                    send('status', 'working', '#' + (chunkIndex + 1));
                    const audio = new Float32Array(audioData);
                    
                    // Silence check - RMS < -40dB
                    let sum = 0; for (let i = 0; i < audio.length; i++) sum += audio[i] * audio[i];
                    if (20 * Math.log10(Math.sqrt(sum / audio.length) + 1e-10) < -40) {
                        self.postMessage({ type: 'chunkComplete', workerId, sessionId, chunkIndex, result: { transcript: '', transcriptLang: 'unknown', filtered: true, filterReason: 'Silence' } });
                        return;
                    }
                    
                    const result = await whisper(audio, { language: 'th', task: 'transcribe' });
                    let text = result.text?.trim() || '';
                    let filtered = false, filterReason = null;
                    
                    // AGGRESSIVE REPETITION DETECTION
                    if (text.length > 10) {
                        const rep = detectRepetition(text);
                        if (rep.isRepetitive) {
                            filtered = true;
                            filterReason = rep.reason;
                            text = '';
                        }
                    }
                    
                    const thaiChars = (text.match(/[\u0E00-\u0E7F]/g) || []).length;
                    const total = text.replace(/\s/g, '').length;
                    const lang = total > 0 && thaiChars / total > 0.3 ? 'th' : 'en';
                    
                    self.postMessage({ type: 'chunkComplete', workerId, sessionId, chunkIndex, result: { transcript: text, transcriptLang: lang, filtered, filterReason } });
                } catch (err) { self.postMessage({ type: 'chunkError', workerId, sessionId, chunkIndex, error: err.message }); }
            }
            
            if (type === 'translate') {
                const { sessionId, chunkIndex, text, sourceLang } = data;
                try {
                    send('status', 'working', 'T#' + (chunkIndex + 1));
                    let translation = '', targetLang = '';
                    if (sourceLang === 'th' && thEn) { const r = await thEn(text, { max_length: 512 }); translation = r[0]?.translation_text || ''; targetLang = 'en'; }
                    else if (sourceLang === 'en' && enTh) { const r = await enTh(text, { max_length: 512 }); translation = r[0]?.translation_text || ''; targetLang = 'th'; }
                    self.postMessage({ type: 'translateComplete', workerId, sessionId, chunkIndex, result: { translation, translationLang: targetLang } });
                } catch (err) { self.postMessage({ type: 'translateError', workerId, sessionId, chunkIndex, error: err.message }); }
            }
            
            if (type === 'backTranslate') {
                const { sessionId, chunkIndex, text, sourceLang } = data;
                try {
                    send('status', 'working', 'BT#' + (chunkIndex + 1));
                    let back = '';
                    if (sourceLang === 'th' && enTh) { const r = await enTh(text, { max_length: 512 }); back = r[0]?.translation_text || ''; }
                    else if (sourceLang === 'en' && thEn) { const r = await thEn(text, { max_length: 512 }); back = r[0]?.translation_text || ''; }
                    self.postMessage({ type: 'backTranslateComplete', workerId, sessionId, chunkIndex, result: { backTranslation: back } });
                } catch (err) { self.postMessage({ type: 'backTranslateError', workerId, sessionId, chunkIndex, error: err.message }); }
            }
        };
        
        // COMPREHENSIVE REPETITION DETECTION
        function detectRepetition(text) {
            // Clean text - remove parentheses, brackets, etc
            const clean = text.replace(/[\(\)\[\]\{\}]/g, '').trim();
            if (clean.length < 10) return { isRepetitive: false };
            
            // 1. Character-level consecutive repetition (Thai characters)
            // Catches: ‡∏î‡∏¥‡πâ‡∏á‡∏ß‡πà‡∏≤‡∏î‡∏¥‡πâ‡∏á‡∏ß‡πà‡∏≤‡∏î‡∏¥‡πâ‡∏á‡∏ß‡πà‡∏≤
            if (/([\u0E00-\u0E7F]{2,8})\1{3,}/.test(clean)) {
                return { isRepetitive: true, reason: 'Character loop' };
            }
            
            // 2. Word/phrase repetition with spaces
            // Split into segments and check for repeating patterns
            const segments = clean.split(/\s+/).filter(s => s.length > 0);
            if (segments.length >= 4) {
                // Check if same word repeats too much
                const wordCounts = {};
                for (const w of segments) {
                    wordCounts[w] = (wordCounts[w] || 0) + 1;
                }
                const maxCount = Math.max(...Object.values(wordCounts));
                // If any word is >40% of all words
                if (maxCount > segments.length * 0.4 && maxCount >= 3) {
                    return { isRepetitive: true, reason: 'Word repetition' };
                }
                
                // Check for repeating 2-word phrases
                if (segments.length >= 6) {
                    const pairs = [];
                    for (let i = 0; i < segments.length - 1; i++) {
                        pairs.push(segments[i] + ' ' + segments[i+1]);
                    }
                    const pairCounts = {};
                    for (const p of pairs) pairCounts[p] = (pairCounts[p] || 0) + 1;
                    const maxPairCount = Math.max(...Object.values(pairCounts));
                    if (maxPairCount >= 3 && maxPairCount > pairs.length * 0.3) {
                        return { isRepetitive: true, reason: 'Phrase repetition' };
                    }
                }
                
                // Check for repeating 3-word phrases
                if (segments.length >= 9) {
                    const triples = [];
                    for (let i = 0; i < segments.length - 2; i++) {
                        triples.push(segments[i] + ' ' + segments[i+1] + ' ' + segments[i+2]);
                    }
                    const tripleCounts = {};
                    for (const t of triples) tripleCounts[t] = (tripleCounts[t] || 0) + 1;
                    const maxTripleCount = Math.max(...Object.values(tripleCounts));
                    if (maxTripleCount >= 3) {
                        return { isRepetitive: true, reason: 'Phrase loop' };
                    }
                }
            }
            
            // 3. Check for parenthesized repetition like (text)(text)(text)
            const parenMatch = text.match(/\([^)]+\)/g);
            if (parenMatch && parenMatch.length >= 3) {
                const unique = new Set(parenMatch);
                if (unique.size === 1 || (parenMatch.length > 5 && unique.size <= 2)) {
                    return { isRepetitive: true, reason: 'Parenthesized repetition' };
                }
            }
            
            // 4. Ratio check - if unique characters are too few relative to text length
            const uniqueChars = new Set(clean.replace(/\s/g, '')).size;
            const totalChars = clean.replace(/\s/g, '').length;
            if (totalChars > 50 && uniqueChars < 15) {
                return { isRepetitive: true, reason: 'Low variety' };
            }
            
            // 5. Check for very long text with low unique content (Whisper hallucination pattern)
            if (totalChars > 100) {
                // Count unique 3-grams
                const trigrams = new Set();
                const noSpace = clean.replace(/\s/g, '');
                for (let i = 0; i < noSpace.length - 2; i++) {
                    trigrams.add(noSpace.substring(i, i + 3));
                }
                // If trigram diversity is very low, it's repetitive
                if (trigrams.size < totalChars * 0.15) {
                    return { isRepetitive: true, reason: 'Repetitive pattern' };
                }
            }
            
            return { isRepetitive: false };
        }
        
        function send(type, a, b) {
            if (type === 'status') self.postMessage({ type: 'status', workerId, status: a, task: b });
            else if (type === 'progress') self.postMessage({ type: 'progress', workerId, model: a, progress: b });
        }
    </script>
    
    <script type="module">
        const DB = 'ThaiTranscriberV7', CHUNK_SEC = 30, SR = 16000, MAX_SESSIONS = 10;
        
        class Store {
            constructor() { this.db = null; }
            async init() {
                if (this.db) return;
                return new Promise((res, rej) => {
                    const r = indexedDB.open(DB, 1);
                    r.onerror = () => rej(r.error);
                    r.onsuccess = () => { this.db = r.result; res(); };
                    r.onupgradeneeded = e => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('sessions')) { const s = db.createObjectStore('sessions', { keyPath: 'id' }); s.createIndex('createdAt', 'createdAt'); }
                        if (!db.objectStoreNames.contains('chunks')) { const c = db.createObjectStore('chunks', { keyPath: 'key' }); c.createIndex('sessionId', 'sessionId'); }
                        if (!db.objectStoreNames.contains('config')) db.createObjectStore('config', { keyPath: 'key' });
                    };
                });
            }
            async get(s, k) { await this.init(); return new Promise((res, rej) => { const r = this.db.transaction(s).objectStore(s).get(k); r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error); }); }
            async put(s, d) { await this.init(); return new Promise((res, rej) => { const r = this.db.transaction(s, 'readwrite').objectStore(s).put(d); r.onsuccess = () => res(); r.onerror = () => rej(r.error); }); }
            async del(s, k) { await this.init(); return new Promise((res, rej) => { const r = this.db.transaction(s, 'readwrite').objectStore(s).delete(k); r.onsuccess = () => res(); r.onerror = () => rej(r.error); }); }
            async getAll(s) { await this.init(); return new Promise((res, rej) => { const r = this.db.transaction(s).objectStore(s).getAll(); r.onsuccess = () => res(r.result || []); r.onerror = () => rej(r.error); }); }
            async getByIdx(s, i, v) { await this.init(); return new Promise((res, rej) => { const r = this.db.transaction(s).objectStore(s).index(i).getAll(v); r.onsuccess = () => res(r.result || []); r.onerror = () => rej(r.error); }); }
            async getSessions() { return (await this.getAll('sessions')).sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)); }
            async getChunks(sid) { return (await this.getByIdx('chunks', 'sessionId', sid)).sort((a, b) => a.index - b.index); }
            async getChunk(sid, idx) { return this.get('chunks', sid + '_' + idx); }
            async saveChunk(c) { c.key = c.sessionId + '_' + c.index; await this.put('chunks', c); }
            async delSession(id) { const chunks = await this.getChunks(id); for (const c of chunks) await this.del('chunks', c.key); await this.del('sessions', id); }
            async cleanup() { const s = await this.getSessions(); if (s.length >= MAX_SESSIONS) for (const x of s.slice(MAX_SESSIONS - 1)) await this.delSession(x.id); }
            async getConfig() { return (await this.get('config', 'main')) || { key: 'main', whisperModel: 'base', workerCount: 4, setupComplete: false }; }
            async saveConfig(c) { c.key = 'main'; await this.put('config', c); }
        }
        
        const store = new Store();
        const S = { config: { whisperModel: 'base', workerCount: 4, setupComplete: false }, step: 1, workers: [], wStates: new Map(), ready: new Set(), session: null, chunkMeta: new Map(), processing: false, pendingWork: [], activeJobs: new Map(), stats: { total: 0, transcribed: 0, translated: 0, filtered: 0 } };

        // Workers
        function createWorker(id) {
            const blob = new Blob([document.getElementById('workerCode').textContent], { type: 'application/javascript' });
            const w = new Worker(URL.createObjectURL(blob), { type: 'module' });
            w.onmessage = e => handleMsg(id, e.data);
            w.onerror = () => updateW(id, 'error', 'Error');
            return w;
        }
        
        function handleMsg(id, m) {
            if (m.type === 'status') { updateW(id, m.status, m.task); updateSetupW(id); }
            else if (m.type === 'progress') { const ws = S.wStates.get(id) || { progress: {} }; ws.progress[m.model] = m.progress; S.wStates.set(id, ws); updateSetupW(id); }
            else if (m.type === 'ready') { S.ready.add(id); updateW(id, 'ready', 'Ready'); updateSetupW(id); checkReady(); if (S.processing) scheduleNext(); }
            else if (m.type === 'error') { updateW(id, 'error', m.error?.slice(0, 20)); updateSetupW(id); }
            else if (m.type === 'chunkComplete') { S.activeJobs.delete(id); handleChunk(m); updateW(id, 'ready', 'Ready'); scheduleNext(); }
            else if (m.type === 'chunkError') { S.activeJobs.delete(id); handleChunkErr(m); updateW(id, 'ready', 'Ready'); scheduleNext(); }
            else if (m.type === 'translateComplete') { S.activeJobs.delete(id); handleTrans(m); updateW(id, 'ready', 'Ready'); scheduleNext(); }
            else if (m.type === 'translateError') { S.activeJobs.delete(id); updateW(id, 'ready', 'Ready'); scheduleNext(); }
            else if (m.type === 'backTranslateComplete') { S.activeJobs.delete(id); handleBack(m); updateW(id, 'ready', 'Ready'); }
            else if (m.type === 'backTranslateError') { S.activeJobs.delete(id); toast('error', 'Back-translate failed'); updateW(id, 'ready', 'Ready'); }
        }
        
        function updateW(id, status, task) { const ws = S.wStates.get(id) || { progress: {} }; ws.status = status; ws.task = task; S.wStates.set(id, ws); updateDots(); }
        
        async function initWorkers() {
            S.workers.forEach(w => w.terminate());
            S.workers = []; S.wStates.clear(); S.ready.clear();
            const n = S.config.workerCount;
            const dots = document.getElementById('workerDots');
            dots.innerHTML = '';
            for (let i = 0; i < n; i++) { const d = document.createElement('div'); d.className = 'worker-dot'; d.id = 'dot-' + i; dots.appendChild(d); }
            for (let i = 0; i < n; i++) {
                S.wStates.set(i, { status: 'loading', task: 'Starting...', progress: {} });
                const w = createWorker(i);
                S.workers.push(w);
                setTimeout(() => w.postMessage({ type: 'init', data: { workerId: i, model: S.config.whisperModel } }), i * 500);
            }
            updateDots();
        }
        
        function getWorker() { for (let i = 0; i < S.workers.length; i++) if (S.wStates.get(i)?.status === 'ready' && !S.activeJobs.has(i)) return i; return null; }
        function updateDots() { for (const [id, ws] of S.wStates) { const d = document.getElementById('dot-' + id); if (d) d.className = 'worker-dot ' + ws.status; } document.getElementById('workerStatusText').textContent = S.ready.size === S.workers.length && S.workers.length > 0 ? S.workers.length + ' workers' : S.ready.size + '/' + S.workers.length; }
        function checkReady() { if (S.ready.size === S.config.workerCount && !S.config.setupComplete) { S.config.setupComplete = true; store.saveConfig(S.config); document.getElementById('setupSummary').textContent = S.config.workerCount + ' workers ‚Ä¢ Whisper ' + S.config.whisperModel; S.step = 4; updateSetup(); } }

        // Audio Ingest
        async function ingest(file) {
            showIngest();
            try {
                updateIng('Reading...', 0);
                const buf = await new Promise((res, rej) => { const r = new FileReader(); r.onprogress = e => e.lengthComputable && updateIng('Reading...', (e.loaded / e.total) * 30); r.onload = () => res(r.result); r.onerror = () => rej(r.error); r.readAsArrayBuffer(file); });
                updateIng('Decoding...', 35);
                const ctx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SR });
                const ab = await ctx.decodeAudioData(buf.slice(0));
                updateIng('Processing...', 60);
                const len = ab.length;
                const mono = new Float32Array(len);
                if (ab.numberOfChannels === 1) ab.copyFromChannel(mono, 0);
                else { const l = new Float32Array(len), r = new Float32Array(len); ab.copyFromChannel(l, 0); ab.copyFromChannel(r, 1); for (let i = 0; i < len; i++) mono[i] = (l[i] + r[i]) / 2; }
                let audio = mono;
                if (ab.sampleRate !== SR) { const ratio = ab.sampleRate / SR, newLen = Math.round(mono.length / ratio); audio = new Float32Array(newLen); for (let i = 0; i < newLen; i++) { const idx = i * ratio, lo = Math.floor(idx); audio[i] = mono[lo] * (1 - (idx - lo)) + mono[Math.min(lo + 1, mono.length - 1)] * (idx - lo); } }
                
                updateIng('Saving...', 70);
                await store.cleanup();
                const now = new Date();
                const totalChunks = Math.ceil(audio.length / (CHUNK_SEC * SR));
                const sess = { id: 'sess_' + now.getTime(), name: 'Session', fileName: file.name, fileSize: file.size, duration: audio.length / SR, createdAt: now.toISOString(), totalChunks, transcribedChunks: 0, translatedChunks: 0, status: 'created' };
                await store.put('sessions', sess);
                
                const chunkLen = CHUNK_SEC * SR;
                for (let i = 0; i < totalChunks; i++) {
                    const st = i * chunkLen, en = Math.min(st + chunkLen, audio.length);
                    await store.saveChunk({ sessionId: sess.id, index: i, startTime: st / SR, endTime: en / SR, audioData: Array.from(audio.slice(st, en)), transcript: null, transcriptLang: null, translation: null, translationLang: null, backTranslation: null, status: 'pending', filtered: false, filterReason: null });
                    if (i % 10 === 0) updateIng('Saving chunks...', 70 + (i / totalChunks) * 25);
                }
                audio = null;
                
                updateIng('Complete!', 100);
                hideIngest();
                await refreshSessions();
                await loadSession(sess.id);
            } catch (err) { hideIngest(); toast('error', 'Failed: ' + err.message); console.error(err); }
        }

        // Processing
        async function startProc() {
            if (!S.session || S.ready.size === 0) { toast('error', 'Workers not ready'); return; }
            S.processing = true;
            showProgress();
            
            const chunks = await store.getChunks(S.session.id);
            S.chunkMeta.clear();
            S.pendingWork = [];
            
            for (const c of chunks) {
                S.chunkMeta.set(c.index, { startTime: c.startTime, endTime: c.endTime, transcript: c.transcript, transcriptLang: c.transcriptLang, translation: c.translation, translationLang: c.translationLang, backTranslation: c.backTranslation, status: c.status, filtered: c.filtered, filterReason: c.filterReason });
                if (c.status === 'pending' || c.status === 'error') S.pendingWork.push({ type: 'transcribe', chunkIndex: c.index });
                else if (c.status === 'transcribed' && !c.filtered && !c.translation && c.transcript) S.pendingWork.push({ type: 'translate', chunkIndex: c.index });
            }
            
            updateStats();
            renderChunks();
            scheduleNext();
        }
        
        function stopProc() { S.processing = false; S.pendingWork = []; toast('info', 'Stopped'); }
        
        async function scheduleNext() {
            if (!S.processing) return;
            const workerId = getWorker();
            if (workerId === null || S.pendingWork.length === 0) { checkComplete(); return; }
            
            const job = S.pendingWork.shift();
            S.activeJobs.set(workerId, job.chunkIndex);
            
            if (job.type === 'transcribe') {
                const chunk = await store.getChunk(S.session.id, job.chunkIndex);
                if (chunk) {
                    updateW(workerId, 'working', '#' + (job.chunkIndex + 1));
                    S.workers[workerId].postMessage({ type: 'transcribe', data: { sessionId: S.session.id, chunkIndex: job.chunkIndex, audioData: chunk.audioData } });
                }
            } else if (job.type === 'translate') {
                const meta = S.chunkMeta.get(job.chunkIndex);
                if (meta?.transcript) {
                    updateW(workerId, 'working', 'T#' + (job.chunkIndex + 1));
                    S.workers[workerId].postMessage({ type: 'translate', data: { sessionId: S.session.id, chunkIndex: job.chunkIndex, text: meta.transcript, sourceLang: meta.transcriptLang } });
                }
            }
            
            if (S.pendingWork.length > 0 && S.processing) setTimeout(() => scheduleNext(), 50);
        }
        
        function checkComplete() { if (S.pendingWork.length === 0 && S.activeJobs.size === 0) { S.processing = false; toast('success', 'Complete!'); } }
        
        async function handleChunk(m) {
            if (m.sessionId !== S.session?.id) return;
            const chunk = await store.getChunk(m.sessionId, m.chunkIndex);
            if (chunk) { chunk.transcript = m.result.transcript; chunk.transcriptLang = m.result.transcriptLang; chunk.filtered = m.result.filtered; chunk.filterReason = m.result.filterReason; chunk.status = m.result.filtered ? 'filtered' : 'transcribed'; await store.saveChunk(chunk); }
            const meta = S.chunkMeta.get(m.chunkIndex);
            if (meta) { meta.transcript = m.result.transcript; meta.transcriptLang = m.result.transcriptLang; meta.filtered = m.result.filtered; meta.filterReason = m.result.filterReason; meta.status = m.result.filtered ? 'filtered' : 'transcribed'; }
            S.stats.transcribed++;
            if (m.result.filtered) S.stats.filtered++;
            if (!m.result.filtered && m.result.transcript) S.pendingWork.push({ type: 'translate', chunkIndex: m.chunkIndex });
            updateChunkUI(m.chunkIndex);
            updateStats();
        }
        
        async function handleChunkErr(m) {
            if (m.sessionId !== S.session?.id) return;
            const chunk = await store.getChunk(m.sessionId, m.chunkIndex);
            if (chunk) { chunk.status = 'error'; await store.saveChunk(chunk); }
            const meta = S.chunkMeta.get(m.chunkIndex);
            if (meta) meta.status = 'error';
            updateChunkUI(m.chunkIndex);
            updateStats();
        }
        
        async function handleTrans(m) {
            if (m.sessionId !== S.session?.id) return;
            const chunk = await store.getChunk(m.sessionId, m.chunkIndex);
            if (chunk) { chunk.translation = m.result.translation; chunk.translationLang = m.result.translationLang; chunk.status = 'complete'; await store.saveChunk(chunk); }
            const meta = S.chunkMeta.get(m.chunkIndex);
            if (meta) { meta.translation = m.result.translation; meta.translationLang = m.result.translationLang; meta.status = 'complete'; }
            S.stats.translated++;
            updateChunkUI(m.chunkIndex);
            updateStats();
        }
        
        async function handleBack(m) {
            if (m.sessionId !== S.session?.id) return;
            const chunk = await store.getChunk(m.sessionId, m.chunkIndex);
            if (chunk) { chunk.backTranslation = m.result.backTranslation; await store.saveChunk(chunk); }
            const meta = S.chunkMeta.get(m.chunkIndex);
            if (meta) meta.backTranslation = m.result.backTranslation;
            updateChunkUI(m.chunkIndex);
            toast('success', 'Back-translate done');
        }
        
        async function redo(i) {
            const chunk = await store.getChunk(S.session.id, i);
            if (!chunk) return;
            chunk.transcript = null; chunk.transcriptLang = null; chunk.translation = null; chunk.translationLang = null; chunk.backTranslation = null; chunk.filtered = false; chunk.status = 'pending';
            await store.saveChunk(chunk);
            const meta = S.chunkMeta.get(i);
            if (meta) { meta.transcript = null; meta.transcriptLang = null; meta.translation = null; meta.translationLang = null; meta.backTranslation = null; meta.filtered = false; meta.status = 'pending'; }
            S.pendingWork.push({ type: 'transcribe', chunkIndex: i });
            S.processing = true;
            updateChunkUI(i);
            scheduleNext();
        }
        
        async function redoTrans(i) {
            const chunk = await store.getChunk(S.session.id, i);
            if (!chunk?.transcript) return;
            chunk.translation = null; chunk.translationLang = null; chunk.backTranslation = null; chunk.status = 'transcribed';
            await store.saveChunk(chunk);
            const meta = S.chunkMeta.get(i);
            if (meta) { meta.translation = null; meta.translationLang = null; meta.backTranslation = null; meta.status = 'transcribed'; }
            S.pendingWork.push({ type: 'translate', chunkIndex: i });
            S.processing = true;
            updateChunkUI(i);
            scheduleNext();
        }
        
        async function backTrans(i) {
            const meta = S.chunkMeta.get(i);
            if (!meta?.translation) return;
            const w = getWorker();
            if (w === null) { toast('warning', 'No workers'); return; }
            S.activeJobs.set(w, i);
            updateW(w, 'working', 'BT#' + (i + 1));
            S.workers[w].postMessage({ type: 'backTranslate', data: { sessionId: S.session.id, chunkIndex: i, text: meta.translation, sourceLang: meta.transcriptLang } });
        }
        
        async function redoBack(i) {
            const chunk = await store.getChunk(S.session.id, i);
            if (chunk) { chunk.backTranslation = null; await store.saveChunk(chunk); }
            const meta = S.chunkMeta.get(i);
            if (meta) meta.backTranslation = null;
            updateChunkUI(i);
            backTrans(i);
        }

        // Sessions
        async function loadSession(id) {
            const sess = await store.get('sessions', id);
            if (!sess) return;
            S.session = sess;
            S.chunkMeta.clear();
            const chunks = await store.getChunks(id);
            for (const c of chunks) S.chunkMeta.set(c.index, { startTime: c.startTime, endTime: c.endTime, transcript: c.transcript, transcriptLang: c.transcriptLang, translation: c.translation, translationLang: c.translationLang, backTranslation: c.backTranslation, status: c.status, filtered: c.filtered, filterReason: c.filterReason });
            S.stats = { total: sess.totalChunks, transcribed: chunks.filter(c => c.transcript !== null || c.filtered).length, translated: chunks.filter(c => c.translation !== null).length, filtered: chunks.filter(c => c.filtered).length };
            renderSession();
            updateSessionList();
        }
        
        async function delSession(id) { if (S.session?.id === id) { S.session = null; S.chunkMeta.clear(); renderEmpty(); } await store.delSession(id); await refreshSessions(); toast('success', 'Deleted'); }
        async function renameSession(id, name) { const s = await store.get('sessions', id); if (s) { s.name = name || 'Session'; await store.put('sessions', s); if (S.session?.id === id) S.session.name = s.name; await refreshSessions(); } }
        async function refreshSessions() { const sessions = await store.getSessions(); renderSessions(sessions); document.getElementById('sessionCount').textContent = sessions.length; }
        
        // UI
        function renderSessions(sessions) {
            const el = document.getElementById('sessionsList'); el.innerHTML = '';
            for (const s of sessions) {
                const card = document.createElement('div');
                card.className = 'session-card' + (S.session?.id === s.id ? ' active' : '');
                card.dataset.id = s.id;
                const d = new Date(s.createdAt), dots = 6, filled = Math.round((s.translatedChunks / s.totalChunks) * dots) || 0;
                let dotsHtml = ''; for (let i = 0; i < dots; i++) dotsHtml += '<div class="session-dot' + (i < filled ? ' filled' : '') + '"></div>';
                card.innerHTML = '<div class="session-card-date">' + d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ' ' + d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }) + '</div><div class="session-card-name">' + esc(s.name) + '</div><div class="session-card-progress">' + dotsHtml + '</div><button class="session-card-delete">√ó</button>';
                card.onclick = e => { if (!e.target.classList.contains('session-card-delete')) loadSession(s.id); };
                card.querySelector('.session-card-delete').onclick = e => { e.stopPropagation(); if (confirm('Delete?')) delSession(s.id); };
                el.appendChild(card);
            }
        }
        
        function updateSessionList() { if (!S.session) return; const card = document.querySelector('.session-card[data-id="' + S.session.id + '"]'); if (!card) return; const dots = card.querySelectorAll('.session-dot'), filled = Math.round((S.stats.translated / S.stats.total) * dots.length) || 0; dots.forEach((d, i) => d.className = 'session-dot' + (i < filled ? ' filled' : '')); }
        
        function renderEmpty() {
            document.getElementById('contentArea').innerHTML = '<div class="empty-state"><div class="empty-icon">üéôÔ∏è</div><div class="empty-title">No session selected</div><div class="drop-zone" id="dropZone"><div>üìÇ Drop audio file here</div><div style="font-size:0.7rem;margin-top:0.25rem;color:var(--text-muted)">M4A, MP3, WAV, OGG, FLAC</div></div></div>';
            setupDrop(document.getElementById('dropZone'));
        }
        
        function renderSession() {
            if (!S.session) { renderEmpty(); return; }
            const s = S.session;
            document.getElementById('contentArea').innerHTML = '<div class="content-header"><div class="content-header-left"><button class="sidebar-toggle" id="sidebarToggle">‚ò∞</button><div class="session-info"><input type="text" class="session-name-input" id="nameInput" value="' + esc(s.name) + '"><div class="session-meta">' + esc(s.fileName) + ' ‚Ä¢ ' + fmtDur(s.duration) + ' ‚Ä¢ ' + s.totalChunks + ' chunks</div></div></div><div class="content-actions"><button class="btn btn-secondary btn-sm" id="exportBtn">üì§ Export</button><button class="btn ' + (S.processing ? 'btn-danger' : 'btn-primary') + ' btn-sm" id="procBtn">' + (S.processing ? '‚èπ Stop' : '‚ñ∂Ô∏è Process') + '</button></div></div><div class="transcript-container"><div class="transcript-header"><div class="column-header"><span class="column-title">Original</span><button class="btn btn-ghost btn-xs" id="copyOrig">üìã Copy All</button></div><div class="column-header"><span class="column-title">Translation</span><button class="btn btn-ghost btn-xs" id="copyTrans">üìã Copy All</button></div></div><div class="transcript-scroll" id="scroll"></div></div>';
            document.getElementById('sidebarToggle').onclick = () => document.getElementById('sidebar').classList.toggle('collapsed');
            document.getElementById('nameInput').onblur = e => renameSession(s.id, e.target.value.trim());
            document.getElementById('nameInput').onkeydown = e => { if (e.key === 'Enter') e.target.blur(); };
            document.getElementById('procBtn').onclick = () => { if (S.processing) stopProc(); else startProc(); const btn = document.getElementById('procBtn'); btn.textContent = S.processing ? '‚èπ Stop' : '‚ñ∂Ô∏è Process'; btn.className = 'btn ' + (S.processing ? 'btn-danger' : 'btn-primary') + ' btn-sm'; };
            document.getElementById('exportBtn').onclick = showExport;
            document.getElementById('copyOrig').onclick = copyOrig;
            document.getElementById('copyTrans').onclick = copyTrans;
            renderChunks();
        }
        
        function renderChunks() { const el = document.getElementById('scroll'); if (!el) return; el.innerHTML = ''; const sorted = Array.from(S.chunkMeta.entries()).sort((a, b) => a[0] - b[0]); for (const [idx, meta] of sorted) el.appendChild(createRow(idx, meta)); }
        
        function createRow(idx, meta) {
            const row = document.createElement('div');
            row.className = 'chunk-row' + (meta.filtered ? ' filtered' : '');
            row.id = 'chunk-' + idx;
            const id = String(idx + 1).padStart(3, '0'), time = fmtTime(meta.startTime) + ' ‚Üí ' + fmtTime(meta.endTime);
            let orig = '', trans = '';
            if (meta.filtered) { orig = '<div class="chunk-text filtered">‚ö†Ô∏è ' + (meta.filterReason || 'Filtered') + '</div>'; trans = '<div class="chunk-text empty">‚Äî</div>'; }
            else if (meta.transcript) { orig = '<div class="chunk-text">' + esc(meta.transcript) + '</div><div class="chunk-actions"><button class="chunk-action" data-a="redo" data-i="' + idx + '">üîÑ Redo</button></div>'; }
            else if (meta.status === 'error') { orig = '<div class="chunk-text filtered">‚ùå Error</div>'; }
            else { orig = '<div class="chunk-text empty">Pending...</div>'; }
            if (!meta.filtered && meta.translation) {
                const flag = meta.translationLang === 'th' ? 'üáπüá≠' : 'üá∫üá∏';
                trans = '<div class="chunk-text">' + flag + ' ' + esc(meta.translation) + '</div><div class="chunk-actions"><button class="chunk-action" data-a="redoT" data-i="' + idx + '">üîÑ Redo</button><button class="chunk-action" data-a="back" data-i="' + idx + '">‚Ü©Ô∏è Back</button></div>';
                if (meta.backTranslation) { const bf = meta.transcriptLang === 'th' ? 'üáπüá≠' : 'üá∫üá∏'; trans += '<div class="back-translation"><div class="back-translation-label"><span>‚Ü©Ô∏è Back-translation</span><button class="chunk-action" data-a="redoB" data-i="' + idx + '">üîÑ</button></div><div class="back-translation-text">' + bf + ' ' + esc(meta.backTranslation) + '</div></div>'; }
            } else if (!meta.filtered && meta.transcript) { trans = '<div class="chunk-text empty">Translating...</div>'; }
            else if (!meta.filtered) { trans = '<div class="chunk-text empty">‚Äî</div>'; }
            row.innerHTML = '<div class="chunk-cell"><div class="chunk-header"><span class="chunk-id">' + id + '</span><span class="chunk-time">' + time + '</span>' + (meta.transcriptLang ? '<span class="chunk-lang ' + meta.transcriptLang + '">' + (meta.transcriptLang === 'th' ? 'üáπüá≠ TH' : 'üá∫üá∏ EN') + '</span>' : '') + '<button class="chunk-play" data-a="play" data-i="' + idx + '">‚ñ∂</button></div>' + orig + '</div><div class="chunk-cell"><div class="chunk-header">' + (meta.translationLang ? '<span class="chunk-lang ' + meta.translationLang + '">' + (meta.translationLang === 'th' ? 'üáπüá≠ TH' : 'üá∫üá∏ EN') + '</span>' : '') + '</div>' + trans + '</div>';
            row.querySelectorAll('[data-a]').forEach(btn => btn.onclick = () => { const a = btn.dataset.a, i = parseInt(btn.dataset.i); if (a === 'play') playChunk(i); else if (a === 'redo') redo(i); else if (a === 'redoT') redoTrans(i); else if (a === 'back') backTrans(i); else if (a === 'redoB') redoBack(i); });
            return row;
        }
        
        function updateChunkUI(idx) { const meta = S.chunkMeta.get(idx); if (!meta) return; const old = document.getElementById('chunk-' + idx); if (old) old.replaceWith(createRow(idx, meta)); }
        
        // Audio
        let aCtx = null, aSrc = null;
        async function playChunk(i) {
            const chunk = await store.getChunk(S.session.id, i);
            if (!chunk?.audioData) return;
            if (aSrc) { aSrc.stop(); aSrc = null; }
            if (!aCtx) aCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (aCtx.state === 'suspended') await aCtx.resume();
            const data = new Float32Array(chunk.audioData), buf = aCtx.createBuffer(1, data.length, SR);
            buf.getChannelData(0).set(data);
            const src = aCtx.createBufferSource(); src.buffer = buf; src.connect(aCtx.destination); src.start(); aSrc = src;
            const btn = document.querySelector('[data-a="play"][data-i="' + i + '"]');
            if (btn) { btn.textContent = '‚èπ'; src.onended = () => { btn.textContent = '‚ñ∂'; aSrc = null; }; }
        }
        
        // Export
        async function showExport() { const c = prompt('Export:\\n1 = Markdown\\n2 = JSON\\n3 = Text'); if (c === '1') await expMd(); else if (c === '2') await expJson(); else if (c === '3') await expTxt(); }
        async function expMd() { const chunks = await store.getChunks(S.session.id); const valid = chunks.filter(c => c.transcript && !c.filtered).sort((a, b) => a.index - b.index); if (!valid.length) { toast('warning', 'No content'); return; } let md = '# ' + (S.session?.name || 'Transcript') + '\n\n'; for (const c of valid) { md += '## ' + String(c.index + 1).padStart(3, '0') + ' [' + fmtTime(c.startTime) + ']\n\n' + c.transcript + '\n\n'; if (c.translation) md += '> ' + c.translation + '\n\n'; if (c.backTranslation) md += '> ‚Ü©Ô∏è ' + c.backTranslation + '\n\n'; } dl(S.session?.name + '.md', md); }
        async function expJson() { const chunks = await store.getChunks(S.session.id); const valid = chunks.filter(c => c.transcript && !c.filtered).sort((a, b) => a.index - b.index); if (!valid.length) { toast('warning', 'No content'); return; } dl(S.session?.name + '.json', JSON.stringify({ session: { name: S.session?.name }, chunks: valid.map(c => ({ id: String(c.index + 1).padStart(3, '0'), start: c.startTime, end: c.endTime, lang: c.transcriptLang, original: c.transcript, translation: c.translation, backTranslation: c.backTranslation })) }, null, 2)); }
        async function expTxt() { const chunks = await store.getChunks(S.session.id); const valid = chunks.filter(c => c.transcript && !c.filtered).sort((a, b) => a.index - b.index); if (!valid.length) { toast('warning', 'No content'); return; } let txt = ''; for (const c of valid) { txt += '[' + String(c.index + 1).padStart(3, '0') + '] ' + fmtTime(c.startTime) + '\n' + c.transcript + '\n'; if (c.translation) txt += '‚Üí ' + c.translation + '\n'; if (c.backTranslation) txt += '  ‚Ü© ' + c.backTranslation + '\n'; txt += '\n'; } dl(S.session?.name + '.txt', txt); }
        function dl(name, content) { const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([content])); a.download = name; a.click(); }
        async function copyOrig() { const chunks = await store.getChunks(S.session.id); const t = chunks.filter(c => c.transcript && !c.filtered).sort((a, b) => a.index - b.index).map(c => c.transcript).join('\n\n'); navigator.clipboard.writeText(t).then(() => toast('success', 'Copied')); }
        async function copyTrans() { const chunks = await store.getChunks(S.session.id); const t = chunks.filter(c => c.translation && !c.filtered).sort((a, b) => a.index - b.index).map(c => c.translation).join('\n\n'); navigator.clipboard.writeText(t).then(() => toast('success', 'Copied')); }

        // Setup UI
        function updateSetup() {
            document.querySelectorAll('.setup-step').forEach(s => s.classList.toggle('active', parseInt(s.dataset.step) === S.step));
            document.getElementById('setupBackBtn').classList.toggle('hidden', S.step <= 1 || S.step >= 3);
            const btn = document.getElementById('setupNextBtn');
            if (S.step === 3) { btn.textContent = 'Initializing...'; btn.disabled = true; }
            else if (S.step === 4) { btn.textContent = 'Start ‚Üí'; btn.disabled = false; }
            else { btn.textContent = 'Next ‚Üí'; btn.disabled = false; }
        }
        
        function updateEst() {
            const n = parseInt(document.getElementById('setupWorkerSlider').value);
            document.getElementById('setupWorkerCount').textContent = n;
            const sizes = { tiny: 40, base: 75, small: 250 };
            document.getElementById('setupEstimate').textContent = '~' + ((sizes[S.config.whisperModel] || 75) + 100) * n + ' MB RAM ‚Ä¢ ' + n + '√ó parallel';
        }
        
        function createSetupW() {
            const el = document.getElementById('setupWorkersGrid'); el.innerHTML = '';
            for (let i = 0; i < S.config.workerCount; i++) {
                const card = document.createElement('div'); card.className = 'setup-worker-card loading'; card.id = 'sw-' + i;
                card.innerHTML = '<div class="setup-worker-header"><span class="setup-worker-id">W' + (i + 1) + '</span><span class="setup-worker-status">Loading...</span></div><div class="setup-worker-progress"><div class="setup-worker-progress-fill" id="sp-' + i + '"></div></div><div class="setup-worker-task" id="st-' + i + '">Starting...</div>';
                el.appendChild(card);
            }
        }
        
        function updateSetupW(id) {
            const ws = S.wStates.get(id); if (!ws) return;
            const card = document.getElementById('sw-' + id), prog = document.getElementById('sp-' + id), task = document.getElementById('st-' + id);
            if (!card) return;
            card.className = 'setup-worker-card ' + ws.status;
            card.querySelector('.setup-worker-status').textContent = ws.status === 'ready' ? 'Ready' : ws.status === 'error' ? 'Error' : 'Loading...';
            if (prog && ws.progress) { const w = ws.progress['whisper'] || 0, te = ws.progress['th-en'] || 0, et = ws.progress['en-th'] || 0; let pct = 0; if (w > 0) pct = w * 0.4; if (te > 0) pct = 40 + te * 0.3; if (et > 0) pct = 70 + et * 0.3; prog.style.width = pct + '%'; }
            if (task) task.textContent = ws.task || '';
        }
        
        // Progress
        function showProgress() { document.getElementById('progressBar').classList.add('visible'); }
        function hideProgress() { document.getElementById('progressBar').classList.remove('visible'); }
        function updateStats() {
            const metas = Array.from(S.chunkMeta.values());
            S.stats.total = metas.length;
            S.stats.transcribed = metas.filter(m => m.transcript !== null || m.filtered).length;
            S.stats.translated = metas.filter(m => m.translation !== null).length;
            S.stats.filtered = metas.filter(m => m.filtered).length;
            const toTrans = S.stats.transcribed - S.stats.filtered;
            document.getElementById('progressFillTranscribe').style.width = (S.stats.total > 0 ? (S.stats.transcribed / S.stats.total) * 50 : 0) + '%';
            document.getElementById('progressFillTranslate').style.width = (toTrans > 0 ? (S.stats.translated / toTrans) * 50 : 0) + '%';
            document.getElementById('progressTranscribe').textContent = 'Transcribe: ' + S.stats.transcribed + '/' + S.stats.total;
            document.getElementById('progressTranslate').textContent = 'Translate: ' + S.stats.translated + '/' + toTrans;
            document.getElementById('progressLabel').textContent = S.stats.transcribed < S.stats.total ? 'Transcribing...' : S.stats.translated < toTrans ? 'Translating...' : 'Complete';
        }
        
        // Ingest UI
        function showIngest() { document.getElementById('ingestOverlay').classList.remove('hidden'); }
        function hideIngest() { document.getElementById('ingestOverlay').classList.add('hidden'); }
        function updateIng(status, pct) { document.getElementById('ingestStatus').textContent = status; document.getElementById('ingestProgressFill').style.width = pct + '%'; document.getElementById('ingestDetail').textContent = Math.round(pct) + '%'; }
        
        // Utils
        function toast(type, msg) { const el = document.createElement('div'); el.className = 'toast ' + type; el.textContent = (type === 'success' ? '‚úì' : type === 'error' ? '‚úï' : '‚Ñπ') + ' ' + msg; document.getElementById('toastContainer').appendChild(el); setTimeout(() => { el.style.opacity = '0'; setTimeout(() => el.remove(), 300); }, 3000); }
        function fmtTime(s) { return Math.floor(s / 60) + ':' + Math.floor(s % 60).toString().padStart(2, '0'); }
        function fmtDur(s) { const h = Math.floor(s / 3600), m = Math.floor((s % 3600) / 60), sec = Math.floor(s % 60); return h > 0 ? h + ':' + m.toString().padStart(2, '0') + ':' + sec.toString().padStart(2, '0') : m + ':' + sec.toString().padStart(2, '0'); }
        function esc(t) { const d = document.createElement('div'); d.textContent = t; return d.innerHTML; }
        function setupDrop(el) { if (!el) return; el.onclick = () => document.getElementById('fileInput').click(); el.ondragover = e => { e.preventDefault(); el.classList.add('dragover'); }; el.ondragleave = () => el.classList.remove('dragover'); el.ondrop = e => { e.preventDefault(); el.classList.remove('dragover'); const f = e.dataTransfer.files[0]; if (f?.type.startsWith('audio/') || f?.name.match(/\.(m4a|mp3|wav|ogg|flac)$/i)) ingest(f); else toast('error', 'Drop audio file'); }; }
        
        // Event Listeners
        document.getElementById('fileInput').onchange = e => { if (e.target.files[0]) ingest(e.target.files[0]); e.target.value = ''; };
        document.getElementById('newSessionBtn').onclick = () => document.getElementById('fileInput').click();
        document.getElementById('restartBtn').onclick = async () => { if (S.processing) { toast('warning', 'Stop first'); return; } toast('info', 'Restarting...'); await initWorkers(); };
        document.getElementById('settingsBtn').onclick = () => { S.config.setupComplete = false; S.step = 1; updateSetup(); document.getElementById('setupOverlay').classList.remove('hidden'); };
        document.getElementById('setupNextBtn').onclick = async () => {
            if (S.step === 1) { S.step = 2; updateEst(); }
            else if (S.step === 2) { S.config.workerCount = parseInt(document.getElementById('setupWorkerSlider').value); S.step = 3; updateSetup(); createSetupW(); await initWorkers(); }
            else if (S.step === 4) { document.getElementById('setupOverlay').classList.add('hidden'); }
            updateSetup();
        };
        document.getElementById('setupBackBtn').onclick = () => { if (S.step > 1 && S.step < 3) { S.step--; updateSetup(); } };
        document.querySelectorAll('.setup-option').forEach(opt => opt.onclick = () => { opt.closest('.setup-step').querySelectorAll('.setup-option').forEach(o => o.classList.remove('selected')); opt.classList.add('selected'); if (opt.closest('.setup-step').dataset.step === '1') { S.config.whisperModel = opt.dataset.value; updateEst(); } });
        document.getElementById('setupWorkerSlider').oninput = updateEst;
        document.body.ondragover = e => e.preventDefault();
        document.body.ondrop = e => { e.preventDefault(); const f = e.dataTransfer.files[0]; if (f?.type.startsWith('audio/') || f?.name.match(/\.(m4a|mp3|wav|ogg|flac)$/i)) ingest(f); };
        
        // Init
        async function init() {
            try {
                await store.init();
                const cfg = await store.getConfig();
                S.config = { ...S.config, ...cfg };
                if (S.config.setupComplete) {
                    document.getElementById('setupOverlay').classList.add('hidden');
                    await initWorkers();
                    await refreshSessions();
                    const sessions = await store.getSessions();
                    if (sessions.length > 0) await loadSession(sessions[0].id);
                    else renderEmpty();
                } else { updateSetup(); updateEst(); }
            } catch (err) { console.error('Init error:', err); toast('error', 'Init failed'); }
        }
        
        init();
    </script>
</body>
</html>
