<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thai Transcriber v8 ‚Äî Gemini</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Thai:wght@300;400;500;600&family=DM+Sans:wght@300;400;500;600;700&family=DM+Mono:wght@400;500&display=swap');

        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-0: #08080c;
            --bg-1: #0e0e14;
            --bg-2: #15151e;
            --bg-3: #1c1c28;
            --bg-4: #252534;
            --border-1: #2a2a3c;
            --border-2: #383850;
            --text-1: #eaeaf2;
            --text-2: #a8a8c0;
            --text-3: #686880;
            --gold: #e2b04a;
            --gold-dim: #b08930;
            --gold-glow: rgba(226, 176, 74, 0.12);
            --thai-blue: #5a9fd4;
            --eng-green: #5ab88a;
            --ok: #4caf7a;
            --warn: #d4a04a;
            --err: #d45a5a;
            --radius: 8px;
        }

        html, body { height: 100%; overflow: hidden; }

        body {
            font-family: 'DM Sans', sans-serif;
            background: var(--bg-0);
            color: var(--text-1);
            line-height: 1.6;
            font-size: 14px;
        }

        /* ‚îÄ‚îÄ Layout ‚îÄ‚îÄ */
        .app { display: flex; flex-direction: column; height: 100vh; }

        .header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 0.65rem 1.25rem;
            background: var(--bg-1);
            border-bottom: 1px solid var(--border-1);
        }

        .logo {
            font-size: 0.85rem; font-weight: 300; letter-spacing: 0.25em; text-transform: uppercase;
            background: linear-gradient(135deg, var(--gold), var(--gold-dim));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }

        .logo-sub {
            font-size: 0.6rem; letter-spacing: 0.08em; color: var(--text-3);
            margin-left: 0.75rem; font-family: 'DM Mono', monospace;
        }

        .header-right { display: flex; align-items: center; gap: 0.5rem; }

        .api-status {
            display: flex; align-items: center; gap: 0.4rem;
            padding: 0.3rem 0.7rem;
            background: var(--bg-2);
            border: 1px solid var(--border-1);
            border-radius: 20px;
            font-size: 0.65rem;
            font-family: 'DM Mono', monospace;
            color: var(--text-3);
        }

        .api-dot {
            width: 7px; height: 7px; border-radius: 50%;
            background: var(--border-2);
        }
        .api-dot.ok { background: var(--ok); box-shadow: 0 0 6px rgba(76, 175, 122, 0.4); }
        .api-dot.working { background: var(--gold); animation: pulse 0.6s infinite; }
        .api-dot.error { background: var(--err); }

        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

        .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; }

        /* ‚îÄ‚îÄ Drop Zone / Welcome ‚îÄ‚îÄ */
        .welcome {
            flex: 1; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            padding: 2rem;
        }

        .welcome-icon {
            width: 80px; height: 80px;
            background: var(--bg-2);
            border: 2px solid var(--border-1);
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 2rem;
            margin-bottom: 1.5rem;
        }

        .welcome h2 {
            font-size: 1.1rem; font-weight: 400; color: var(--text-2);
            margin-bottom: 0.4rem;
        }

        .welcome p {
            font-size: 0.8rem; color: var(--text-3);
            margin-bottom: 2rem; text-align: center; max-width: 400px;
        }

        .drop-zone {
            width: 100%; max-width: 420px;
            padding: 2.5rem 2rem;
            border: 2px dashed var(--border-2);
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--gold);
            background: var(--gold-glow);
        }

        .drop-zone-label {
            font-size: 0.85rem; color: var(--text-2); margin-bottom: 0.3rem;
        }

        .drop-zone-sub {
            font-size: 0.7rem; color: var(--text-3);
            font-family: 'DM Mono', monospace;
        }

        /* ‚îÄ‚îÄ Session Bar ‚îÄ‚îÄ */
        .session-bar {
            display: flex; align-items: center; justify-content: space-between;
            padding: 0.6rem 1.25rem;
            background: var(--bg-1);
            border-bottom: 1px solid var(--border-1);
            gap: 1rem;
        }

        .session-info { flex: 1; min-width: 0; }

        .session-name {
            font-size: 0.95rem; font-weight: 500;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }

        .session-meta {
            font-size: 0.65rem; color: var(--text-3);
            font-family: 'DM Mono', monospace;
            display: flex; gap: 0.75rem; flex-wrap: wrap;
        }

        .session-actions { display: flex; gap: 0.5rem; flex-shrink: 0; }

        .btn {
            padding: 0.45rem 0.9rem;
            border: none; border-radius: var(--radius);
            font-family: 'DM Sans', sans-serif;
            font-size: 0.75rem; font-weight: 500;
            cursor: pointer;
            display: inline-flex; align-items: center; gap: 0.35rem;
            transition: all 0.15s;
        }

        .btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-gold { background: linear-gradient(135deg, var(--gold), var(--gold-dim)); color: var(--bg-0); }
        .btn-gold:hover:not(:disabled) { filter: brightness(1.1); }
        .btn-outline { background: transparent; border: 1px solid var(--border-2); color: var(--text-2); }
        .btn-outline:hover:not(:disabled) { border-color: var(--gold); color: var(--gold); }
        .btn-stop { background: var(--err); color: white; }
        .btn-sm { padding: 0.3rem 0.6rem; font-size: 0.7rem; }
        .btn-ghost { background: transparent; color: var(--text-3); padding: 0.3rem 0.5rem; }
        .btn-ghost:hover { color: var(--text-1); }

        /* ‚îÄ‚îÄ Progress ‚îÄ‚îÄ */
        .progress-bar {
            padding: 0.5rem 1.25rem;
            background: var(--bg-1);
            border-bottom: 1px solid var(--border-1);
            display: none;
        }

        .progress-bar.visible { display: block; }

        .progress-top {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 0.35rem;
        }

        .progress-label {
            font-size: 0.7rem; color: var(--text-2);
        }

        .progress-stats {
            font-size: 0.65rem; color: var(--text-3);
            font-family: 'DM Mono', monospace;
        }

        .progress-track {
            height: 5px; background: var(--bg-3);
            border-radius: 3px; overflow: hidden;
        }

        .progress-fill {
            height: 100%; width: 0%;
            background: linear-gradient(90deg, var(--gold-dim), var(--gold));
            border-radius: 3px;
            transition: width 0.4s ease;
        }

        /* ‚îÄ‚îÄ Transcript Area ‚îÄ‚îÄ */
        .transcript { flex: 1; display: flex; flex-direction: column; overflow: hidden; }

        .transcript-cols {
            display: grid; grid-template-columns: 1fr 1fr;
            border-bottom: 1px solid var(--border-1);
            background: var(--bg-1);
        }

        .col-header {
            padding: 0.55rem 1.25rem;
            display: flex; align-items: center; justify-content: space-between;
            font-size: 0.65rem; font-weight: 600;
            text-transform: uppercase; letter-spacing: 0.1em;
            color: var(--text-3);
        }

        .col-header:first-child { border-right: 1px solid var(--border-1); }

        .col-tag {
            font-size: 0.6rem; font-weight: 500;
            padding: 0.1rem 0.4rem; border-radius: 3px;
        }

        .col-tag.thai { background: rgba(90, 159, 212, 0.12); color: var(--thai-blue); }
        .col-tag.eng { background: rgba(90, 184, 138, 0.12); color: var(--eng-green); }

        .scroll { flex: 1; overflow-y: auto; }

        .chunk {
            display: grid; grid-template-columns: 1fr 1fr;
            border-bottom: 1px solid var(--border-1);
            transition: background 0.15s;
        }

        .chunk:hover { background: rgba(255, 255, 255, 0.015); }
        .chunk.processing { background: var(--gold-glow); }
        .chunk.error-row { background: rgba(212, 90, 90, 0.05); }

        .cell {
            padding: 0.85rem 1.25rem;
            min-height: 70px;
        }

        .cell:first-child { border-right: 1px solid var(--border-1); }

        .cell-head {
            display: flex; align-items: center; gap: 0.5rem;
            margin-bottom: 0.45rem;
        }

        .cell-id {
            font-family: 'DM Mono', monospace;
            font-size: 0.6rem; color: var(--text-3);
            background: var(--bg-3);
            padding: 0.12rem 0.35rem; border-radius: 3px;
        }

        .cell-time {
            font-family: 'DM Mono', monospace;
            font-size: 0.6rem; color: var(--text-3);
        }

        .cell-text {
            font-size: 0.9rem; line-height: 1.8;
        }

        .cell-text.thai-text {
            font-family: 'Noto Sans Thai', 'DM Sans', sans-serif;
        }

        .cell-text.empty {
            color: var(--text-3); font-style: italic; font-size: 0.8rem;
        }

        .cell-text.error-text {
            color: var(--err); font-size: 0.8rem;
        }

        .cell-actions {
            display: flex; gap: 0.3rem; margin-top: 0.4rem;
            opacity: 0; transition: opacity 0.15s;
        }

        .chunk:hover .cell-actions { opacity: 1; }

        .cell-action {
            padding: 0.15rem 0.35rem;
            font-size: 0.6rem; font-family: 'DM Sans', sans-serif;
            background: var(--bg-3); border: 1px solid var(--border-1);
            color: var(--text-3); border-radius: 3px;
            cursor: pointer; transition: all 0.15s;
        }

        .cell-action:hover {
            background: var(--bg-4); color: var(--text-1);
            border-color: var(--border-2);
        }

        /* ‚îÄ‚îÄ Back-Translate Drawer ‚îÄ‚îÄ */
        .chunk-wrapper {
            border-bottom: 1px solid var(--border-1);
        }

        .chunk-wrapper .chunk {
            border-bottom: none;
        }

        .bt-toggle {
            display: flex; align-items: center; gap: 0.5rem;
            padding: 0.35rem 1.25rem;
            background: var(--bg-1);
            border-top: 1px solid var(--border-1);
            cursor: pointer;
            user-select: none;
            transition: background 0.15s;
        }

        .bt-toggle:hover {
            background: var(--bg-2);
        }

        .bt-toggle.disabled {
            opacity: 0.3;
            cursor: default;
            pointer-events: none;
        }

        .bt-chevron {
            font-size: 0.6rem;
            color: var(--text-3);
            transition: transform 0.25s ease;
            display: inline-block;
            width: 12px; height: 12px;
            text-align: center; line-height: 12px;
        }

        .bt-toggle.open .bt-chevron {
            transform: rotate(90deg);
        }

        .bt-label {
            font-size: 0.65rem;
            font-family: 'DM Mono', monospace;
            color: var(--text-3);
        }

        .bt-toggle:hover .bt-label {
            color: var(--gold);
        }

        .bt-toggle:hover .bt-chevron {
            color: var(--gold);
        }

        .bt-spinner {
            width: 10px; height: 10px;
            border: 1.5px solid var(--border-2);
            border-top-color: var(--gold);
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
            display: none;
        }

        .bt-toggle.loading .bt-spinner { display: inline-block; }
        .bt-toggle.loading .bt-chevron { display: none; }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .bt-drawer {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.25s ease;
            opacity: 0;
            background: var(--bg-1);
        }

        .bt-drawer.open {
            max-height: 400px;
            opacity: 1;
        }

        .bt-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            padding: 0.75rem 1.25rem 1rem;
            gap: 0;
        }

        .bt-col {
            padding: 0.5rem 0.75rem;
        }

        .bt-col:first-child {
            border-right: 1px solid var(--border-1);
        }

        .bt-col-label {
            font-size: 0.6rem; font-weight: 600;
            text-transform: uppercase; letter-spacing: 0.08em;
            color: var(--text-3);
            margin-bottom: 0.35rem;
            display: flex; align-items: center; gap: 0.4rem;
        }

        .bt-arrow {
            color: var(--gold-dim);
            font-size: 0.7rem;
        }

        .bt-text {
            font-size: 0.85rem;
            line-height: 1.7;
            color: var(--gold);
            font-style: italic;
        }

        .bt-text.thai-text {
            font-family: 'Noto Sans Thai', 'DM Sans', sans-serif;
        }

        .bt-text.empty {
            color: var(--text-3);
        }

        .bt-actions {
            padding: 0.25rem 1.25rem 0.6rem;
            display: flex; gap: 0.3rem;
        }

        @media (max-width: 768px) {
            .bt-content { grid-template-columns: 1fr; }
            .bt-col:first-child { border-right: none; border-bottom: 1px solid var(--border-1); padding-bottom: 0.75rem; margin-bottom: 0.5rem; }
        }

        /* ‚îÄ‚îÄ Settings Panel ‚îÄ‚îÄ */
        .overlay {
            position: fixed; inset: 0;
            background: rgba(8, 8, 12, 0.92);
            z-index: 1000;
            display: flex; align-items: center; justify-content: center;
            padding: 1rem;
            backdrop-filter: blur(4px);
        }

        .overlay.hidden { display: none; }

        .modal {
            background: var(--bg-1);
            border: 1px solid var(--border-1);
            border-radius: 12px;
            width: 100%; max-width: 440px;
            overflow: hidden;
        }

        .modal-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid var(--border-1);
        }

        .modal-title { font-size: 1rem; font-weight: 500; }
        .modal-sub { font-size: 0.75rem; color: var(--text-3); margin-top: 0.2rem; }

        .modal-body { padding: 1.5rem; }

        .field { margin-bottom: 1.25rem; }

        .field-label {
            font-size: 0.7rem; font-weight: 600;
            text-transform: uppercase; letter-spacing: 0.08em;
            color: var(--text-3); margin-bottom: 0.5rem;
        }

        .field-input {
            width: 100%; padding: 0.6rem 0.8rem;
            background: var(--bg-2);
            border: 1px solid var(--border-1);
            border-radius: var(--radius);
            color: var(--text-1);
            font-family: 'DM Mono', monospace;
            font-size: 0.8rem;
        }

        .field-input:focus {
            outline: none;
            border-color: var(--gold);
            box-shadow: 0 0 0 2px var(--gold-glow);
        }

        .field-hint {
            font-size: 0.65rem; color: var(--text-3);
            margin-top: 0.35rem;
        }

        .field-select {
            width: 100%; padding: 0.6rem 0.8rem;
            background: var(--bg-2);
            border: 1px solid var(--border-1);
            border-radius: var(--radius);
            color: var(--text-1);
            font-family: 'DM Sans', sans-serif;
            font-size: 0.8rem;
        }

        .field-select:focus {
            outline: none; border-color: var(--gold);
        }

        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border-1);
            display: flex; justify-content: flex-end; gap: 0.5rem;
        }

        /* ‚îÄ‚îÄ Ingest Overlay ‚îÄ‚îÄ */
        .ingest-modal {
            background: var(--bg-1);
            border: 1px solid var(--border-1);
            border-radius: 12px;
            width: 100%; max-width: 380px;
            padding: 2rem; text-align: center;
        }

        .ingest-icon { font-size: 2.5rem; margin-bottom: 1rem; }

        .ingest-title { font-size: 0.95rem; margin-bottom: 0.4rem; }

        .ingest-status {
            font-size: 0.75rem; color: var(--text-3); margin-bottom: 1rem;
        }

        .ingest-track {
            height: 5px; background: var(--bg-3);
            border-radius: 3px; overflow: hidden; margin-bottom: 0.5rem;
        }

        .ingest-fill {
            height: 100%; width: 0%;
            background: linear-gradient(90deg, var(--gold-dim), var(--gold));
            transition: width 0.3s;
        }

        .ingest-detail {
            font-size: 0.65rem; color: var(--text-3);
            font-family: 'DM Mono', monospace;
        }

        /* ‚îÄ‚îÄ Toast ‚îÄ‚îÄ */
        .toast-wrap {
            position: fixed; bottom: 1rem; right: 1rem; z-index: 2000;
            display: flex; flex-direction: column; gap: 0.4rem;
        }

        .toast {
            padding: 0.6rem 1rem;
            background: var(--bg-3);
            border: 1px solid var(--border-1);
            border-radius: var(--radius);
            font-size: 0.8rem;
            animation: slideIn 0.2s ease;
            transition: opacity 0.3s;
        }

        .toast.ok { border-left: 3px solid var(--ok); }
        .toast.err { border-left: 3px solid var(--err); }
        .toast.warn { border-left: 3px solid var(--warn); }

        @keyframes slideIn {
            from { transform: translateX(40px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* ‚îÄ‚îÄ Scrollbar ‚îÄ‚îÄ */
        .scroll::-webkit-scrollbar { width: 6px; }
        .scroll::-webkit-scrollbar-track { background: transparent; }
        .scroll::-webkit-scrollbar-thumb { background: var(--border-1); border-radius: 3px; }
        .scroll::-webkit-scrollbar-thumb:hover { background: var(--border-2); }

        input[type="file"] { display: none; }

        /* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
        @media (max-width: 768px) {
            .chunk { grid-template-columns: 1fr; }
            .cell:first-child { border-right: none; border-bottom: 1px solid var(--border-1); }
            .transcript-cols { grid-template-columns: 1fr; }
            .col-header:first-child { border-right: none; border-bottom: 1px solid var(--border-1); }
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- Header -->
        <header class="header">
            <div style="display:flex;align-items:baseline;">
                <span class="logo">Thai Transcriber</span>
                <span class="logo-sub">v8 ¬∑ Gemini</span>
            </div>
            <div class="header-right">
                <div class="api-status">
                    <div class="api-dot" id="apiDot"></div>
                    <span id="apiStatusText">No API key</span>
                </div>
                <button class="btn btn-ghost" id="settingsBtn" title="Settings">‚öôÔ∏è</button>
            </div>
        </header>

        <!-- Main content -->
        <div class="main" id="mainArea">
            <!-- Welcome state (shown by default) -->
            <div class="welcome" id="welcomeView">
                <div class="welcome-icon">üéôÔ∏è</div>
                <h2>Thai Audio ‚Üí English Text</h2>
                <p>Drop a Thai audio recording and Gemini will transcribe and translate it to readable English.</p>
                <div class="drop-zone" id="dropZone">
                    <div class="drop-zone-label">üìÇ Drop audio file or click to browse</div>
                    <div class="drop-zone-sub">m4a ¬∑ mp3 ¬∑ wav ¬∑ ogg ¬∑ flac</div>
                </div>
            </div>
        </div>

        <!-- Progress bar -->
        <div class="progress-bar" id="progressBar">
            <div class="progress-top">
                <span class="progress-label" id="progressLabel">Processing...</span>
                <span class="progress-stats" id="progressStats">0 / 0</span>
            </div>
            <div class="progress-track">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
    </div>

    <!-- Settings overlay -->
    <div class="overlay hidden" id="settingsOverlay">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Settings</div>
                <div class="modal-sub">Configure Gemini API connection</div>
            </div>
            <div class="modal-body">
                <div class="field">
                    <div class="field-label">Gemini API Key</div>
                    <input type="password" class="field-input" id="apiKeyInput" placeholder="AIzaSy..." autocomplete="off">
                    <div class="field-hint">From Google AI Studio ¬∑ stored locally only</div>
                </div>
                <div class="field">
                    <div class="field-label">Model</div>
                    <select class="field-select" id="modelSelect">
                        <option value="gemini-2.0-flash">Gemini 2.0 Flash (fast, recommended)</option>
                        <option value="gemini-2.5-flash-preview-05-20">Gemini 2.5 Flash (best balance)</option>
                        <option value="gemini-2.5-pro-preview-05-06">Gemini 2.5 Pro (highest quality)</option>
                    </select>
                    <div class="field-hint">Flash is fast and free-tier friendly ¬∑ Pro is best for difficult audio</div>
                </div>
                <div class="field">
                    <div class="field-label">Chunk Duration (seconds)</div>
                    <select class="field-select" id="chunkSelect">
                        <option value="60">60s ‚Äî More chunks, faster per-chunk</option>
                        <option value="120" selected>120s ‚Äî Good balance</option>
                        <option value="180">180s ‚Äî Better context</option>
                        <option value="300">300s ‚Äî Fewer chunks, more context</option>
                    </select>
                    <div class="field-hint">Longer chunks give Gemini more context for better results</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="settingsCancel">Cancel</button>
                <button class="btn btn-gold" id="settingsSave">Save</button>
            </div>
        </div>
    </div>

    <!-- Ingest overlay -->
    <div class="overlay hidden" id="ingestOverlay">
        <div class="ingest-modal">
            <div class="ingest-icon">üîä</div>
            <div class="ingest-title">Preparing Audio</div>
            <div class="ingest-status" id="ingestStatus">Reading file...</div>
            <div class="ingest-track"><div class="ingest-fill" id="ingestFill"></div></div>
            <div class="ingest-detail" id="ingestDetail">0%</div>
        </div>
    </div>

    <!-- Toast container -->
    <div class="toast-wrap" id="toastWrap"></div>

    <input type="file" id="fileInput" accept="audio/*,.m4a,.mp3,.wav,.ogg,.flac">

    <script>
        // ‚îÄ‚îÄ‚îÄ Config & State ‚îÄ‚îÄ‚îÄ
        const CONFIG_KEY = 'thai-transcriber-v8-config';
        const SR = 16000; // sample rate for processing

        let config = {
            apiKey: 'AIzaSyBH9zuyG1e3Yheu8EngJFrRYLE2X1oIZkI',
            model: 'gemini-2.0-flash',
            chunkSec: 120
        };

        let state = {
            session: null,     // { name, fileName, duration, totalChunks, chunks[] }
            processing: false,
            currentChunk: -1,
            abortController: null
        };

        // ‚îÄ‚îÄ‚îÄ Init ‚îÄ‚îÄ‚îÄ
        function init() {
            loadConfig();
            setupEvents();
            updateApiStatus();

            // Auto-show settings if no API key
            if (!config.apiKey) {
                document.getElementById('settingsOverlay').classList.remove('hidden');
            }
        }

        function loadConfig() {
            try {
                const saved = JSON.parse(localStorage.getItem(CONFIG_KEY));
                if (saved) config = { ...config, ...saved };
            } catch(e) {}
            document.getElementById('apiKeyInput').value = config.apiKey;
            document.getElementById('modelSelect').value = config.model;
            document.getElementById('chunkSelect').value = String(config.chunkSec);
        }

        function saveConfig() {
            config.apiKey = document.getElementById('apiKeyInput').value.trim();
            config.model = document.getElementById('modelSelect').value;
            config.chunkSec = parseInt(document.getElementById('chunkSelect').value);
            localStorage.setItem(CONFIG_KEY, JSON.stringify(config));
            updateApiStatus();
        }

        function updateApiStatus() {
            const dot = document.getElementById('apiDot');
            const txt = document.getElementById('apiStatusText');
            if (!config.apiKey) {
                dot.className = 'api-dot';
                txt.textContent = 'No API key';
            } else if (state.processing) {
                dot.className = 'api-dot working';
                txt.textContent = 'Processing...';
            } else {
                dot.className = 'api-dot ok';
                txt.textContent = config.model.replace('gemini-', '').replace('-preview-05-20','').replace('-preview-05-06','');
            }
        }

        // ‚îÄ‚îÄ‚îÄ Events ‚îÄ‚îÄ‚îÄ
        function setupEvents() {
            const drop = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');

            drop.onclick = () => fileInput.click();
            drop.ondragover = e => { e.preventDefault(); drop.classList.add('dragover'); };
            drop.ondragleave = () => drop.classList.remove('dragover');
            drop.ondrop = e => {
                e.preventDefault(); drop.classList.remove('dragover');
                const f = e.dataTransfer.files[0];
                if (f && isAudio(f)) ingestFile(f);
                else toast('err', 'Please drop an audio file');
            };

            document.body.ondragover = e => e.preventDefault();
            document.body.ondrop = e => {
                e.preventDefault();
                const f = e.dataTransfer?.files[0];
                if (f && isAudio(f)) ingestFile(f);
            };

            fileInput.onchange = e => {
                if (e.target.files[0]) ingestFile(e.target.files[0]);
                e.target.value = '';
            };

            document.getElementById('settingsBtn').onclick = () => {
                document.getElementById('apiKeyInput').value = config.apiKey;
                document.getElementById('modelSelect').value = config.model;
                document.getElementById('chunkSelect').value = String(config.chunkSec);
                document.getElementById('settingsOverlay').classList.remove('hidden');
            };

            document.getElementById('settingsCancel').onclick = () => {
                document.getElementById('settingsOverlay').classList.add('hidden');
            };

            document.getElementById('settingsSave').onclick = () => {
                saveConfig();
                document.getElementById('settingsOverlay').classList.add('hidden');
                toast('ok', 'Settings saved');
            };
        }

        function isAudio(f) {
            return f.type.startsWith('audio/') || /\.(m4a|mp3|wav|ogg|flac|aac|wma|webm)$/i.test(f.name);
        }

        // ‚îÄ‚îÄ‚îÄ Audio Ingest ‚îÄ‚îÄ‚îÄ
        async function ingestFile(file) {
            if (!config.apiKey) {
                document.getElementById('settingsOverlay').classList.remove('hidden');
                toast('warn', 'Set your API key first');
                return;
            }

            const overlay = document.getElementById('ingestOverlay');
            overlay.classList.remove('hidden');
            setIngest('Reading file...', 0);

            try {
                // Read file as ArrayBuffer
                const arrayBuf = await new Promise((res, rej) => {
                    const reader = new FileReader();
                    reader.onprogress = e => {
                        if (e.lengthComputable) setIngest('Reading...', (e.loaded / e.total) * 25);
                    };
                    reader.onload = () => res(reader.result);
                    reader.onerror = () => rej(reader.error);
                    reader.readAsArrayBuffer(file);
                });

                // Also read as base64 for API (we'll chunk later)
                setIngest('Reading base64...', 28);
                const base64Full = await new Promise((res, rej) => {
                    const reader = new FileReader();
                    reader.onload = () => res(reader.result.split(',')[1]);
                    reader.onerror = () => rej(reader.error);
                    reader.readAsDataURL(file);
                });

                setIngest('Decoding audio...', 35);

                // Decode to get duration and for chunking
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SR });
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuf.slice(0));
                const duration = audioBuffer.duration;

                setIngest('Preparing chunks...', 55);

                // Get mono audio data
                let mono;
                if (audioBuffer.numberOfChannels === 1) {
                    mono = new Float32Array(audioBuffer.length);
                    audioBuffer.copyFromChannel(mono, 0);
                } else {
                    const left = new Float32Array(audioBuffer.length);
                    const right = new Float32Array(audioBuffer.length);
                    audioBuffer.copyFromChannel(left, 0);
                    audioBuffer.copyFromChannel(right, 1);
                    mono = new Float32Array(audioBuffer.length);
                    for (let i = 0; i < mono.length; i++) mono[i] = (left[i] + right[i]) / 2;
                }

                // Resample if needed (already at SR from audioCtx)
                const chunkSamples = config.chunkSec * SR;
                const totalChunks = Math.ceil(mono.length / chunkSamples);

                setIngest('Encoding chunks...', 65);

                // Create WAV chunks as base64
                const chunks = [];
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * chunkSamples;
                    const end = Math.min(start + chunkSamples, mono.length);
                    const samples = mono.slice(start, end);
                    const wavBase64 = encodeWavBase64(samples, SR);

                    chunks.push({
                        index: i,
                        startTime: start / SR,
                        endTime: end / SR,
                        audioBase64: wavBase64,
                        mimeType: 'audio/wav',
                        thai: null,
                        english: null,
                        status: 'pending',  // pending | processing | done | error
                        error: null,
                        // Back-translation fields
                        btThai: null,       // English ‚Üí Thai back-translation
                        btEnglish: null,    // Thai ‚Üí English back-translation
                        btStatus: 'idle',   // idle | loading | done | error
                        btOpen: false       // chevron open state
                    });

                    if (i % 5 === 0) setIngest('Encoding chunks...', 65 + (i / totalChunks) * 30);
                }

                audioCtx.close();

                // Build session
                state.session = {
                    name: file.name.replace(/\.[^.]+$/, ''),
                    fileName: file.name,
                    fileSize: file.size,
                    duration: duration,
                    totalChunks: totalChunks,
                    chunks: chunks
                };

                setIngest('Ready!', 100);
                setTimeout(() => overlay.classList.add('hidden'), 300);

                renderSession();
                toast('ok', `${totalChunks} chunks ready ¬∑ ${fmtDur(duration)}`);

            } catch (err) {
                overlay.classList.add('hidden');
                toast('err', 'Failed to process audio: ' + err.message);
                console.error(err);
            }
        }

        function setIngest(text, pct) {
            document.getElementById('ingestStatus').textContent = text;
            document.getElementById('ingestFill').style.width = pct + '%';
            document.getElementById('ingestDetail').textContent = Math.round(pct) + '%';
        }

        // ‚îÄ‚îÄ‚îÄ WAV Encoding ‚îÄ‚îÄ‚îÄ
        function encodeWavBase64(samples, sampleRate) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);
            const dataSize = samples.length * (bitsPerSample / 8);
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            // WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            // Samples
            let offset = 44;
            for (let i = 0; i < samples.length; i++) {
                const s = Math.max(-1, Math.min(1, samples[i]));
                view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                offset += 2;
            }

            // Convert to base64
            const bytes = new Uint8Array(buffer);
            let binary = '';
            const chunkSize = 8192;
            for (let i = 0; i < bytes.length; i += chunkSize) {
                binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
            }
            return btoa(binary);
        }

        function writeString(view, offset, str) {
            for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
        }

        // ‚îÄ‚îÄ‚îÄ Gemini API ‚îÄ‚îÄ‚îÄ
        async function callGemini(audioBase64, mimeType, chunkIndex, totalChunks, contextHint) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${config.model}:generateContent?key=${config.apiKey}`;

            const prompt = `You are a professional Thai language transcriber and translator.

TASK: Listen to this Thai audio recording (chunk ${chunkIndex + 1} of ${totalChunks}) and provide:
1. The Thai transcription (accurate Thai text of what is spoken)
2. An English translation (natural, readable English)

${contextHint ? `CONTEXT from previous chunk: "${contextHint}"` : ''}

RULES:
- If the audio contains Thai speech, transcribe it accurately in Thai script
- If the audio contains English speech, transcribe in English and note it
- If the audio is silence, music, or unintelligible, say so briefly
- The English translation should be natural and fluent, not word-for-word
- Preserve the meaning and tone of the original

RESPOND IN EXACTLY THIS JSON FORMAT (no markdown, no code fences):
{"thai": "Thai transcription here", "english": "English translation here", "notes": "any relevant notes or null"}`;

            const body = {
                contents: [{
                    parts: [
                        {
                            inline_data: {
                                mime_type: mimeType,
                                data: audioBase64
                            }
                        },
                        { text: prompt }
                    ]
                }],
                generationConfig: {
                    temperature: 0.1,
                    maxOutputTokens: 4096
                }
            };

            const resp = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body),
                signal: state.abortController?.signal
            });

            if (!resp.ok) {
                const errData = await resp.json().catch(() => ({}));
                const errMsg = errData?.error?.message || `HTTP ${resp.status}`;
                throw new Error(errMsg);
            }

            const data = await resp.json();

            // Extract text from response
            const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';

            // Parse JSON response
            try {
                // Strip markdown code fences if present
                const clean = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                const parsed = JSON.parse(clean);
                return {
                    thai: parsed.thai || '',
                    english: parsed.english || '',
                    notes: parsed.notes || null
                };
            } catch (parseErr) {
                // If JSON parsing fails, try to extract content heuristically
                console.warn('JSON parse failed, extracting heuristically:', text);
                return {
                    thai: extractBetween(text, 'thai', 'english') || text,
                    english: extractAfter(text, 'english') || text,
                    notes: 'JSON parse fallback'
                };
            }
        }

        function extractBetween(text, startKey, endKey) {
            const s = text.toLowerCase().indexOf(startKey);
            const e = text.toLowerCase().indexOf(endKey);
            if (s >= 0 && e > s) {
                return text.substring(s + startKey.length, e).replace(/^[:"'\s]+|[,"'\s]+$/g, '').trim();
            }
            return null;
        }

        function extractAfter(text, key) {
            const i = text.toLowerCase().indexOf(key);
            if (i >= 0) {
                return text.substring(i + key.length).replace(/^[:"'\s]+|[,"'\s}]+$/g, '').trim();
            }
            return null;
        }

        // ‚îÄ‚îÄ‚îÄ Processing Pipeline ‚îÄ‚îÄ‚îÄ
        async function startProcessing() {
            if (!state.session || state.processing) return;
            if (!config.apiKey) {
                document.getElementById('settingsOverlay').classList.remove('hidden');
                toast('warn', 'Set your API key first');
                return;
            }

            state.processing = true;
            state.abortController = new AbortController();
            updateApiStatus();
            showProgress();
            updateProcButton();

            const chunks = state.session.chunks;
            let contextHint = '';

            for (let i = 0; i < chunks.length; i++) {
                if (!state.processing) break;

                const chunk = chunks[i];
                if (chunk.status === 'done') {
                    // Use previous translation as context
                    contextHint = chunk.english?.slice(-200) || '';
                    updateProgress(i + 1, chunks.length);
                    continue;
                }

                chunk.status = 'processing';
                state.currentChunk = i;
                updateChunkUI(i);
                updateProgress(i, chunks.length);

                try {
                    const result = await callGemini(
                        chunk.audioBase64,
                        chunk.mimeType,
                        i,
                        chunks.length,
                        contextHint
                    );

                    chunk.thai = result.thai;
                    chunk.english = result.english;
                    chunk.notes = result.notes;
                    chunk.status = 'done';
                    chunk.error = null;

                    // Use this translation as context for next chunk
                    contextHint = result.english?.slice(-200) || '';

                } catch (err) {
                    if (err.name === 'AbortError') break;

                    chunk.status = 'error';
                    chunk.error = err.message;
                    console.error(`Chunk ${i} error:`, err);

                    // If rate limited, wait and retry
                    if (err.message.includes('429') || err.message.toLowerCase().includes('rate')) {
                        toast('warn', 'Rate limited ‚Äî waiting 30s...');
                        await sleep(30000);
                        if (state.processing) {
                            i--; // Retry this chunk
                            chunk.status = 'pending';
                        }
                    } else {
                        toast('err', `Chunk ${i + 1}: ${err.message.slice(0, 60)}`);
                    }
                }

                updateChunkUI(i);
                updateProgress(i + 1, chunks.length);

                // Small delay between requests to avoid rate limits
                if (state.processing && i < chunks.length - 1) {
                    await sleep(1000);
                }
            }

            state.processing = false;
            state.currentChunk = -1;
            updateApiStatus();
            updateProcButton();

            const doneCount = chunks.filter(c => c.status === 'done').length;
            if (doneCount === chunks.length) {
                toast('ok', 'All chunks processed!');
                hideProgress();
            } else if (doneCount > 0) {
                toast('warn', `${doneCount}/${chunks.length} chunks completed`);
            }
        }

        function stopProcessing() {
            state.processing = false;
            if (state.abortController) {
                state.abortController.abort();
                state.abortController = null;
            }
            updateApiStatus();
            updateProcButton();
            toast('warn', 'Stopped');
        }

        async function retryChunk(index) {
            if (state.processing) {
                toast('warn', 'Wait for current processing to finish');
                return;
            }

            const chunk = state.session.chunks[index];
            if (!chunk) return;

            state.processing = true;
            state.abortController = new AbortController();
            chunk.status = 'processing';
            updateChunkUI(index);
            updateApiStatus();

            // Get context from previous chunk
            const prev = index > 0 ? state.session.chunks[index - 1] : null;
            const contextHint = prev?.english?.slice(-200) || '';

            try {
                const result = await callGemini(
                    chunk.audioBase64, chunk.mimeType,
                    index, state.session.totalChunks, contextHint
                );
                chunk.thai = result.thai;
                chunk.english = result.english;
                chunk.notes = result.notes;
                chunk.status = 'done';
                chunk.error = null;
                toast('ok', `Chunk ${index + 1} retried`);
            } catch (err) {
                chunk.status = 'error';
                chunk.error = err.message;
                toast('err', err.message.slice(0, 60));
            }

            state.processing = false;
            updateChunkUI(index);
            updateApiStatus();
        }

        // ‚îÄ‚îÄ‚îÄ Back-Translate ‚îÄ‚îÄ‚îÄ
        async function backTranslateChunk(index) {
            const chunk = state.session?.chunks[index];
            if (!chunk || !chunk.english || !chunk.thai) return;

            // If already done, just toggle open
            if (chunk.btStatus === 'done') {
                chunk.btOpen = !chunk.btOpen;
                updateChunkUI(index);
                return;
            }

            // Start loading
            chunk.btStatus = 'loading';
            chunk.btOpen = true;
            updateChunkUI(index);

            const url = `https://generativelanguage.googleapis.com/v1beta/models/${config.model}:generateContent?key=${config.apiKey}`;

            const prompt = `You are a professional translator performing a BACK-TRANSLATION quality check.

You have:
- ORIGINAL THAI: "${chunk.thai}"
- ENGLISH TRANSLATION: "${chunk.english}"

TASK: Perform two back-translations to verify accuracy:
1. Translate the ENGLISH back into Thai (so we can compare with the original Thai)
2. Translate the ORIGINAL THAI back into English independently (a fresh translation to compare with the existing one)

RESPOND IN EXACTLY THIS JSON FORMAT (no markdown, no code fences):
{"back_thai": "The English translated back to Thai here", "back_english": "The Thai translated freshly to English here"}`;

            try {
                const resp = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: { temperature: 0.1, maxOutputTokens: 2048 }
                    })
                });

                if (!resp.ok) {
                    const errData = await resp.json().catch(() => ({}));
                    throw new Error(errData?.error?.message || `HTTP ${resp.status}`);
                }

                const data = await resp.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                const clean = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                const parsed = JSON.parse(clean);

                chunk.btThai = parsed.back_thai || '';
                chunk.btEnglish = parsed.back_english || '';
                chunk.btStatus = 'done';
                toast('ok', `Back-translation ${index + 1} done`);

            } catch (err) {
                chunk.btStatus = 'error';
                console.error('Back-translate error:', err);
                toast('err', 'Back-translate: ' + err.message.slice(0, 60));
            }

            updateChunkUI(index);
        }

        function toggleBt(index) {
            const chunk = state.session?.chunks[index];
            if (!chunk) return;

            if (chunk.btStatus === 'done') {
                // Already have results ‚Äî just toggle visibility
                chunk.btOpen = !chunk.btOpen;
                updateChunkUI(index);
            } else if (chunk.btStatus === 'idle' && chunk.status === 'done') {
                // Need to fetch ‚Äî triggers API call and opens
                backTranslateChunk(index);
            }
            // If loading, do nothing
        }

        function redoBt(index) {
            const chunk = state.session?.chunks[index];
            if (!chunk) return;
            chunk.btThai = null;
            chunk.btEnglish = null;
            chunk.btStatus = 'idle';
            chunk.btOpen = false;
            updateChunkUI(index);
            backTranslateChunk(index);
        }
        function renderSession() {
            const s = state.session;
            if (!s) return;

            document.getElementById('mainArea').innerHTML = `
                <div class="session-bar">
                    <div class="session-info">
                        <div class="session-name">${esc(s.name)}</div>
                        <div class="session-meta">
                            <span>${esc(s.fileName)}</span>
                            <span>${fmtDur(s.duration)}</span>
                            <span>${s.totalChunks} chunks @ ${config.chunkSec}s</span>
                            <span>${fmtSize(s.fileSize)}</span>
                        </div>
                    </div>
                    <div class="session-actions">
                        <button class="btn btn-outline btn-sm" id="newFileBtn">üìÇ New File</button>
                        <button class="btn btn-outline btn-sm" id="exportBtn">üì§ Export</button>
                        <button class="btn btn-gold btn-sm" id="procBtn">‚ñ∂ Process All</button>
                    </div>
                </div>
                <div class="transcript">
                    <div class="transcript-cols">
                        <div class="col-header">
                            <span>üáπüá≠ Thai Original</span>
                            <button class="btn btn-ghost btn-sm" id="copyThaiBtn">üìã</button>
                        </div>
                        <div class="col-header">
                            <span>üá∫üá∏ English Translation</span>
                            <button class="btn btn-ghost btn-sm" id="copyEngBtn">üìã</button>
                        </div>
                    </div>
                    <div class="scroll" id="chunkScroll"></div>
                </div>
            `;

            // Render all chunks
            const scroll = document.getElementById('chunkScroll');
            for (let i = 0; i < s.chunks.length; i++) {
                scroll.appendChild(createChunkEl(i));
            }

            // Events
            document.getElementById('procBtn').onclick = () => {
                if (state.processing) stopProcessing();
                else startProcessing();
            };

            document.getElementById('newFileBtn').onclick = () => {
                document.getElementById('fileInput').click();
            };

            document.getElementById('exportBtn').onclick = exportResults;

            document.getElementById('copyThaiBtn').onclick = () => {
                const text = s.chunks.filter(c => c.thai).map(c => c.thai).join('\n\n');
                navigator.clipboard.writeText(text).then(() => toast('ok', 'Thai text copied'));
            };

            document.getElementById('copyEngBtn').onclick = () => {
                const text = s.chunks.filter(c => c.english).map(c => c.english).join('\n\n');
                navigator.clipboard.writeText(text).then(() => toast('ok', 'English text copied'));
            };
        }

        function createChunkEl(index) {
            const chunk = state.session.chunks[index];
            const wrapper = document.createElement('div');
            wrapper.className = 'chunk-wrapper';
            wrapper.id = 'chunk-' + index;

            const id = String(index + 1).padStart(3, '0');
            const time = fmtTime(chunk.startTime) + ' ‚Üí ' + fmtTime(chunk.endTime);

            let thaiContent, engContent;

            if (chunk.status === 'done' && chunk.thai) {
                thaiContent = `<div class="cell-text thai-text">${esc(chunk.thai)}</div>
                    <div class="cell-actions">
                        <button class="cell-action" onclick="retryChunk(${index})">üîÑ Redo</button>
                        <button class="cell-action" onclick="playChunk(${index})">‚ñ∂ Play</button>
                    </div>`;
            } else if (chunk.status === 'processing') {
                thaiContent = `<div class="cell-text empty">‚è≥ Listening...</div>`;
            } else if (chunk.status === 'error') {
                thaiContent = `<div class="cell-text error-text">‚ùå ${esc(chunk.error?.slice(0, 80) || 'Error')}</div>
                    <div class="cell-actions">
                        <button class="cell-action" onclick="retryChunk(${index})">üîÑ Retry</button>
                        <button class="cell-action" onclick="playChunk(${index})">‚ñ∂ Play</button>
                    </div>`;
            } else {
                thaiContent = `<div class="cell-text empty">Waiting...</div>`;
            }

            if (chunk.status === 'done' && chunk.english) {
                engContent = `<div class="cell-text">${esc(chunk.english)}</div>
                    ${chunk.notes ? `<div style="margin-top:0.4rem;font-size:0.7rem;color:var(--text-3);font-style:italic;">${esc(chunk.notes)}</div>` : ''}`;
            } else if (chunk.status === 'processing') {
                engContent = `<div class="cell-text empty">‚è≥ Translating...</div>`;
            } else if (chunk.status === 'error') {
                engContent = `<div class="cell-text empty">‚Äî</div>`;
            } else {
                engContent = `<div class="cell-text empty">‚Äî</div>`;
            }

            // Back-translate toggle + drawer
            const canBt = chunk.status === 'done' && chunk.thai && chunk.english;
            const btLoading = chunk.btStatus === 'loading';
            const btDone = chunk.btStatus === 'done';
            const btOpen = chunk.btOpen;

            let toggleClass = 'bt-toggle';
            if (!canBt) toggleClass += ' disabled';
            if (btOpen) toggleClass += ' open';
            if (btLoading) toggleClass += ' loading';

            let btLabel = 'Back-translate';
            if (btLoading) btLabel = 'Translating...';
            else if (btDone) btLabel = btOpen ? 'Hide back-translation' : 'Show back-translation';

            let drawerContent = '';
            if (btDone) {
                drawerContent = `
                    <div class="bt-content">
                        <div class="bt-col">
                            <div class="bt-col-label"><span class="bt-arrow">‚Ü©</span> English ‚Üí Thai</div>
                            <div class="bt-text thai-text">${esc(chunk.btThai) || '<span class="empty">‚Äî</span>'}</div>
                        </div>
                        <div class="bt-col">
                            <div class="bt-col-label"><span class="bt-arrow">‚Ü©</span> Thai ‚Üí English (fresh)</div>
                            <div class="bt-text">${esc(chunk.btEnglish) || '<span class="empty">‚Äî</span>'}</div>
                        </div>
                    </div>
                    <div class="bt-actions">
                        <button class="cell-action" onclick="redoBt(${index})">üîÑ Redo back-translate</button>
                    </div>`;
            } else if (btLoading) {
                drawerContent = `
                    <div class="bt-content">
                        <div class="bt-col"><div class="bt-text empty">‚è≥ Generating...</div></div>
                        <div class="bt-col"><div class="bt-text empty">‚è≥ Generating...</div></div>
                    </div>`;
            }

            wrapper.innerHTML = `
                <div class="chunk${chunk.status === 'processing' ? ' processing' : ''}${chunk.status === 'error' ? ' error-row' : ''}">
                    <div class="cell">
                        <div class="cell-head">
                            <span class="cell-id">${id}</span>
                            <span class="cell-time">${time}</span>
                        </div>
                        ${thaiContent}
                    </div>
                    <div class="cell">
                        <div class="cell-head"></div>
                        ${engContent}
                    </div>
                </div>
                <div class="${toggleClass}" onclick="toggleBt(${index})">
                    <span class="bt-chevron">‚ñ∂</span>
                    <div class="bt-spinner"></div>
                    <span class="bt-label">${btLabel}</span>
                </div>
                <div class="bt-drawer${btOpen ? ' open' : ''}">
                    ${drawerContent}
                </div>
            `;

            return wrapper;
        }

        function updateChunkUI(index) {
            const old = document.getElementById('chunk-' + index);
            if (old) old.replaceWith(createChunkEl(index));
        }

        function updateProcButton() {
            const btn = document.getElementById('procBtn');
            if (!btn) return;
            if (state.processing) {
                btn.textContent = '‚èπ Stop';
                btn.className = 'btn btn-stop btn-sm';
            } else {
                const done = state.session?.chunks.filter(c => c.status === 'done').length || 0;
                const total = state.session?.totalChunks || 0;
                if (done === total && total > 0) {
                    btn.textContent = 'üîÑ Reprocess';
                } else if (done > 0) {
                    btn.textContent = '‚ñ∂ Continue';
                } else {
                    btn.textContent = '‚ñ∂ Process All';
                }
                btn.className = 'btn btn-gold btn-sm';
            }
        }

        // ‚îÄ‚îÄ‚îÄ Progress ‚îÄ‚îÄ‚îÄ
        function showProgress() {
            document.getElementById('progressBar').classList.add('visible');
        }

        function hideProgress() {
            document.getElementById('progressBar').classList.remove('visible');
        }

        function updateProgress(current, total) {
            const pct = total > 0 ? (current / total) * 100 : 0;
            document.getElementById('progressFill').style.width = pct + '%';
            document.getElementById('progressLabel').textContent = current >= total ? 'Complete' : `Processing chunk ${current + 1} of ${total}...`;
            document.getElementById('progressStats').textContent = `${current} / ${total}`;
        }

        // ‚îÄ‚îÄ‚îÄ Audio Playback ‚îÄ‚îÄ‚îÄ
        let playCtx = null, playSrc = null;

        function playChunk(index) {
            const chunk = state.session?.chunks[index];
            if (!chunk) return;

            if (playSrc) { playSrc.stop(); playSrc = null; }
            if (!playCtx) playCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (playCtx.state === 'suspended') playCtx.resume();

            // Decode the WAV base64
            const binary = atob(chunk.audioBase64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);

            playCtx.decodeAudioData(bytes.buffer.slice(0), buffer => {
                const src = playCtx.createBufferSource();
                src.buffer = buffer;
                src.connect(playCtx.destination);
                src.start();
                playSrc = src;
                src.onended = () => { playSrc = null; };
            });
        }

        // ‚îÄ‚îÄ‚îÄ Export ‚îÄ‚îÄ‚îÄ
        function exportResults() {
            if (!state.session) return;
            const s = state.session;
            const done = s.chunks.filter(c => c.status === 'done');

            if (done.length === 0) {
                toast('warn', 'No results to export yet');
                return;
            }

            // Build a clean markdown document
            let md = `# ${s.name}\n\n`;
            md += `**File:** ${s.fileName} ¬∑ **Duration:** ${fmtDur(s.duration)} ¬∑ **Model:** ${config.model}\n\n---\n\n`;

            // Full English translation (the main deliverable)
            md += `## English Translation\n\n`;
            for (const c of done) {
                if (c.english && c.english.trim()) {
                    md += c.english.trim() + '\n\n';
                }
            }

            md += `---\n\n## Full Transcript (Thai + English)\n\n`;
            for (const c of done) {
                const id = String(c.index + 1).padStart(3, '0');
                md += `### [${id}] ${fmtTime(c.startTime)} ‚Üí ${fmtTime(c.endTime)}\n\n`;
                if (c.thai) md += `üáπüá≠ ${c.thai}\n\n`;
                if (c.english) md += `üá∫üá∏ ${c.english}\n\n`;
                if (c.notes) md += `_${c.notes}_\n\n`;
                if (c.btThai || c.btEnglish) {
                    md += `**Back-translation:**\n\n`;
                    if (c.btThai) md += `‚Ü© EN‚ÜíTH: ${c.btThai}\n\n`;
                    if (c.btEnglish) md += `‚Ü© TH‚ÜíEN: ${c.btEnglish}\n\n`;
                }
            }

            // Download
            const blob = new Blob([md], { type: 'text/markdown' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = s.name + '-transcript.md';
            a.click();

            toast('ok', 'Exported ' + done.length + ' chunks');
        }

        // ‚îÄ‚îÄ‚îÄ Utilities ‚îÄ‚îÄ‚îÄ
        function fmtTime(s) {
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return m + ':' + sec.toString().padStart(2, '0');
        }

        function fmtDur(s) {
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const sec = Math.floor(s % 60);
            if (h > 0) return `${h}h ${m}m ${sec}s`;
            return `${m}m ${sec}s`;
        }

        function fmtSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / 1048576).toFixed(1) + ' MB';
        }

        function esc(t) {
            if (!t) return '';
            const d = document.createElement('div');
            d.textContent = t;
            return d.innerHTML;
        }

        function sleep(ms) {
            return new Promise(r => setTimeout(r, ms));
        }

        function toast(type, msg) {
            const el = document.createElement('div');
            el.className = 'toast ' + type;
            el.textContent = msg;
            document.getElementById('toastWrap').appendChild(el);
            setTimeout(() => {
                el.style.opacity = '0';
                setTimeout(() => el.remove(), 300);
            }, 4000);
        }

        // ‚îÄ‚îÄ‚îÄ Start ‚îÄ‚îÄ‚îÄ
        init();
    </script>
</body>
</html>
