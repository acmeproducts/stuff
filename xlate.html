<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thai Transcriber</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;500;600&family=JetBrains+Mono:wght@400&display=swap');
        :root {
            --bg: #0d0d12; --surface: #14141b; --elevated: #1c1c25; --border: #2a2a38;
            --text: #e4e4eb; --text-dim: #8888a0; --text-muted: #55556a;
            --gold: #d4a853; --gold-dim: #a08040; --thai: #3a9fc4; --english: #9a7bc4;
            --success: #4a9d6a; --warning: #c4883a; --error: #c45a5a;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Sarabun', sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; line-height: 1.6; }
        .container { max-width: 1400px; margin: 0 auto; padding: 1rem; }
        header { display: flex; align-items: center; justify-content: space-between; padding: 0.75rem 0; border-bottom: 1px solid var(--border); margin-bottom: 1rem; }
        .logo { font-size: 1rem; font-weight: 300; letter-spacing: 0.15em; background: linear-gradient(135deg, var(--gold), var(--gold-dim)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .header-controls { display: flex; align-items: center; gap: 0.75rem; }
        .status-pill { display: flex; align-items: center; gap: 0.4rem; padding: 0.3rem 0.6rem; background: var(--surface); border: 1px solid var(--border); border-radius: 12px; font-size: 0.65rem; }
        .status-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--text-muted); }
        .status-dot.ready { background: var(--success); }
        .status-dot.working { background: var(--warning); animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        .main-grid { display: grid; grid-template-columns: 320px 1fr; gap: 1rem; height: calc(100vh - 90px); }
        @media (max-width: 900px) { .main-grid { grid-template-columns: 1fr; height: auto; } }
        .card { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; display: flex; flex-direction: column; overflow: hidden; }
        .card-header { padding: 0.6rem 0.875rem; border-bottom: 1px solid var(--border); font-size: 0.6rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.12em; color: var(--text-dim); display: flex; align-items: center; justify-content: space-between; }
        .card-body { padding: 0.875rem; flex: 1; overflow-y: auto; }
        .btn { padding: 0.45rem 0.875rem; border: none; border-radius: 4px; font-family: inherit; font-size: 0.75rem; font-weight: 500; cursor: pointer; transition: all 0.15s; display: inline-flex; align-items: center; gap: 0.25rem; }
        .btn-primary { background: linear-gradient(135deg, var(--gold), var(--gold-dim)); color: var(--bg); }
        .btn-primary:hover:not(:disabled) { filter: brightness(1.1); }
        .btn-secondary { background: var(--elevated); color: var(--text); border: 1px solid var(--border); }
        .btn-ghost { background: none; color: var(--text-dim); padding: 0.25rem 0.4rem; }
        .btn-ghost:hover { color: var(--text); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-block { width: 100%; justify-content: center; }
        .btn-sm { padding: 0.3rem 0.5rem; font-size: 0.7rem; }
        .upload-area { border: 2px dashed var(--border); border-radius: 6px; padding: 1.25rem 0.75rem; text-align: center; cursor: pointer; }
        .upload-area:hover { border-color: var(--gold-dim); }
        .upload-area.has-file { border-style: solid; border-color: var(--success); }
        .upload-icon { font-size: 1.25rem; }
        .upload-text { color: var(--text-dim); font-size: 0.75rem; }
        .file-info { display: none; margin-top: 0.6rem; padding: 0.5rem; background: var(--elevated); border-radius: 4px; font-size: 0.75rem; }
        .file-info.visible { display: block; }
        .file-name { font-weight: 500; color: var(--gold); word-break: break-all; }
        .file-meta { font-size: 0.65rem; color: var(--text-muted); font-family: 'JetBrains Mono', monospace; }
        .workers-panel { margin-top: 0.75rem; padding: 0.6rem; background: var(--elevated); border-radius: 6px; }
        .workers-header { display: flex; justify-content: space-between; font-size: 0.65rem; color: var(--text-dim); margin-bottom: 0.5rem; }
        .worker-cards { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.4rem; }
        .worker-card { padding: 0.4rem 0.5rem; background: var(--bg); border-radius: 4px; border-left: 3px solid var(--border); font-size: 0.65rem; }
        .worker-card.loading { border-color: var(--warning); }
        .worker-card.ready { border-color: var(--success); }
        .worker-card.working { border-color: var(--gold); }
        .worker-card.error { border-color: var(--error); }
        .worker-card-header { display: flex; justify-content: space-between; }
        .worker-id { font-weight: 600; color: var(--text-dim); }
        .worker-status { font-size: 0.6rem; color: var(--text-muted); }
        .worker-card.working .worker-status { color: var(--gold); }
        .worker-card.ready .worker-status { color: var(--success); }
        .worker-task { font-family: 'JetBrains Mono', monospace; font-size: 0.6rem; color: var(--text-muted); margin-top: 0.15rem; }
        .worker-card.working .worker-task { color: var(--gold); }
        .progress-section { margin-top: 0.75rem; padding: 0.6rem; background: var(--elevated); border-radius: 6px; display: none; }
        .progress-section.visible { display: block; }
        .progress-header { display: flex; justify-content: space-between; font-size: 0.7rem; margin-bottom: 0.4rem; }
        .progress-bar { height: 4px; background: var(--border); border-radius: 2px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--gold); width: 0%; transition: width 0.2s; }
        .progress-stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.3rem; margin-top: 0.5rem; font-size: 0.6rem; }
        .stat-item { display: flex; justify-content: space-between; color: var(--text-muted); }
        .stat-value { color: var(--text-dim); font-family: 'JetBrains Mono', monospace; }
        .chunk-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(24px, 1fr)); gap: 2px; margin-top: 0.5rem; max-height: 120px; overflow-y: auto; }
        .chunk-cell { aspect-ratio: 1; background: var(--border); border-radius: 2px; font-size: 0.45rem; display: flex; align-items: center; justify-content: center; color: var(--text-muted); }
        .chunk-cell.pending { background: var(--warning); color: var(--bg); }
        .chunk-cell.done { background: var(--success); color: white; }
        .chunk-cell.filtered { background: var(--text-muted); }
        .chunk-cell.error { background: var(--error); color: white; }
        .tabs { display: flex; border-bottom: 1px solid var(--border); }
        .tab { padding: 0.5rem 0.875rem; background: none; border: none; color: var(--text-muted); font-family: inherit; font-size: 0.7rem; cursor: pointer; position: relative; }
        .tab.active { color: var(--gold); }
        .tab.active::after { content: ''; position: absolute; bottom: -1px; left: 0; right: 0; height: 2px; background: var(--gold); }
        .tab-badge { background: var(--elevated); padding: 0.1rem 0.35rem; border-radius: 6px; font-size: 0.6rem; margin-left: 0.25rem; }
        .tab-content { display: none; height: calc(100% - 33px); overflow-y: auto; }
        .tab-content.active { display: block; }
        .chunk-list { padding: 0.5rem; }
        .chunk-item { padding: 0.6rem; margin-bottom: 0.4rem; background: var(--elevated); border-radius: 5px; border-left: 3px solid var(--border); }
        .chunk-item.th { border-color: var(--thai); }
        .chunk-item.en { border-color: var(--english); }
        .chunk-item.filtered { opacity: 0.5; }
        .chunk-header { display: flex; align-items: center; gap: 0.4rem; margin-bottom: 0.3rem; flex-wrap: wrap; }
        .chunk-id { font-family: 'JetBrains Mono', monospace; font-size: 0.6rem; color: var(--text-muted); background: var(--bg); padding: 0.1rem 0.3rem; border-radius: 2px; }
        .chunk-time { font-family: 'JetBrains Mono', monospace; font-size: 0.6rem; color: var(--text-muted); }
        .chunk-lang { font-size: 0.55rem; font-weight: 600; padding: 0.1rem 0.25rem; border-radius: 2px; }
        .chunk-item.th .chunk-lang { background: rgba(58, 159, 196, 0.2); color: var(--thai); }
        .chunk-item.en .chunk-lang { background: rgba(154, 123, 196, 0.2); color: var(--english); }
        .chunk-original { font-size: 0.85rem; line-height: 1.5; }
        .chunk-translation { font-size: 0.8rem; color: var(--gold); font-style: italic; padding-left: 0.6rem; border-left: 2px solid var(--gold-dim); margin-top: 0.3rem; }
        .chunk-warning { font-size: 0.65rem; color: var(--warning); margin-top: 0.2rem; }
        .empty-state { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-muted); padding: 2rem; }
        .empty-icon { font-size: 2rem; margin-bottom: 0.4rem; opacity: 0.4; }
        .overlay { position: fixed; inset: 0; background: rgba(13, 13, 18, 0.95); z-index: 100; display: flex; align-items: center; justify-content: center; padding: 1rem; }
        .overlay.hidden { display: none; }
        .setup-box { background: var(--surface); border: 1px solid var(--border); border-radius: 10px; width: 100%; max-width: 450px; }
        .setup-title { font-size: 1rem; text-align: center; padding: 1rem; border-bottom: 1px solid var(--border); color: var(--gold); }
        .setup-content { padding: 1rem; }
        .setup-step { display: none; }
        .setup-step.active { display: block; }
        .setup-label { font-size: 0.8rem; color: var(--text-dim); margin-bottom: 0.6rem; }
        .option { padding: 0.6rem 0.75rem; background: var(--elevated); border: 2px solid var(--border); border-radius: 5px; margin-bottom: 0.35rem; cursor: pointer; }
        .option:hover { border-color: var(--text-muted); }
        .option.selected { border-color: var(--gold); }
        .option-title { font-weight: 500; font-size: 0.85rem; }
        .option-desc { font-size: 0.7rem; color: var(--text-muted); }
        .slider-container { margin: 1rem 0; }
        .slider-label { display: flex; justify-content: space-between; font-size: 0.75rem; margin-bottom: 0.5rem; }
        .slider-value { font-family: 'JetBrains Mono', monospace; color: var(--gold); font-weight: 600; }
        .slider { width: 100%; height: 6px; border-radius: 3px; background: var(--border); -webkit-appearance: none; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: var(--gold); cursor: pointer; }
        .worker-estimate { font-size: 0.7rem; color: var(--text-muted); margin-top: 0.5rem; padding: 0.5rem; background: var(--bg); border-radius: 4px; }
        .setup-workers-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.3rem; margin-top: 0.75rem; }
        .setup-worker-cell { padding: 0.4rem; background: var(--bg); border-radius: 4px; text-align: center; font-size: 0.7rem; }
        .setup-worker-cell .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--border); margin: 0 auto 0.2rem; }
        .setup-worker-cell.loading .dot { background: var(--warning); animation: pulse 1s infinite; }
        .setup-worker-cell.ready .dot { background: var(--success); }
        .setup-worker-cell.error .dot { background: var(--error); }
        .setup-footer { padding: 0.75rem 1rem; border-top: 1px solid var(--border); display: flex; justify-content: space-between; }
        .resume-banner { display: none; padding: 0.6rem; background: rgba(212, 168, 83, 0.1); border: 1px solid var(--gold-dim); border-radius: 5px; margin-bottom: 0.6rem; }
        .resume-banner.visible { display: block; }
        .resume-title { font-size: 0.75rem; font-weight: 500; color: var(--gold); }
        .resume-info { font-size: 0.65rem; color: var(--text-dim); margin: 0.25rem 0; }
        .resume-actions { display: flex; gap: 0.3rem; margin-top: 0.4rem; }
        .toast-area { position: fixed; bottom: 1rem; right: 1rem; z-index: 200; }
        .toast { padding: 0.5rem 0.875rem; background: var(--elevated); border: 1px solid var(--border); border-radius: 4px; margin-top: 0.3rem; font-size: 0.75rem; }
        .toast.success { border-color: var(--success); }
        .toast.error { border-color: var(--error); }
        .hidden { display: none !important; }
        input[type="file"] { display: none; }
    </style>
</head>
<body>
    <div class="overlay" id="setupOverlay">
        <div class="setup-box">
            <div class="setup-title">Thai Transcriber Setup</div>
            <div class="setup-content">
                <div class="setup-step active" data-step="1">
                    <div class="setup-label">Transcription Model:</div>
                    <div class="option" data-value="tiny"><div class="option-title">üöÄ Tiny (~40 MB/worker)</div><div class="option-desc">Fast, less accurate</div></div>
                    <div class="option selected" data-value="base"><div class="option-title">‚öñÔ∏è Base (~75 MB/worker)</div><div class="option-desc">Recommended</div></div>
                    <div class="option" data-value="small"><div class="option-title">üéØ Small (~250 MB/worker)</div><div class="option-desc">Most accurate</div></div>
                </div>
                <div class="setup-step" data-step="2">
                    <div class="setup-label">Translation:</div>
                    <div class="option selected" data-value="yes"><div class="option-title">üîÑ Thai ‚Üí English (+50 MB/worker)</div></div>
                    <div class="option" data-value="no"><div class="option-title">üìù Transcription only</div></div>
                </div>
                <div class="setup-step" data-step="3">
                    <div class="setup-label">Parallel Workers (1-8):</div>
                    <div class="slider-container">
                        <div class="slider-label"><span>Workers</span><span class="slider-value" id="workerCountDisplay">4</span></div>
                        <input type="range" class="slider" id="workerCountSlider" min="1" max="8" value="4">
                        <div class="worker-estimate" id="workerEstimate">~500 MB RAM ‚Ä¢ 4√ó faster</div>
                    </div>
                    <div style="font-size:0.7rem;color:var(--text-muted);">Each worker loads its own model. More = faster but more RAM.</div>
                </div>
                <div class="setup-step" data-step="4">
                    <div class="setup-label">Initializing workers...</div>
                    <div class="progress-bar"><div class="progress-fill" id="setupProgress"></div></div>
                    <div class="setup-workers-grid" id="setupWorkersGrid"></div>
                </div>
                <div class="setup-step" data-step="5">
                    <div style="text-align:center;padding:1rem 0;">
                        <div style="font-size:2rem;">‚úÖ</div>
                        <div style="color:var(--success);">Ready!</div>
                        <div style="color:var(--text-dim);font-size:0.75rem;" id="setupSummary"></div>
                    </div>
                </div>
            </div>
            <div class="setup-footer">
                <button class="btn btn-secondary hidden" id="setupBack">‚Üê Back</button>
                <button class="btn btn-primary" id="setupNext">Next ‚Üí</button>
            </div>
        </div>
    </div>

    <div class="container">
        <header>
            <div class="logo">THAI TRANSCRIBER</div>
            <div class="header-controls">
                <div class="status-pill"><span class="status-dot" id="statusDot"></span><span id="statusText">Loading</span></div>
                <button class="btn btn-ghost" id="restartBtn" title="Restart">üîÑ</button>
                <button class="btn btn-ghost" id="settingsBtn" title="Settings">‚öôÔ∏è</button>
            </div>
        </header>
        <div class="main-grid">
            <div class="card">
                <div class="card-header">Input</div>
                <div class="card-body">
                    <div class="resume-banner" id="resumeBanner">
                        <div class="resume-title">‚è∏Ô∏è Incomplete Job</div>
                        <div class="resume-info" id="resumeInfo"></div>
                        <div class="resume-actions">
                            <button class="btn btn-primary btn-sm" id="resumeBtn">‚ñ∂Ô∏è Resume</button>
                            <button class="btn btn-secondary btn-sm" id="discardBtn">üóëÔ∏è Discard</button>
                        </div>
                    </div>
                    <div class="upload-area" id="uploadArea">
                        <div class="upload-icon">üéµ</div>
                        <div class="upload-text">Drop audio file</div>
                    </div>
                    <input type="file" id="fileInput" accept="audio/*,.m4a">
                    <div class="file-info" id="fileInfo">
                        <div class="file-name" id="fileName"></div>
                        <div class="file-meta" id="fileMeta"></div>
                    </div>
                    <div class="workers-panel" id="workersPanel">
                        <div class="workers-header"><span>Workers</span><span id="workersReady">0/0</span></div>
                        <div class="worker-cards" id="workerCards"></div>
                    </div>
                    <div class="progress-section" id="progressSection">
                        <div class="progress-header"><span id="progressLabel">Processing</span><span id="progressPct">0%</span></div>
                        <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
                        <div class="progress-stats">
                            <div class="stat-item"><span>Done</span><span class="stat-value" id="statChunks">0/0</span></div>
                            <div class="stat-item"><span>Translated</span><span class="stat-value" id="statTranslated">0</span></div>
                            <div class="stat-item"><span>Filtered</span><span class="stat-value" id="statFiltered">0</span></div>
                            <div class="stat-item"><span>Errors</span><span class="stat-value" id="statErrors">0</span></div>
                        </div>
                        <div class="chunk-grid" id="chunkGrid"></div>
                    </div>
                    <div style="margin-top:0.75rem;">
                        <button class="btn btn-primary btn-block" id="startBtn" disabled>‚ñ∂Ô∏è Start</button>
                        <button class="btn btn-secondary btn-block hidden" id="stopBtn">‚èπ Stop</button>
                    </div>
                </div>
            </div>
            <div class="card">
                <div class="tabs">
                    <button class="tab active" data-tab="chunks">Chunks <span class="tab-badge" id="chunkCount">0</span></button>
                    <button class="tab" data-tab="export">Export</button>
                </div>
                <div class="tab-content active" id="tab-chunks">
                    <div class="chunk-list" id="chunkList">
                        <div class="empty-state"><div class="empty-icon">üéß</div><div>Load audio to begin</div></div>
                    </div>
                </div>
                <div class="tab-content" id="tab-export">
                    <div style="padding:0.875rem;">
                        <div style="font-size:0.75rem;color:var(--text-dim);margin-bottom:0.4rem;">Export Format:</div>
                        <div style="display:flex;gap:0.4rem;flex-wrap:wrap;">
                            <button class="btn btn-secondary btn-sm" id="exportMd">üìÑ Markdown</button>
                            <button class="btn btn-secondary btn-sm" id="exportJson">üìã JSON</button>
                            <button class="btn btn-secondary btn-sm" id="exportTxt">üìù Text</button>
                            <button class="btn btn-secondary btn-sm" id="copyAll">üìã Copy All</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="toast-area" id="toastArea"></div>

    <script id="workerCode" type="text/js-worker">
        let pipeline = null;
        let translator = null;
        let workerId = null;
        
        self.onmessage = async function(e) {
            const { type, data } = e.data;
            
            if (type === 'init') {
                workerId = data.workerId;
                try {
                    const { pipeline: pipelineFn } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2');
                    self.postMessage({ type: 'status', workerId, status: 'loading_whisper' });
                    pipeline = await pipelineFn('automatic-speech-recognition', data.whisperModel, {
                        quantized: true,
                        progress_callback: (p) => {
                            if (p.status === 'progress') self.postMessage({ type: 'model_progress', workerId, progress: p.progress });
                        }
                    });
                    if (data.enableTranslation) {
                        self.postMessage({ type: 'status', workerId, status: 'loading_translator' });
                        translator = await pipelineFn('translation', 'Xenova/opus-mt-th-en', { quantized: true });
                    }
                    self.postMessage({ type: 'ready', workerId });
                } catch (err) {
                    self.postMessage({ type: 'error', workerId, error: err.message });
                }
            }
            
            if (type === 'transcribe') {
                const { chunkIndex, audioData, startTime, endTime } = data;
                try {
                    self.postMessage({ type: 'chunk_start', workerId, chunkIndex });
                    const audio = new Float32Array(audioData);
                    const result = await pipeline(audio, { language: 'th', task: 'transcribe', return_timestamps: false });
                    let text = result.text?.trim() || '';
                    let translation = null;
                    let filtered = false;
                    let filterReason = null;
                    
                    if (text) {
                        const rep = detectRepetition(text);
                        if (rep.isRepetitive) { filtered = true; filterReason = rep.reason; text = rep.cleaned || ''; }
                    }
                    
                    const lang = detectLanguage(text);
                    if (text && lang === 'th' && translator && !filtered) {
                        try {
                            const tr = await translator(text, { max_length: 512 });
                            translation = tr[0]?.translation_text || null;
                        } catch (e) {}
                    }
                    
                    self.postMessage({ type: 'chunk_done', workerId, chunkIndex, result: { chunkIndex, startTime, endTime, text, language: lang, translation, filtered, filterReason } });
                } catch (err) {
                    self.postMessage({ type: 'chunk_error', workerId, chunkIndex, error: err.message });
                }
            }
        };
        
        function detectLanguage(text) {
            if (!text) return 'unknown';
            const thai = (text.match(/[\u0E00-\u0E7F]/g) || []).length;
            const total = text.replace(/\s/g, '').length;
            return total > 0 && thai / total > 0.3 ? 'th' : 'en';
        }
        
        function detectRepetition(text) {
            const words = text.split(/\s+/);
            if (words.length < 5) return { isRepetitive: false };
            if (/(.{2,})\1{5,}/.test(text)) return { isRepetitive: true, reason: 'Loop detected', cleaned: null };
            const counts = {};
            for (const w of words) counts[w] = (counts[w] || 0) + 1;
            const max = Math.max(...Object.values(counts));
            if (max > words.length * 0.5 && words.length > 8) return { isRepetitive: true, reason: 'Repetition', cleaned: null };
            return { isRepetitive: false };
        }
    </script>

    <script type="module">
        const DB_NAME = 'ThaiTranscriberV6';
        const DB_VERSION = 1;
        
        class Storage {
            constructor() { this.db = null; }
            async init() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open(DB_NAME, DB_VERSION);
                    req.onerror = () => reject(req.error);
                    req.onsuccess = () => { this.db = req.result; resolve(); };
                    req.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        ['config', 'audio', 'chunks', 'results', 'progress'].forEach(s => {
                            if (!db.objectStoreNames.contains(s)) db.createObjectStore(s);
                        });
                    };
                });
            }
            async get(store, key) {
                if (!this.db) await this.init();
                return new Promise((res, rej) => { const r = this.db.transaction(store, 'readonly').objectStore(store).get(key); r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error); });
            }
            async set(store, key, value) {
                if (!this.db) await this.init();
                return new Promise((res, rej) => { const r = this.db.transaction(store, 'readwrite').objectStore(store).put(value, key); r.onsuccess = () => res(); r.onerror = () => rej(r.error); });
            }
            async getAll(store) {
                if (!this.db) await this.init();
                return new Promise((res, rej) => { const r = this.db.transaction(store, 'readonly').objectStore(store).getAll(); r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error); });
            }
            async clear(store) {
                if (!this.db) await this.init();
                return new Promise((res, rej) => { const r = this.db.transaction(store, 'readwrite').objectStore(store).clear(); r.onsuccess = () => res(); r.onerror = () => rej(r.error); });
            }
            async delete(store, key) {
                if (!this.db) await this.init();
                return new Promise((res, rej) => { const r = this.db.transaction(store, 'readwrite').objectStore(store).delete(key); r.onsuccess = () => res(); r.onerror = () => rej(r.error); });
            }
        }
        
        const storage = new Storage();
        const state = {
            config: { whisperModel: 'base', enableTranslation: true, workerCount: 4, setupComplete: false },
            setupStep: 1, audioMeta: null, totalChunks: 0, results: new Map(),
            pendingChunks: new Set(), completedChunks: new Set(), errorChunks: new Set(),
            filteredCount: 0, isProcessing: false, workers: [], workerStates: new Map(),
            readyWorkers: new Set(), chunkQueue: []
        };
        
        function createWorker(id) {
            const code = document.getElementById('workerCode').textContent;
            const blob = new Blob([code], { type: 'application/javascript' });
            const worker = new Worker(URL.createObjectURL(blob), { type: 'module' });
            worker.onmessage = (e) => handleWorkerMessage(id, e.data);
            worker.onerror = (e) => { state.workerStates.set(id, 'error'); updateWorkerUI(id, 'error', 'Error'); };
            return worker;
        }
        
        function handleWorkerMessage(workerId, msg) {
            const { type } = msg;
            if (type === 'status') {
                updateWorkerUI(workerId, 'loading', msg.status === 'loading_whisper' ? 'Whisper...' : 'Translator...');
                if (!state.config.setupComplete) updateSetupWorker(workerId, 'loading');
            } else if (type === 'ready') {
                state.readyWorkers.add(workerId);
                state.workerStates.set(workerId, 'ready');
                updateWorkerUI(workerId, 'ready', 'Ready');
                updateWorkersHeader();
                if (!state.config.setupComplete) { updateSetupWorker(workerId, 'ready'); checkAllWorkersReady(); }
                if (state.isProcessing) assignChunkToWorker(workerId);
            } else if (type === 'error') {
                state.workerStates.set(workerId, 'error');
                updateWorkerUI(workerId, 'error', msg.error?.substring(0, 15) || 'Error');
                if (!state.config.setupComplete) updateSetupWorker(workerId, 'error');
            } else if (type === 'chunk_start') {
                state.pendingChunks.add(msg.chunkIndex);
                state.workerStates.set(workerId, 'working');
                updateWorkerUI(workerId, 'working', `#${msg.chunkIndex + 1}`);
                updateChunkCell(msg.chunkIndex, 'pending');
                updateStats();
            } else if (type === 'chunk_done') {
                handleChunkDone(workerId, msg.chunkIndex, msg.result);
            } else if (type === 'chunk_error') {
                handleChunkError(workerId, msg.chunkIndex, msg.error);
            }
        }
        
        async function handleChunkDone(workerId, chunkIndex, result) {
            state.pendingChunks.delete(chunkIndex);
            state.completedChunks.add(chunkIndex);
            state.results.set(chunkIndex, result);
            if (result.filtered) state.filteredCount++;
            
            await storage.set('results', `chunk_${chunkIndex}`, result);
            await storage.set('progress', 'current', { completed: Array.from(state.completedChunks), total: state.totalChunks });
            
            updateChunkCell(chunkIndex, result.filtered ? 'filtered' : 'done');
            updateChunkList(result);
            updateStats();
            
            state.workerStates.set(workerId, 'ready');
            updateWorkerUI(workerId, 'ready', 'Ready');
            assignChunkToWorker(workerId);
            checkComplete();
        }
        
        function handleChunkError(workerId, chunkIndex, error) {
            state.pendingChunks.delete(chunkIndex);
            state.errorChunks.add(chunkIndex);
            updateChunkCell(chunkIndex, 'error');
            updateStats();
            state.workerStates.set(workerId, 'ready');
            updateWorkerUI(workerId, 'ready', 'Ready');
            assignChunkToWorker(workerId);
            checkComplete();
        }
        
        async function assignChunkToWorker(workerId) {
            if (!state.isProcessing || state.chunkQueue.length === 0) return;
            const chunkIndex = state.chunkQueue.shift();
            const chunk = await storage.get('chunks', `chunk_${chunkIndex}`);
            if (chunk) {
                state.workers[workerId].postMessage({
                    type: 'transcribe',
                    data: { chunkIndex, audioData: chunk.data, startTime: chunk.startTime, endTime: chunk.endTime }
                });
            }
        }
        
        function checkComplete() {
            if (state.completedChunks.size + state.errorChunks.size >= state.totalChunks && state.isProcessing) {
                state.isProcessing = false;
                document.getElementById('startBtn').classList.remove('hidden');
                document.getElementById('stopBtn').classList.add('hidden');
                toast('success', 'Complete!');
                updateStatus('ready', `${state.workers.length} workers`);
            }
        }
        
        async function initWorkers() {
            state.workers.forEach(w => w.terminate());
            state.workers = [];
            state.workerStates.clear();
            state.readyWorkers.clear();
            
            const count = state.config.workerCount;
            const container = document.getElementById('workerCards');
            container.innerHTML = '';
            
            for (let i = 0; i < count; i++) {
                const card = document.createElement('div');
                card.className = 'worker-card';
                card.id = `worker-card-${i}`;
                card.innerHTML = `<div class="worker-card-header"><span class="worker-id">W${i + 1}</span><span class="worker-status">Init</span></div><div class="worker-task">‚Äî</div>`;
                container.appendChild(card);
                state.workerStates.set(i, 'idle');
            }
            updateWorkersHeader();
            
            for (let i = 0; i < count; i++) {
                const worker = createWorker(i);
                state.workers.push(worker);
                updateWorkerUI(i, 'loading', 'Init...');
                worker.postMessage({
                    type: 'init',
                    data: { workerId: i, whisperModel: `Xenova/whisper-${state.config.whisperModel}`, enableTranslation: state.config.enableTranslation }
                });
            }
        }
        
        function updateWorkerUI(id, status, task) {
            const card = document.getElementById(`worker-card-${id}`);
            if (!card) return;
            card.className = `worker-card ${status}`;
            card.querySelector('.worker-status').textContent = status === 'ready' ? 'Ready' : status === 'working' ? 'Working' : status === 'loading' ? 'Loading' : status === 'error' ? 'Error' : 'Idle';
            card.querySelector('.worker-task').textContent = task || '‚Äî';
        }
        
        function updateWorkersHeader() {
            document.getElementById('workersReady').textContent = `${state.readyWorkers.size}/${state.workers.length}`;
            if (state.readyWorkers.size === state.workers.length && state.workers.length > 0) updateStatus('ready', `${state.workers.length} workers`);
        }
        
        async function handleFile(file) {
            state.audioMeta = { name: file.name, size: file.size };
            const arrayBuffer = await file.arrayBuffer();
            await storage.set('audio', 'current', { name: file.name, size: file.size, data: arrayBuffer });
            
            updateStatus('working', 'Decoding...');
            const ctx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
            const audioBuffer = await ctx.decodeAudioData(arrayBuffer.slice(0));
            
            const length = audioBuffer.length;
            const mono = new Float32Array(length);
            if (audioBuffer.numberOfChannels === 1) { audioBuffer.copyFromChannel(mono, 0); }
            else {
                const left = new Float32Array(length), right = new Float32Array(length);
                audioBuffer.copyFromChannel(left, 0); audioBuffer.copyFromChannel(right, 1);
                for (let i = 0; i < length; i++) mono[i] = (left[i] + right[i]) / 2;
            }
            
            let resampled = mono;
            if (audioBuffer.sampleRate !== 16000) {
                const ratio = audioBuffer.sampleRate / 16000;
                const newLen = Math.round(mono.length / ratio);
                resampled = new Float32Array(newLen);
                for (let i = 0; i < newLen; i++) {
                    const idx = i * ratio, lo = Math.floor(idx);
                    resampled[i] = mono[lo] * (1 - (idx - lo)) + mono[Math.min(lo + 1, mono.length - 1)] * (idx - lo);
                }
            }
            
            await storage.clear('chunks');
            await storage.clear('results');
            
            const chunkLen = 30 * 16000;
            state.totalChunks = Math.ceil(resampled.length / chunkLen);
            
            for (let i = 0; i < state.totalChunks; i++) {
                const start = i * chunkLen, end = Math.min(start + chunkLen, resampled.length);
                await storage.set('chunks', `chunk_${i}`, { index: i, data: Array.from(resampled.slice(start, end)), startTime: start / 16000, endTime: end / 16000 });
            }
            
            await storage.set('progress', 'meta', { totalChunks: state.totalChunks, duration: resampled.length / 16000, fileName: file.name });
            
            state.results.clear(); state.pendingChunks.clear(); state.completedChunks.clear(); state.errorChunks.clear(); state.filteredCount = 0; state.chunkQueue = [];
            
            document.getElementById('uploadArea').classList.add('has-file');
            document.getElementById('fileInfo').classList.add('visible');
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileMeta').textContent = `${formatBytes(file.size)} ‚Ä¢ ${formatTime(resampled.length / 16000)} ‚Ä¢ ${state.totalChunks} chunks`;
            document.getElementById('startBtn').disabled = state.readyWorkers.size === 0;
            document.getElementById('progressSection').classList.add('visible');
            
            initChunkGrid();
            clearChunkList();
            updateStats();
            updateStatus('ready', `${state.workers.length} workers`);
            toast('success', 'Audio ready');
        }
        
        async function startProcessing(resumeFrom = new Set()) {
            if (state.readyWorkers.size === 0) { toast('error', 'No workers'); return; }
            state.isProcessing = true;
            state.completedChunks = resumeFrom;
            document.getElementById('startBtn').classList.add('hidden');
            document.getElementById('stopBtn').classList.remove('hidden');
            document.getElementById('resumeBanner').classList.remove('visible');
            
            state.chunkQueue = [];
            for (let i = 0; i < state.totalChunks; i++) {
                if (!state.completedChunks.has(i)) state.chunkQueue.push(i);
            }
            updateStatus('working', 'Processing...');
            for (const wid of state.readyWorkers) assignChunkToWorker(wid);
        }
        
        function stopProcessing() {
            state.isProcessing = false; state.chunkQueue = [];
            document.getElementById('startBtn').classList.remove('hidden');
            document.getElementById('stopBtn').classList.add('hidden');
            updateStatus('ready', `${state.workers.length} workers`);
            toast('success', 'Paused');
        }
        
        async function discardProgress() {
            await storage.clear('chunks'); await storage.clear('results');
            await storage.delete('progress', 'current'); await storage.delete('progress', 'meta');
            state.results.clear(); state.pendingChunks.clear(); state.completedChunks.clear(); state.errorChunks.clear();
            state.totalChunks = 0; state.chunkQueue = [];
            document.getElementById('resumeBanner').classList.remove('visible');
            document.getElementById('progressSection').classList.remove('visible');
            clearChunkList();
            toast('success', 'Discarded');
        }
        
        function updateStatus(type, text) {
            document.getElementById('statusDot').className = `status-dot ${type}`;
            document.getElementById('statusText').textContent = text;
        }
        
        function updateStats() {
            const done = state.completedChunks.size, total = state.totalChunks;
            const pct = total > 0 ? Math.round((done / total) * 100) : 0;
            document.getElementById('progressFill').style.width = `${pct}%`;
            document.getElementById('progressPct').textContent = `${pct}%`;
            document.getElementById('statChunks').textContent = `${done}/${total}`;
            document.getElementById('statTranslated').textContent = Array.from(state.results.values()).filter(r => r.translation).length;
            document.getElementById('statFiltered').textContent = state.filteredCount;
            document.getElementById('statErrors').textContent = state.errorChunks.size;
            document.getElementById('chunkCount').textContent = done;
        }
        
        function initChunkGrid() {
            const grid = document.getElementById('chunkGrid');
            grid.innerHTML = '';
            for (let i = 0; i < state.totalChunks; i++) {
                const cell = document.createElement('div');
                cell.className = 'chunk-cell'; cell.id = `cell-${i}`; cell.textContent = i + 1;
                grid.appendChild(cell);
            }
        }
        
        function updateChunkCell(index, status) {
            const cell = document.getElementById(`cell-${index}`);
            if (cell) cell.className = `chunk-cell ${status}`;
        }
        
        function clearChunkList() {
            document.getElementById('chunkList').innerHTML = '<div class="empty-state"><div class="empty-icon">üéß</div><div>Load audio</div></div>';
        }
        
        function updateChunkList(result) {
            const list = document.getElementById('chunkList');
            const empty = list.querySelector('.empty-state'); if (empty) empty.remove();
            let item = document.getElementById(`chunk-${result.chunkIndex}`);
            if (!item) {
                item = document.createElement('div'); item.id = `chunk-${result.chunkIndex}`;
                const items = list.querySelectorAll('.chunk-item');
                let inserted = false;
                for (const ex of items) { if (result.chunkIndex < parseInt(ex.id.replace('chunk-', ''))) { list.insertBefore(item, ex); inserted = true; break; } }
                if (!inserted) list.appendChild(item);
            }
            const lang = result.language === 'th' ? 'th' : 'en';
            item.className = `chunk-item ${lang} ${result.filtered ? 'filtered' : ''}`;
            item.innerHTML = `<div class="chunk-header"><span class="chunk-id">${String(result.chunkIndex + 1).padStart(3, '0')}</span><span class="chunk-time">${formatTime(result.startTime)}‚Üí${formatTime(result.endTime)}</span><span class="chunk-lang">${result.language === 'th' ? 'üáπüá≠' : 'üá∫üá∏'}</span></div>${result.text ? `<div class="chunk-original">${escapeHtml(result.text)}</div>` : '<div class="chunk-original" style="color:var(--text-muted);">(empty)</div>'}${result.translation ? `<div class="chunk-translation">${escapeHtml(result.translation)}</div>` : ''}${result.filtered ? `<div class="chunk-warning">‚ö†Ô∏è ${result.filterReason}</div>` : ''}`;
        }
        
        function showSetup() { document.getElementById('setupOverlay').classList.remove('hidden'); state.setupStep = 1; updateSetupUI(); }
        function hideSetup() { document.getElementById('setupOverlay').classList.add('hidden'); }
        
        function updateSetupUI() {
            document.querySelectorAll('.setup-step').forEach(el => el.classList.toggle('active', el.dataset.step == state.setupStep));
            document.getElementById('setupBack').classList.toggle('hidden', state.setupStep <= 1);
            const next = document.getElementById('setupNext');
            next.textContent = state.setupStep === 4 ? 'Loading...' : state.setupStep === 5 ? 'Done ‚Üí' : 'Next ‚Üí';
            next.disabled = state.setupStep === 4;
        }
        
        function updateWorkerEstimate() {
            const count = parseInt(document.getElementById('workerCountSlider').value);
            document.getElementById('workerCountDisplay').textContent = count;
            const sizes = { tiny: 40, base: 75, small: 250 };
            const mb = (sizes[state.config.whisperModel] || 75) + (state.config.enableTranslation ? 50 : 0);
            document.getElementById('workerEstimate').textContent = `~${mb * count} MB RAM ‚Ä¢ ${count}√ó parallel`;
        }
        
        function initSetupWorkersGrid() {
            const grid = document.getElementById('setupWorkersGrid');
            grid.innerHTML = '';
            for (let i = 0; i < state.config.workerCount; i++) {
                const cell = document.createElement('div');
                cell.className = 'setup-worker-cell loading'; cell.id = `setup-w-${i}`;
                cell.innerHTML = `<div class="dot"></div><div>W${i + 1}</div>`;
                grid.appendChild(cell);
            }
        }
        
        function updateSetupWorker(id, status) {
            const cell = document.getElementById(`setup-w-${id}`);
            if (cell) cell.className = `setup-worker-cell ${status}`;
            const ready = state.readyWorkers.size, total = state.config.workerCount;
            document.getElementById('setupProgress').style.width = `${(ready / total) * 100}%`;
        }
        
        function checkAllWorkersReady() {
            if (state.readyWorkers.size === state.config.workerCount) {
                state.config.setupComplete = true;
                storage.set('config', 'main', state.config);
                document.getElementById('setupSummary').textContent = `${state.config.workerCount} workers ‚Ä¢ Whisper ${state.config.whisperModel}`;
                state.setupStep = 5;
                updateSetupUI();
            }
        }
        
        async function setupNext() {
            if (state.setupStep === 1) {
                const sel = document.querySelector('.setup-step[data-step="1"] .option.selected');
                state.config.whisperModel = sel?.dataset.value || 'base';
                state.setupStep = 2;
            } else if (state.setupStep === 2) {
                const sel = document.querySelector('.setup-step[data-step="2"] .option.selected');
                state.config.enableTranslation = sel?.dataset.value === 'yes';
                state.setupStep = 3;
                updateWorkerEstimate();
            } else if (state.setupStep === 3) {
                state.config.workerCount = parseInt(document.getElementById('workerCountSlider').value);
                state.setupStep = 4;
                updateSetupUI();
                initSetupWorkersGrid();
                await initWorkers();
            } else if (state.setupStep === 5) {
                hideSetup();
            }
            updateSetupUI();
        }
        
        async function checkResume() {
            const progress = await storage.get('progress', 'current');
            const meta = await storage.get('progress', 'meta');
            if (progress && meta && progress.completed.length < meta.totalChunks) {
                state.totalChunks = meta.totalChunks;
                const results = await storage.getAll('results');
                for (const r of results) { state.results.set(r.chunkIndex, r); state.completedChunks.add(r.chunkIndex); if (r.filtered) state.filteredCount++; }
                document.getElementById('resumeInfo').textContent = `${progress.completed.length}/${meta.totalChunks} ‚Ä¢ ${meta.fileName}`;
                document.getElementById('resumeBanner').classList.add('visible');
                const audio = await storage.get('audio', 'current');
                if (audio) {
                    state.audioMeta = { name: audio.name, size: audio.size };
                    document.getElementById('uploadArea').classList.add('has-file');
                    document.getElementById('fileInfo').classList.add('visible');
                    document.getElementById('fileName').textContent = audio.name;
                    document.getElementById('fileMeta').textContent = `${formatBytes(audio.size)} ‚Ä¢ ${meta.totalChunks} chunks`;
                    document.getElementById('startBtn').disabled = state.readyWorkers.size === 0;
                    document.getElementById('progressSection').classList.add('visible');
                }
                initChunkGrid();
                for (const r of results) { updateChunkCell(r.chunkIndex, r.filtered ? 'filtered' : 'done'); updateChunkList(r); }
                updateStats();
                return true;
            }
            return false;
        }
        
        function getExportData() {
            return Array.from(state.results.values()).filter(r => r.text && !r.filtered).sort((a, b) => a.chunkIndex - b.chunkIndex);
        }
        
        function exportMarkdown() {
            const data = getExportData(); if (!data.length) return toast('error', 'No data');
            let md = `# ${state.audioMeta?.name || 'Transcript'}\n\n`;
            for (const c of data) { md += `## ${String(c.chunkIndex + 1).padStart(3, '0')} [${formatTime(c.startTime)}]\n\n${c.text}\n\n${c.translation ? `> ${c.translation}\n\n` : ''}`; }
            download(`${state.audioMeta?.name || 'transcript'}.md`, md, 'text/markdown');
        }
        
        function exportJson() {
            const data = getExportData(); if (!data.length) return toast('error', 'No data');
            const json = JSON.stringify({ meta: { fileName: state.audioMeta?.name, chunks: state.totalChunks }, chunks: data.map(c => ({ id: String(c.chunkIndex + 1).padStart(3, '0'), start: c.startTime, end: c.endTime, lang: c.language, text: c.text, translation: c.translation })) }, null, 2);
            download(`${state.audioMeta?.name || 'transcript'}.json`, json, 'application/json');
        }
        
        function exportTxt() {
            const data = getExportData(); if (!data.length) return toast('error', 'No data');
            let txt = '';
            for (const c of data) { txt += `[${String(c.chunkIndex + 1).padStart(3, '0')}] ${formatTime(c.startTime)}\n${c.text}\n${c.translation ? `‚Üí ${c.translation}\n` : ''}\n`; }
            download(`${state.audioMeta?.name || 'transcript'}.txt`, txt, 'text/plain');
        }
        
        function copyAll() {
            const data = getExportData(); if (!data.length) return toast('error', 'No data');
            navigator.clipboard.writeText(data.map(c => c.translation || c.text).join('\n\n')).then(() => toast('success', 'Copied'));
        }
        
        function formatTime(s) { const m = Math.floor(s / 60); return `${m}:${Math.floor(s % 60).toString().padStart(2, '0')}`; }
        function formatBytes(b) { return b < 1048576 ? (b / 1024).toFixed(1) + ' KB' : (b / 1048576).toFixed(1) + ' MB'; }
        function escapeHtml(t) { const d = document.createElement('div'); d.textContent = t; return d.innerHTML; }
        function download(name, content, type) { const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([content], { type })); a.download = name; a.click(); }
        function toast(type, msg) { const t = document.createElement('div'); t.className = `toast ${type}`; t.textContent = msg; document.getElementById('toastArea').appendChild(t); setTimeout(() => { t.style.opacity = '0'; setTimeout(() => t.remove(), 300); }, 3000); }
        
        document.getElementById('uploadArea').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('uploadArea').addEventListener('dragover', e => e.preventDefault());
        document.getElementById('uploadArea').addEventListener('drop', e => { e.preventDefault(); if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]); });
        document.getElementById('fileInput').addEventListener('change', e => { if (e.target.files[0]) handleFile(e.target.files[0]); });
        document.getElementById('startBtn').addEventListener('click', () => startProcessing(state.completedChunks));
        document.getElementById('stopBtn').addEventListener('click', stopProcessing);
        document.getElementById('resumeBtn').addEventListener('click', () => startProcessing(state.completedChunks));
        document.getElementById('discardBtn').addEventListener('click', discardProgress);
        document.getElementById('restartBtn').addEventListener('click', async () => { if (state.isProcessing) { toast('error', 'Stop first'); return; } toast('success', 'Restarting...'); await initWorkers(); });
        document.getElementById('settingsBtn').addEventListener('click', () => { state.config.setupComplete = false; state.setupStep = 1; showSetup(); updateSetupUI(); });
        document.getElementById('setupNext').addEventListener('click', setupNext);
        document.getElementById('setupBack').addEventListener('click', () => { if (state.setupStep > 1 && state.setupStep < 4) { state.setupStep--; updateSetupUI(); } });
        document.querySelectorAll('.option').forEach(opt => opt.addEventListener('click', () => { opt.closest('.setup-step').querySelectorAll('.option').forEach(o => o.classList.remove('selected')); opt.classList.add('selected'); if (state.setupStep === 1) state.config.whisperModel = opt.dataset.value; }));
        document.getElementById('workerCountSlider').addEventListener('input', updateWorkerEstimate);
        document.querySelectorAll('.tab').forEach(tab => tab.addEventListener('click', () => { document.querySelectorAll('.tab').forEach(t => t.classList.remove('active')); document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active')); tab.classList.add('active'); document.getElementById(`tab-${tab.dataset.tab}`).classList.add('active'); }));
        document.getElementById('exportMd').addEventListener('click', exportMarkdown);
        document.getElementById('exportJson').addEventListener('click', exportJson);
        document.getElementById('exportTxt').addEventListener('click', exportTxt);
        document.getElementById('copyAll').addEventListener('click', copyAll);
        
        async function init() {
            await storage.init();
            const config = await storage.get('config', 'main');
            if (config) state.config = { ...state.config, ...config };
            if (!state.config.setupComplete) { showSetup(); }
            else { hideSetup(); await initWorkers(); await checkResume(); }
        }
        init();
    </script>
</body>
</html>
