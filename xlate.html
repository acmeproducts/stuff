<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thai Transcriber v7</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap');
        
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a24;
            --bg-elevated: #22222e;
            --border-primary: #2a2a3a;
            --border-secondary: #363648;
            --text-primary: #e8e8f0;
            --text-secondary: #a0a0b8;
            --text-muted: #606078;
            --accent-gold: #d4a853;
            --accent-gold-dim: #a07830;
            --accent-thai: #4a90c2;
            --accent-english: #9a70c2;
            --status-success: #48a068;
            --status-warning: #c08840;
            --status-error: #c05050;
            --status-info: #5080c0;
        }
        
        html, body { height: 100%; overflow: hidden; }
        
        body {
            font-family: 'Sarabun', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            font-size: 14px;
        }
        
        .app-container { display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        
        .app-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            flex-shrink: 0;
        }
        
        .app-logo {
            font-size: 1rem;
            font-weight: 300;
            letter-spacing: 0.2em;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-gold-dim));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .header-controls { display: flex; align-items: center; gap: 0.75rem; }
        
        .worker-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.35rem 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 20px;
            font-size: 0.7rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .worker-dots { display: flex; gap: 3px; }
        
        .worker-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--border-secondary);
            transition: background 0.2s;
        }
        
        .worker-dot.loading { background: var(--status-warning); animation: pulse 1s infinite; }
        .worker-dot.ready { background: var(--status-success); }
        .worker-dot.working { background: var(--accent-gold); animation: pulse 0.5s infinite; }
        .worker-dot.error { background: var(--status-error); }
        
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        
        .app-main { display: flex; flex: 1; overflow: hidden; }
        
        /* Sidebar */
        .sidebar {
            width: 220px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-primary);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: width 0.2s;
        }
        
        .sidebar.collapsed { width: 0; overflow: hidden; }
        
        .sidebar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-primary);
        }
        
        .sidebar-title {
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
        }
        
        .sidebar-sessions { flex: 1; overflow-y: auto; padding: 0.5rem; }
        
        .session-card {
            padding: 0.6rem 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            position: relative;
        }
        
        .session-card:hover { border-color: var(--border-secondary); background: var(--bg-elevated); }
        .session-card.active { border-color: var(--accent-gold); background: rgba(212, 168, 83, 0.08); }
        
        .session-card-date { font-size: 0.7rem; color: var(--text-secondary); }
        .session-card-name { font-size: 0.75rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        .session-card-progress { display: flex; gap: 2px; margin-top: 0.3rem; }
        .session-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--border-secondary); }
        .session-dot.filled { background: var(--status-success); }
        
        .session-card-delete {
            position: absolute;
            top: 0.4rem;
            right: 0.4rem;
            width: 18px;
            height: 18px;
            border: none;
            background: var(--status-error);
            color: white;
            border-radius: 3px;
            font-size: 0.7rem;
            cursor: pointer;
            opacity: 0;
        }
        
        .session-card:hover .session-card-delete { opacity: 1; }
        
        .sidebar-footer { padding: 0.75rem; border-top: 1px solid var(--border-primary); }
        
        .new-btn {
            width: 100%;
            padding: 0.6rem;
            background: var(--bg-tertiary);
            border: 2px dashed var(--border-secondary);
            border-radius: 6px;
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 0.75rem;
            cursor: pointer;
        }
        
        .new-btn:hover { border-color: var(--accent-gold); color: var(--accent-gold); }
        
        /* Content Area */
        .content-area { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        
        .content-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            gap: 1rem;
        }
        
        .content-header-left { display: flex; align-items: center; gap: 0.75rem; flex: 1; min-width: 0; }
        
        .sidebar-toggle {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border-primary);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
        }
        
        .session-info { flex: 1; min-width: 0; }
        
        .session-name-input {
            background: transparent;
            border: none;
            font-family: inherit;
            font-size: 0.95rem;
            font-weight: 500;
            color: var(--text-primary);
            width: 100%;
            padding: 0.2rem 0;
            border-bottom: 1px solid transparent;
        }
        
        .session-name-input:focus { outline: none; border-bottom-color: var(--accent-gold); }
        
        .session-meta { font-size: 0.7rem; color: var(--text-muted); font-family: 'JetBrains Mono', monospace; }
        
        .content-actions { display: flex; gap: 0.5rem; }
        
        /* Buttons */
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 5px;
            font-family: inherit;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
        }
        
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background: linear-gradient(135deg, var(--accent-gold), var(--accent-gold-dim)); color: var(--bg-primary); }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-primary); }
        .btn-ghost { background: transparent; color: var(--text-secondary); padding: 0.35rem 0.5rem; }
        .btn-sm { padding: 0.35rem 0.6rem; font-size: 0.7rem; }
        .btn-xs { padding: 0.2rem 0.4rem; font-size: 0.65rem; }
        .btn-icon { width: 32px; height: 32px; padding: 0; }
        
        /* Transcript View */
        .transcript-container { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        
        .transcript-header {
            display: grid;
            grid-template-columns: 1fr 1fr;
            border-bottom: 1px solid var(--border-primary);
            background: var(--bg-secondary);
        }
        
        .column-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.6rem 1rem;
        }
        
        .column-header:first-child { border-right: 1px solid var(--border-primary); }
        
        .column-title { font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); }
        
        .transcript-scroll { flex: 1; overflow-y: auto; }
        
        .chunk-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            border-bottom: 1px solid var(--border-primary);
        }
        
        .chunk-row:hover { background: rgba(255, 255, 255, 0.02); }
        .chunk-row.filtered { opacity: 0.5; }
        
        .chunk-cell { padding: 0.75rem 1rem; min-height: 80px; }
        .chunk-cell:first-child { border-right: 1px solid var(--border-primary); }
        
        .chunk-header { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; flex-wrap: wrap; }
        
        .chunk-id {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            color: var(--text-muted);
            background: var(--bg-tertiary);
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
        }
        
        .chunk-time { font-family: 'JetBrains Mono', monospace; font-size: 0.6rem; color: var(--text-muted); }
        
        .chunk-lang { font-size: 0.6rem; font-weight: 600; padding: 0.1rem 0.35rem; border-radius: 3px; }
        .chunk-lang.th { background: rgba(74, 144, 194, 0.15); color: var(--accent-thai); }
        .chunk-lang.en { background: rgba(154, 112, 194, 0.15); color: var(--accent-english); }
        
        .chunk-play {
            width: 22px;
            height: 22px;
            border: 1px solid var(--border-secondary);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border-radius: 50%;
            font-size: 0.6rem;
            cursor: pointer;
        }
        
        .chunk-play:hover { background: var(--accent-gold); border-color: var(--accent-gold); color: var(--bg-primary); }
        
        .chunk-text { font-size: 0.9rem; line-height: 1.7; }
        .chunk-text.empty { color: var(--text-muted); font-style: italic; }
        .chunk-text.filtered { color: var(--status-warning); font-size: 0.8rem; }
        
        .chunk-actions { display: flex; gap: 0.3rem; margin-top: 0.5rem; opacity: 0; transition: opacity 0.15s; }
        .chunk-row:hover .chunk-actions { opacity: 1; }
        
        .chunk-action {
            padding: 0.2rem 0.4rem;
            font-size: 0.6rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            border-radius: 3px;
            cursor: pointer;
        }
        
        .chunk-action:hover { background: var(--bg-elevated); color: var(--text-primary); }
        
        .back-translation {
            margin-top: 0.6rem;
            padding: 0.5rem 0.6rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            border-left: 2px solid var(--accent-gold-dim);
        }
        
        .back-translation-label { font-size: 0.6rem; color: var(--text-muted); margin-bottom: 0.25rem; display: flex; justify-content: space-between; }
        .back-translation-text { font-size: 0.8rem; color: var(--accent-gold); font-style: italic; }
        
        /* Empty State */
        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            padding: 2rem;
        }
        
        .empty-icon { font-size: 3rem; margin-bottom: 1rem; opacity: 0.3; }
        .empty-title { font-size: 1rem; margin-bottom: 0.5rem; color: var(--text-secondary); }
        
        .drop-zone {
            margin-top: 1.5rem;
            padding: 2rem 3rem;
            border: 2px dashed var(--border-secondary);
            border-radius: 10px;
            cursor: pointer;
            text-align: center;
        }
        
        .drop-zone:hover { border-color: var(--accent-gold); background: rgba(212, 168, 83, 0.05); }
        .drop-zone.dragover { border-color: var(--accent-gold); background: rgba(212, 168, 83, 0.1); }
        
        /* Progress Bar */
        .progress-bar-container {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-primary);
            padding: 0.6rem 1rem;
            display: none;
        }
        
        .progress-bar-container.visible { display: block; }
        
        .progress-header { display: flex; justify-content: space-between; margin-bottom: 0.4rem; font-size: 0.7rem; }
        .progress-stats { display: flex; gap: 1rem; font-size: 0.65rem; font-family: 'JetBrains Mono', monospace; color: var(--text-muted); }
        
        .progress-track { height: 6px; background: var(--bg-tertiary); border-radius: 3px; overflow: hidden; display: flex; }
        .progress-fill { height: 100%; transition: width 0.3s; }
        .progress-fill.transcribe { background: var(--accent-thai); }
        .progress-fill.translate { background: var(--accent-gold); }
        
        /* Setup Overlay */
        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(10, 10, 15, 0.95);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        
        .overlay.hidden { display: none; }
        
        .setup-modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            width: 100%;
            max-width: 480px;
        }
        
        .setup-header { padding: 1.25rem; border-bottom: 1px solid var(--border-primary); text-align: center; }
        .setup-title { font-size: 1.1rem; color: var(--accent-gold); }
        .setup-subtitle { font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem; }
        
        .setup-body { padding: 1.25rem; }
        .setup-step { display: none; }
        .setup-step.active { display: block; }
        .setup-label { font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.75rem; }
        
        .setup-option {
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            cursor: pointer;
        }
        
        .setup-option:hover { border-color: var(--border-secondary); }
        .setup-option.selected { border-color: var(--accent-gold); background: rgba(212, 168, 83, 0.08); }
        .setup-option-title { font-weight: 500; font-size: 0.9rem; }
        .setup-option-desc { font-size: 0.75rem; color: var(--text-muted); }
        
        .setup-slider-container { margin: 1.5rem 0; }
        .setup-slider-header { display: flex; justify-content: space-between; margin-bottom: 0.75rem; }
        .setup-slider-value { font-family: 'JetBrains Mono', monospace; font-size: 1.1rem; font-weight: 600; color: var(--accent-gold); }
        
        .setup-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: var(--bg-tertiary);
            -webkit-appearance: none;
        }
        
        .setup-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--accent-gold);
            cursor: pointer;
        }
        
        .setup-estimate {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: var(--bg-primary);
            border-radius: 6px;
            font-size: 0.75rem;
            color: var(--text-muted);
            text-align: center;
        }
        
        .setup-workers-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; margin-top: 1rem; }
        
        .setup-worker-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.75rem;
        }
        
        .setup-worker-header { display: flex; justify-content: space-between; margin-bottom: 0.5rem; }
        .setup-worker-id { font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; font-weight: 600; color: var(--text-secondary); }
        .setup-worker-status { font-size: 0.65rem; color: var(--text-muted); }
        .setup-worker-card.loading .setup-worker-status { color: var(--status-warning); }
        .setup-worker-card.ready .setup-worker-status { color: var(--status-success); }
        .setup-worker-card.error .setup-worker-status { color: var(--status-error); }
        
        .setup-worker-progress { height: 4px; background: var(--bg-primary); border-radius: 2px; overflow: hidden; margin-bottom: 0.3rem; }
        .setup-worker-progress-fill { height: 100%; background: var(--accent-gold); width: 0%; transition: width 0.2s; }
        .setup-worker-card.ready .setup-worker-progress-fill { background: var(--status-success); width: 100%; }
        
        .setup-worker-task { font-size: 0.65rem; color: var(--text-muted); font-family: 'JetBrains Mono', monospace; }
        
        .setup-complete { text-align: center; padding: 1rem 0; }
        .setup-complete-icon { font-size: 3rem; margin-bottom: 0.75rem; }
        .setup-complete-title { font-size: 1.1rem; color: var(--status-success); margin-bottom: 0.5rem; }
        .setup-complete-summary { font-size: 0.8rem; color: var(--text-muted); }
        
        .setup-footer {
            padding: 1rem 1.25rem;
            border-top: 1px solid var(--border-primary);
            display: flex;
            justify-content: space-between;
        }
        
        /* Ingest Overlay */
        .ingest-modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            width: 100%;
            max-width: 400px;
            padding: 2rem;
            text-align: center;
        }
        
        .ingest-icon { font-size: 2.5rem; margin-bottom: 1rem; }
        .ingest-title { font-size: 1rem; margin-bottom: 0.5rem; }
        .ingest-status { font-size: 0.8rem; color: var(--text-muted); margin-bottom: 1rem; }
        .ingest-progress { height: 6px; background: var(--bg-tertiary); border-radius: 3px; overflow: hidden; margin-bottom: 0.5rem; }
        .ingest-progress-fill { height: 100%; background: var(--accent-gold); width: 0%; transition: width 0.3s; }
        .ingest-detail { font-size: 0.7rem; font-family: 'JetBrains Mono', monospace; color: var(--text-muted); }
        
        /* Toast */
        .toast-container { position: fixed; bottom: 1rem; right: 1rem; z-index: 2000; }
        
        .toast {
            padding: 0.75rem 1rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            margin-top: 0.5rem;
            font-size: 0.8rem;
            animation: toastIn 0.2s;
        }
        
        @keyframes toastIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        
        .toast.success { border-color: var(--status-success); }
        .toast.error { border-color: var(--status-error); }
        .toast.warning { border-color: var(--status-warning); }
        
        .hidden { display: none !important; }
        input[type="file"] { display: none; }
        
        @media (max-width: 768px) {
            .sidebar { position: fixed; left: 0; top: 0; bottom: 0; z-index: 100; transform: translateX(-100%); }
            .sidebar.open { transform: translateX(0); }
            .chunk-row { grid-template-columns: 1fr; }
            .chunk-cell:first-child { border-right: none; border-bottom: 1px solid var(--border-primary); }
            .transcript-header { grid-template-columns: 1fr; }
            .column-header:first-child { border-right: none; border-bottom: 1px solid var(--border-primary); }
        }
    </style>
</head>
<body>
    <!-- Setup Overlay -->
    <div class="overlay" id="setupOverlay">
        <div class="setup-modal">
            <div class="setup-header">
                <div class="setup-title">Thai Transcriber Setup</div>
                <div class="setup-subtitle">Configure transcription environment</div>
            </div>
            <div class="setup-body">
                <!-- Step 1: Model -->
                <div class="setup-step active" data-step="1">
                    <div class="setup-label">Select Whisper Model</div>
                    <div class="setup-option" data-value="tiny">
                        <div class="setup-option-title">üöÄ Tiny (~40 MB/worker)</div>
                        <div class="setup-option-desc">Fastest, less accurate</div>
                    </div>
                    <div class="setup-option selected" data-value="base">
                        <div class="setup-option-title">‚öñÔ∏è Base (~75 MB/worker)</div>
                        <div class="setup-option-desc">Recommended balance</div>
                    </div>
                    <div class="setup-option" data-value="small">
                        <div class="setup-option-title">üéØ Small (~250 MB/worker)</div>
                        <div class="setup-option-desc">Most accurate, slower</div>
                    </div>
                </div>
                
                <!-- Step 2: Workers -->
                <div class="setup-step" data-step="2">
                    <div class="setup-label">Parallel Workers (1-8)</div>
                    <div class="setup-slider-container">
                        <div class="setup-slider-header">
                            <span>Workers</span>
                            <span class="setup-slider-value" id="setupWorkerCount">4</span>
                        </div>
                        <input type="range" class="setup-slider" id="setupWorkerSlider" min="1" max="8" value="4">
                    </div>
                    <div class="setup-estimate" id="setupEstimate">~500 MB RAM ‚Ä¢ 4√ó parallel</div>
                    <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 0.75rem;">
                        Each worker loads Whisper + translators. More = faster but needs more RAM.
                    </div>
                </div>
                
                <!-- Step 3: Init -->
                <div class="setup-step" data-step="3">
                    <div class="setup-label">Initializing Workers...</div>
                    <div class="setup-workers-grid" id="setupWorkersGrid"></div>
                </div>
                
                <!-- Step 4: Done -->
                <div class="setup-step" data-step="4">
                    <div class="setup-complete">
                        <div class="setup-complete-icon">‚úÖ</div>
                        <div class="setup-complete-title">Setup Complete</div>
                        <div class="setup-complete-summary" id="setupSummary">4 workers ‚Ä¢ Whisper base</div>
                    </div>
                </div>
            </div>
            <div class="setup-footer">
                <button class="btn btn-secondary hidden" id="setupBackBtn">‚Üê Back</button>
                <div style="flex: 1;"></div>
                <button class="btn btn-primary" id="setupNextBtn">Next ‚Üí</button>
            </div>
        </div>
    </div>
    
    <!-- Ingest Overlay -->
    <div class="overlay hidden" id="ingestOverlay">
        <div class="ingest-modal">
            <div class="ingest-icon">üìÇ</div>
            <div class="ingest-title" id="ingestTitle">Processing Audio</div>
            <div class="ingest-status" id="ingestStatus">Reading file...</div>
            <div class="ingest-progress"><div class="ingest-progress-fill" id="ingestProgressFill"></div></div>
            <div class="ingest-detail" id="ingestDetail">0%</div>
        </div>
    </div>
    
    <!-- Main App -->
    <div class="app-container">
        <header class="app-header">
            <div class="app-logo">THAI TRANSCRIBER</div>
            <div class="header-controls">
                <div class="worker-status">
                    <div class="worker-dots" id="workerDots"></div>
                    <span id="workerStatusText">Loading...</span>
                </div>
                <button class="btn btn-ghost btn-icon" id="restartBtn" title="Restart">üîÑ</button>
                <button class="btn btn-ghost btn-icon" id="settingsBtn" title="Settings">‚öôÔ∏è</button>
            </div>
        </header>
        
        <div class="app-main">
            <aside class="sidebar" id="sidebar">
                <div class="sidebar-header">
                    <span class="sidebar-title">Sessions</span>
                    <span class="sidebar-title" id="sessionCount">0</span>
                </div>
                <div class="sidebar-sessions" id="sessionsList"></div>
                <div class="sidebar-footer">
                    <button class="new-btn" id="newSessionBtn">+ New Recording</button>
                </div>
            </aside>
            
            <main class="content-area" id="contentArea"></main>
        </div>
        
        <div class="progress-bar-container" id="progressBar">
            <div class="progress-header">
                <span id="progressLabel">Processing...</span>
                <div class="progress-stats">
                    <span id="progressTranscribe">Transcribe: 0/0</span>
                    <span id="progressTranslate">Translate: 0/0</span>
                </div>
            </div>
            <div class="progress-track">
                <div class="progress-fill transcribe" id="progressFillTranscribe"></div>
                <div class="progress-fill translate" id="progressFillTranslate"></div>
            </div>
        </div>
    </div>
    
    <input type="file" id="fileInput" accept="audio/*,.m4a,.mp3,.wav,.ogg,.flac">
    <div class="toast-container" id="toastContainer"></div>

    <!-- Worker Code -->
    <script id="workerCode" type="text/js-worker">
        let workerId = null;
        let whisperPipeline = null;
        let translatorThEn = null;
        let translatorEnTh = null;
        
        self.onmessage = async function(e) {
            const { type, data } = e.data;
            
            if (type === 'init') {
                workerId = data.workerId;
                
                try {
                    // Import transformers
                    self.postMessage({ type: 'status', workerId, status: 'loading', task: 'Loading library...' });
                    
                    const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2');
                    
                    // Load Whisper
                    self.postMessage({ type: 'status', workerId, status: 'loading', task: 'Loading Whisper...' });
                    whisperPipeline = await pipeline('automatic-speech-recognition', 'Xenova/whisper-' + data.model, {
                        quantized: true,
                        progress_callback: (p) => {
                            if (p.status === 'progress') {
                                self.postMessage({ type: 'progress', workerId, model: 'whisper', progress: p.progress });
                            }
                        }
                    });
                    self.postMessage({ type: 'progress', workerId, model: 'whisper', progress: 100 });
                    
                    // Load Thai->English
                    self.postMessage({ type: 'status', workerId, status: 'loading', task: 'Loading TH‚ÜíEN...' });
                    translatorThEn = await pipeline('translation', 'Xenova/opus-mt-th-en', {
                        quantized: true,
                        progress_callback: (p) => {
                            if (p.status === 'progress') {
                                self.postMessage({ type: 'progress', workerId, model: 'th-en', progress: p.progress });
                            }
                        }
                    });
                    self.postMessage({ type: 'progress', workerId, model: 'th-en', progress: 100 });
                    
                    // Load English->Thai - use a simpler model
                    self.postMessage({ type: 'status', workerId, status: 'loading', task: 'Loading EN‚ÜíTH...' });
                    try {
                        // Try the multilingual model first
                        translatorEnTh = await pipeline('translation', 'Xenova/opus-mt-en-th', {
                            quantized: true,
                            progress_callback: (p) => {
                                if (p.status === 'progress') {
                                    self.postMessage({ type: 'progress', workerId, model: 'en-th', progress: p.progress });
                                }
                            }
                        });
                    } catch (err) {
                        // Fallback - skip EN->TH if not available
                        console.warn('EN->TH model not available, skipping');
                        translatorEnTh = null;
                    }
                    self.postMessage({ type: 'progress', workerId, model: 'en-th', progress: 100 });
                    
                    self.postMessage({ type: 'ready', workerId });
                    
                } catch (error) {
                    console.error('Worker init error:', error);
                    self.postMessage({ type: 'error', workerId, error: error.message });
                }
            }
            
            if (type === 'transcribe') {
                const { sessionId, chunkIndex, audioData, startTime, endTime } = data;
                
                try {
                    self.postMessage({ type: 'status', workerId, status: 'working', task: 'Chunk ' + (chunkIndex + 1) });
                    
                    const audio = new Float32Array(audioData);
                    
                    // Silence detection
                    let sumSq = 0;
                    for (let i = 0; i < audio.length; i++) sumSq += audio[i] * audio[i];
                    const rms = Math.sqrt(sumSq / audio.length);
                    const db = 20 * Math.log10(rms + 1e-10);
                    
                    if (db < -40) {
                        self.postMessage({
                            type: 'chunkComplete', workerId, sessionId, chunkIndex,
                            result: { transcript: '', transcriptLang: 'unknown', filtered: true, filterReason: 'Silence' }
                        });
                        return;
                    }
                    
                    // Transcribe
                    const result = await whisperPipeline(audio, { language: 'th', task: 'transcribe', return_timestamps: false });
                    let text = result.text?.trim() || '';
                    let filtered = false;
                    let filterReason = null;
                    
                    // Repetition check
                    if (text && text.length > 20) {
                        if (/([\u0E00-\u0E7F]{1,5})\1{5,}/.test(text)) {
                            filtered = true;
                            filterReason = 'Repetition loop';
                            text = '';
                        } else {
                            const words = text.split(/\s+/);
                            if (words.length > 8) {
                                const counts = {};
                                for (const w of words) counts[w] = (counts[w] || 0) + 1;
                                const max = Math.max(...Object.values(counts));
                                if (max > words.length * 0.5) {
                                    filtered = true;
                                    filterReason = 'Word repetition';
                                    text = '';
                                }
                            }
                        }
                    }
                    
                    // Detect language
                    let lang = 'unknown';
                    if (text) {
                        const thaiChars = (text.match(/[\u0E00-\u0E7F]/g) || []).length;
                        const total = text.replace(/\s/g, '').length;
                        lang = total > 0 && thaiChars / total > 0.3 ? 'th' : 'en';
                    }
                    
                    self.postMessage({
                        type: 'chunkComplete', workerId, sessionId, chunkIndex,
                        result: { transcript: text, transcriptLang: lang, filtered, filterReason }
                    });
                    
                } catch (error) {
                    self.postMessage({ type: 'chunkError', workerId, sessionId, chunkIndex, error: error.message });
                }
            }
            
            if (type === 'translate') {
                const { sessionId, chunkIndex, text, sourceLang } = data;
                
                try {
                    self.postMessage({ type: 'status', workerId, status: 'working', task: 'Translating ' + (chunkIndex + 1) });
                    
                    let translation = '';
                    let targetLang = '';
                    
                    if (sourceLang === 'th' && translatorThEn) {
                        const result = await translatorThEn(text, { max_length: 512 });
                        translation = result[0]?.translation_text || '';
                        targetLang = 'en';
                    } else if (sourceLang === 'en' && translatorEnTh) {
                        const result = await translatorEnTh(text, { max_length: 512 });
                        translation = result[0]?.translation_text || '';
                        targetLang = 'th';
                    }
                    
                    self.postMessage({
                        type: 'translateComplete', workerId, sessionId, chunkIndex,
                        result: { translation, translationLang: targetLang }
                    });
                    
                } catch (error) {
                    self.postMessage({ type: 'translateError', workerId, sessionId, chunkIndex, error: error.message });
                }
            }
            
            if (type === 'backTranslate') {
                const { sessionId, chunkIndex, text, sourceLang } = data;
                
                try {
                    self.postMessage({ type: 'status', workerId, status: 'working', task: 'Back-translating ' + (chunkIndex + 1) });
                    
                    let backTranslation = '';
                    
                    // sourceLang is original language, so we translate back to it
                    if (sourceLang === 'th' && translatorEnTh) {
                        // text is EN, translate to TH
                        const result = await translatorEnTh(text, { max_length: 512 });
                        backTranslation = result[0]?.translation_text || '';
                    } else if (sourceLang === 'en' && translatorThEn) {
                        // text is TH, translate to EN
                        const result = await translatorThEn(text, { max_length: 512 });
                        backTranslation = result[0]?.translation_text || '';
                    }
                    
                    self.postMessage({
                        type: 'backTranslateComplete', workerId, sessionId, chunkIndex,
                        result: { backTranslation }
                    });
                    
                } catch (error) {
                    self.postMessage({ type: 'backTranslateError', workerId, sessionId, chunkIndex, error: error.message });
                }
            }
        };
    </script>

    <script type="module">
        // ================================================
        // THAI TRANSCRIBER v7 - Main Application
        // ================================================
        
        const DB_NAME = 'ThaiTranscriberV7';
        const DB_VERSION = 1;
        const MAX_SESSIONS = 10;
        const CHUNK_SEC = 30;
        const SAMPLE_RATE = 16000;
        
        // ============================================
        // STORAGE
        // ============================================
        
        class Storage {
            constructor() { this.db = null; }
            
            async init() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open(DB_NAME, DB_VERSION);
                    req.onerror = () => reject(req.error);
                    req.onsuccess = () => { this.db = req.result; resolve(); };
                    req.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('sessions')) {
                            const s = db.createObjectStore('sessions', { keyPath: 'id' });
                            s.createIndex('createdAt', 'createdAt');
                        }
                        if (!db.objectStoreNames.contains('chunks')) {
                            const c = db.createObjectStore('chunks', { keyPath: 'key' });
                            c.createIndex('sessionId', 'sessionId');
                        }
                        if (!db.objectStoreNames.contains('config')) {
                            db.createObjectStore('config', { keyPath: 'key' });
                        }
                    };
                });
            }
            
            async _ensure() { if (!this.db) await this.init(); }
            
            async get(store, key) {
                await this._ensure();
                return new Promise((res, rej) => {
                    const r = this.db.transaction(store, 'readonly').objectStore(store).get(key);
                    r.onsuccess = () => res(r.result);
                    r.onerror = () => rej(r.error);
                });
            }
            
            async put(store, data) {
                await this._ensure();
                return new Promise((res, rej) => {
                    const r = this.db.transaction(store, 'readwrite').objectStore(store).put(data);
                    r.onsuccess = () => res();
                    r.onerror = () => rej(r.error);
                });
            }
            
            async delete(store, key) {
                await this._ensure();
                return new Promise((res, rej) => {
                    const r = this.db.transaction(store, 'readwrite').objectStore(store).delete(key);
                    r.onsuccess = () => res();
                    r.onerror = () => rej(r.error);
                });
            }
            
            async getAll(store) {
                await this._ensure();
                return new Promise((res, rej) => {
                    const r = this.db.transaction(store, 'readonly').objectStore(store).getAll();
                    r.onsuccess = () => res(r.result || []);
                    r.onerror = () => rej(r.error);
                });
            }
            
            async getAllByIndex(store, indexName, value) {
                await this._ensure();
                return new Promise((res, rej) => {
                    const r = this.db.transaction(store, 'readonly').objectStore(store).index(indexName).getAll(value);
                    r.onsuccess = () => res(r.result || []);
                    r.onerror = () => rej(r.error);
                });
            }
            
            async getAllSessions() {
                const s = await this.getAll('sessions');
                return s.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
            }
            
            async getChunksForSession(sessionId) {
                const c = await this.getAllByIndex('chunks', 'sessionId', sessionId);
                return c.sort((a, b) => a.index - b.index);
            }
            
            async saveChunk(chunk) {
                chunk.key = chunk.sessionId + '_' + chunk.index;
                await this.put('chunks', chunk);
            }
            
            async deleteSession(sessionId) {
                const chunks = await this.getChunksForSession(sessionId);
                for (const c of chunks) await this.delete('chunks', c.key);
                await this.delete('sessions', sessionId);
            }
            
            async cleanupOld() {
                const sessions = await this.getAllSessions();
                if (sessions.length >= MAX_SESSIONS) {
                    const toDelete = sessions.slice(MAX_SESSIONS - 1);
                    for (const s of toDelete) await this.deleteSession(s.id);
                }
            }
            
            async getConfig() {
                const c = await this.get('config', 'main');
                return c || { key: 'main', whisperModel: 'base', workerCount: 4, setupComplete: false };
            }
            
            async saveConfig(config) {
                config.key = 'main';
                await this.put('config', config);
            }
        }
        
        const storage = new Storage();
        
        // ============================================
        // STATE
        // ============================================
        
        const state = {
            config: { whisperModel: 'base', workerCount: 4, setupComplete: false },
            setupStep: 1,
            workers: [],
            workerStates: new Map(),
            readyWorkers: new Set(),
            currentSession: null,
            chunks: new Map(),
            isProcessing: false,
            transcribeQueue: [],
            translateQueue: [],
            stats: { total: 0, transcribed: 0, translated: 0, filtered: 0, errors: 0 }
        };
        
        // ============================================
        // WORKERS
        // ============================================
        
        function createWorker(id) {
            const code = document.getElementById('workerCode').textContent;
            const blob = new Blob([code], { type: 'application/javascript' });
            const worker = new Worker(URL.createObjectURL(blob), { type: 'module' });
            
            worker.onmessage = (e) => handleWorkerMsg(id, e.data);
            worker.onerror = (e) => {
                console.error('Worker error:', e);
                updateWorkerState(id, 'error', 'Error');
            };
            
            return worker;
        }
        
        function handleWorkerMsg(workerId, msg) {
            const { type } = msg;
            
            if (type === 'status') {
                updateWorkerState(workerId, msg.status, msg.task);
                updateSetupWorkerUI(workerId);
            } else if (type === 'progress') {
                const ws = state.workerStates.get(workerId) || { status: 'loading', task: '', progress: {} };
                ws.progress = ws.progress || {};
                ws.progress[msg.model] = msg.progress;
                state.workerStates.set(workerId, ws);
                updateSetupWorkerUI(workerId);
            } else if (type === 'ready') {
                state.readyWorkers.add(workerId);
                updateWorkerState(workerId, 'ready', 'Ready');
                updateSetupWorkerUI(workerId);
                checkAllWorkersReady();
                if (state.isProcessing) processNext();
            } else if (type === 'error') {
                updateWorkerState(workerId, 'error', msg.error?.substring(0, 30) || 'Error');
                updateSetupWorkerUI(workerId);
            } else if (type === 'chunkComplete') {
                handleChunkComplete(msg);
            } else if (type === 'chunkError') {
                handleChunkError(msg);
            } else if (type === 'translateComplete') {
                handleTranslateComplete(msg);
            } else if (type === 'translateError') {
                handleTranslateError(msg);
            } else if (type === 'backTranslateComplete') {
                handleBackTranslateComplete(msg);
            } else if (type === 'backTranslateError') {
                toast('error', 'Back-translate failed');
            }
        }
        
        function updateWorkerState(id, status, task) {
            const ws = state.workerStates.get(id) || { progress: {} };
            ws.status = status;
            ws.task = task;
            state.workerStates.set(id, ws);
            updateWorkerDots();
        }
        
        async function initWorkers() {
            // Terminate existing
            state.workers.forEach(w => w.terminate());
            state.workers = [];
            state.workerStates.clear();
            state.readyWorkers.clear();
            
            const count = state.config.workerCount;
            
            // Create dots
            const dotsEl = document.getElementById('workerDots');
            dotsEl.innerHTML = '';
            for (let i = 0; i < count; i++) {
                const dot = document.createElement('div');
                dot.className = 'worker-dot';
                dot.id = 'worker-dot-' + i;
                dotsEl.appendChild(dot);
            }
            
            // Create workers
            for (let i = 0; i < count; i++) {
                state.workerStates.set(i, { status: 'loading', task: 'Init...', progress: {} });
                const worker = createWorker(i);
                state.workers.push(worker);
                
                // Stagger worker initialization to avoid overwhelming
                setTimeout(() => {
                    worker.postMessage({ type: 'init', data: { workerId: i, model: state.config.whisperModel } });
                }, i * 500);
            }
            
            updateWorkerDots();
        }
        
        function getAvailableWorker() {
            for (let i = 0; i < state.workers.length; i++) {
                const ws = state.workerStates.get(i);
                if (ws?.status === 'ready' && state.readyWorkers.has(i)) return i;
            }
            return null;
        }
        
        function updateWorkerDots() {
            for (const [id, ws] of state.workerStates) {
                const dot = document.getElementById('worker-dot-' + id);
                if (dot) dot.className = 'worker-dot ' + ws.status;
            }
            
            const ready = state.readyWorkers.size;
            const total = state.workers.length;
            document.getElementById('workerStatusText').textContent = 
                ready === total && total > 0 ? total + ' workers' : ready + '/' + total + ' ready';
        }
        
        function checkAllWorkersReady() {
            if (state.readyWorkers.size === state.config.workerCount) {
                if (!state.config.setupComplete) {
                    state.config.setupComplete = true;
                    storage.saveConfig(state.config);
                    document.getElementById('setupSummary').textContent = 
                        state.config.workerCount + ' workers ‚Ä¢ Whisper ' + state.config.whisperModel;
                    state.setupStep = 4;
                    updateSetupUI();
                }
            }
        }

        // ============================================
        // AUDIO PROCESSING
        // ============================================
        
        async function ingestFile(file) {
            showIngest();
            
            try {
                // Read
                updateIngest('Reading file...', 0, '0%');
                const buffer = await new Promise((res, rej) => {
                    const reader = new FileReader();
                    reader.onprogress = (e) => {
                        if (e.lengthComputable) {
                            const pct = (e.loaded / e.total) * 30;
                            updateIngest('Reading...', pct, formatBytes(e.loaded) + ' / ' + formatBytes(e.total));
                        }
                    };
                    reader.onload = () => res(reader.result);
                    reader.onerror = () => rej(reader.error);
                    reader.readAsArrayBuffer(file);
                });
                
                // Decode
                updateIngest('Decoding audio...', 30, 'Please wait...');
                const ctx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
                const audioBuffer = await ctx.decodeAudioData(buffer.slice(0));
                
                updateIngest('Processing...', 60, '');
                
                // Extract mono
                const length = audioBuffer.length;
                const mono = new Float32Array(length);
                if (audioBuffer.numberOfChannels === 1) {
                    audioBuffer.copyFromChannel(mono, 0);
                } else {
                    const left = new Float32Array(length), right = new Float32Array(length);
                    audioBuffer.copyFromChannel(left, 0);
                    audioBuffer.copyFromChannel(right, 1);
                    for (let i = 0; i < length; i++) mono[i] = (left[i] + right[i]) / 2;
                }
                
                // Resample if needed
                let audio = mono;
                if (audioBuffer.sampleRate !== SAMPLE_RATE) {
                    const ratio = audioBuffer.sampleRate / SAMPLE_RATE;
                    const newLen = Math.round(mono.length / ratio);
                    audio = new Float32Array(newLen);
                    for (let i = 0; i < newLen; i++) {
                        const idx = i * ratio, lo = Math.floor(idx);
                        audio[i] = mono[lo] * (1 - (idx - lo)) + mono[Math.min(lo + 1, mono.length - 1)] * (idx - lo);
                    }
                }
                
                // Create chunks
                updateIngest('Creating chunks...', 80, '');
                const chunkLen = CHUNK_SEC * SAMPLE_RATE;
                const totalChunks = Math.ceil(audio.length / chunkLen);
                const chunks = [];
                
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * chunkLen;
                    const end = Math.min(start + chunkLen, audio.length);
                    chunks.push({
                        index: i,
                        startTime: start / SAMPLE_RATE,
                        endTime: end / SAMPLE_RATE,
                        audioData: Array.from(audio.slice(start, end))
                    });
                }
                
                // Create session
                updateIngest('Creating session...', 90, '');
                await storage.cleanupOld();
                
                const now = new Date();
                const session = {
                    id: 'sess_' + now.getTime(),
                    name: 'Session',
                    fileName: file.name,
                    fileSize: file.size,
                    duration: audio.length / SAMPLE_RATE,
                    createdAt: now.toISOString(),
                    totalChunks: totalChunks,
                    transcribedChunks: 0,
                    translatedChunks: 0,
                    status: 'created'
                };
                
                await storage.put('sessions', session);
                
                // Store chunks
                for (const chunk of chunks) {
                    await storage.saveChunk({
                        sessionId: session.id,
                        index: chunk.index,
                        startTime: chunk.startTime,
                        endTime: chunk.endTime,
                        audioData: chunk.audioData,
                        transcript: null,
                        transcriptLang: null,
                        translation: null,
                        translationLang: null,
                        backTranslation: null,
                        status: 'pending',
                        filtered: false,
                        filterReason: null
                    });
                }
                
                updateIngest('Complete!', 100, '');
                hideIngest();
                
                await refreshSessions();
                await loadSession(session.id);
                startProcessing();
                
            } catch (error) {
                console.error('Ingest error:', error);
                hideIngest();
                toast('error', 'Failed to process: ' + error.message);
            }
        }
        
        // ============================================
        // PROCESSING
        // ============================================
        
        async function startProcessing() {
            if (!state.currentSession) return;
            if (state.readyWorkers.size === 0) { toast('error', 'No workers ready'); return; }
            
            state.isProcessing = true;
            showProgress();
            
            // Build queues
            const chunks = await storage.getChunksForSession(state.currentSession.id);
            state.transcribeQueue = [];
            state.translateQueue = [];
            
            for (const chunk of chunks) {
                state.chunks.set(chunk.index, chunk);
                if (chunk.status === 'pending' || chunk.status === 'error') {
                    state.transcribeQueue.push(chunk.index);
                } else if (chunk.status === 'transcribed' && !chunk.filtered && !chunk.translation) {
                    state.translateQueue.push(chunk.index);
                }
            }
            
            updateStats();
            renderChunks();
            processNext();
        }
        
        function stopProcessing() {
            state.isProcessing = false;
            toast('info', 'Paused');
        }
        
        function processNext() {
            if (!state.isProcessing) return;
            
            while (true) {
                const workerId = getAvailableWorker();
                if (workerId === null) break;
                
                if (state.transcribeQueue.length > 0) {
                    const idx = state.transcribeQueue.shift();
                    sendTranscribe(workerId, idx);
                } else if (state.translateQueue.length > 0) {
                    const idx = state.translateQueue.shift();
                    sendTranslate(workerId, idx);
                } else {
                    break;
                }
            }
            
            // Check complete
            if (state.transcribeQueue.length === 0 && state.translateQueue.length === 0) {
                let working = false;
                for (const ws of state.workerStates.values()) {
                    if (ws.status === 'working') { working = true; break; }
                }
                if (!working) {
                    state.isProcessing = false;
                    toast('success', 'Complete!');
                }
            }
        }
        
        function sendTranscribe(workerId, chunkIndex) {
            const chunk = state.chunks.get(chunkIndex);
            if (!chunk) return;
            
            updateWorkerState(workerId, 'working', '#' + (chunkIndex + 1));
            state.workers[workerId].postMessage({
                type: 'transcribe',
                data: {
                    sessionId: state.currentSession.id,
                    chunkIndex,
                    audioData: chunk.audioData,
                    startTime: chunk.startTime,
                    endTime: chunk.endTime
                }
            });
        }
        
        function sendTranslate(workerId, chunkIndex) {
            const chunk = state.chunks.get(chunkIndex);
            if (!chunk?.transcript) return;
            
            updateWorkerState(workerId, 'working', 'T#' + (chunkIndex + 1));
            state.workers[workerId].postMessage({
                type: 'translate',
                data: {
                    sessionId: state.currentSession.id,
                    chunkIndex,
                    text: chunk.transcript,
                    sourceLang: chunk.transcriptLang
                }
            });
        }
        
        async function handleChunkComplete(msg) {
            if (msg.sessionId !== state.currentSession?.id) return;
            
            const chunk = state.chunks.get(msg.chunkIndex);
            if (!chunk) return;
            
            chunk.transcript = msg.result.transcript;
            chunk.transcriptLang = msg.result.transcriptLang;
            chunk.filtered = msg.result.filtered;
            chunk.filterReason = msg.result.filterReason;
            chunk.status = msg.result.filtered ? 'filtered' : 'transcribed';
            
            await storage.saveChunk(chunk);
            
            state.stats.transcribed++;
            if (msg.result.filtered) state.stats.filtered++;
            
            if (!msg.result.filtered && msg.result.transcript) {
                state.translateQueue.push(msg.chunkIndex);
            }
            
            updateChunkUI(msg.chunkIndex);
            updateStats();
            updateWorkerState(msg.workerId, 'ready', 'Ready');
            processNext();
        }
        
        async function handleChunkError(msg) {
            if (msg.sessionId !== state.currentSession?.id) return;
            
            const chunk = state.chunks.get(msg.chunkIndex);
            if (chunk) {
                chunk.status = 'error';
                chunk.error = msg.error;
                await storage.saveChunk(chunk);
            }
            
            state.stats.errors++;
            updateChunkUI(msg.chunkIndex);
            updateStats();
            updateWorkerState(msg.workerId, 'ready', 'Ready');
            processNext();
        }
        
        async function handleTranslateComplete(msg) {
            if (msg.sessionId !== state.currentSession?.id) return;
            
            const chunk = state.chunks.get(msg.chunkIndex);
            if (!chunk) return;
            
            chunk.translation = msg.result.translation;
            chunk.translationLang = msg.result.translationLang;
            chunk.status = 'complete';
            
            await storage.saveChunk(chunk);
            
            state.stats.translated++;
            updateChunkUI(msg.chunkIndex);
            updateStats();
            updateWorkerState(msg.workerId, 'ready', 'Ready');
            processNext();
        }
        
        function handleTranslateError(msg) {
            console.warn('Translate error:', msg.error);
            updateWorkerState(msg.workerId, 'ready', 'Ready');
            processNext();
        }
        
        async function handleBackTranslateComplete(msg) {
            if (msg.sessionId !== state.currentSession?.id) return;
            
            const chunk = state.chunks.get(msg.chunkIndex);
            if (chunk) {
                chunk.backTranslation = msg.result.backTranslation;
                await storage.saveChunk(chunk);
                updateChunkUI(msg.chunkIndex);
            }
            
            updateWorkerState(msg.workerId, 'ready', 'Ready');
            toast('success', 'Back-translation done');
        }
        
        // Redo actions
        async function retranscribe(chunkIndex) {
            const chunk = state.chunks.get(chunkIndex);
            if (!chunk) return;
            
            chunk.transcript = null;
            chunk.transcriptLang = null;
            chunk.translation = null;
            chunk.translationLang = null;
            chunk.backTranslation = null;
            chunk.filtered = false;
            chunk.filterReason = null;
            chunk.status = 'pending';
            
            await storage.saveChunk(chunk);
            state.transcribeQueue.push(chunkIndex);
            state.isProcessing = true;
            updateChunkUI(chunkIndex);
            processNext();
        }
        
        async function retranslate(chunkIndex) {
            const chunk = state.chunks.get(chunkIndex);
            if (!chunk?.transcript) return;
            
            chunk.translation = null;
            chunk.translationLang = null;
            chunk.backTranslation = null;
            chunk.status = 'transcribed';
            
            await storage.saveChunk(chunk);
            state.translateQueue.push(chunkIndex);
            state.isProcessing = true;
            updateChunkUI(chunkIndex);
            processNext();
        }
        
        async function backTranslate(chunkIndex) {
            const chunk = state.chunks.get(chunkIndex);
            if (!chunk?.translation) return;
            
            const workerId = getAvailableWorker();
            if (workerId === null) { toast('warning', 'No workers available'); return; }
            
            updateWorkerState(workerId, 'working', 'BT#' + (chunkIndex + 1));
            state.workers[workerId].postMessage({
                type: 'backTranslate',
                data: {
                    sessionId: state.currentSession.id,
                    chunkIndex,
                    text: chunk.translation,
                    sourceLang: chunk.transcriptLang
                }
            });
        }
        
        async function redoBackTranslate(chunkIndex) {
            const chunk = state.chunks.get(chunkIndex);
            if (chunk) {
                chunk.backTranslation = null;
                await storage.saveChunk(chunk);
                updateChunkUI(chunkIndex);
            }
            backTranslate(chunkIndex);
        }

        // ============================================
        // SESSION MANAGEMENT
        // ============================================
        
        async function loadSession(sessionId) {
            const session = await storage.get('sessions', sessionId);
            if (!session) return;
            
            state.currentSession = session;
            state.chunks.clear();
            
            const chunks = await storage.getChunksForSession(sessionId);
            for (const c of chunks) state.chunks.set(c.index, c);
            
            state.stats = {
                total: session.totalChunks,
                transcribed: chunks.filter(c => c.transcript !== null || c.filtered).length,
                translated: chunks.filter(c => c.translation !== null).length,
                filtered: chunks.filter(c => c.filtered).length,
                errors: chunks.filter(c => c.status === 'error').length
            };
            
            renderSessionView();
            updateSessionInList();
            
            if (session.status !== 'complete' && state.stats.transcribed < state.stats.total) {
                showProgress();
            }
        }
        
        async function deleteSessionById(sessionId) {
            if (state.currentSession?.id === sessionId) {
                state.currentSession = null;
                state.chunks.clear();
                renderEmpty();
            }
            await storage.deleteSession(sessionId);
            await refreshSessions();
            toast('success', 'Deleted');
        }
        
        async function renameSession(sessionId, name) {
            const session = await storage.get('sessions', sessionId);
            if (session) {
                session.name = name || 'Session';
                await storage.put('sessions', session);
                if (state.currentSession?.id === sessionId) state.currentSession.name = session.name;
                await refreshSessions();
            }
        }
        
        async function refreshSessions() {
            const sessions = await storage.getAllSessions();
            renderSessionsList(sessions);
            document.getElementById('sessionCount').textContent = sessions.length;
        }
        
        // ============================================
        // UI RENDERING
        // ============================================
        
        function renderSessionsList(sessions) {
            const el = document.getElementById('sessionsList');
            el.innerHTML = '';
            
            for (const s of sessions) {
                const card = document.createElement('div');
                card.className = 'session-card' + (state.currentSession?.id === s.id ? ' active' : '');
                card.dataset.id = s.id;
                
                const d = new Date(s.createdAt);
                const dots = 6;
                const filled = Math.round((s.translatedChunks / s.totalChunks) * dots) || 0;
                let dotsHtml = '';
                for (let i = 0; i < dots; i++) dotsHtml += '<div class="session-dot' + (i < filled ? ' filled' : '') + '"></div>';
                
                card.innerHTML = `
                    <div class="session-card-date">${d.toLocaleDateString('en-US', {month:'short',day:'numeric'})} ${d.toLocaleTimeString('en-US', {hour:'2-digit',minute:'2-digit'})}</div>
                    <div class="session-card-name">${escapeHtml(s.name)}</div>
                    <div class="session-card-progress">${dotsHtml}</div>
                    <button class="session-card-delete">√ó</button>
                `;
                
                card.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('session-card-delete')) loadSession(s.id);
                });
                
                card.querySelector('.session-card-delete').addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (confirm('Delete?')) deleteSessionById(s.id);
                });
                
                el.appendChild(card);
            }
        }
        
        function updateSessionInList() {
            if (!state.currentSession) return;
            const card = document.querySelector('.session-card[data-id="' + state.currentSession.id + '"]');
            if (!card) return;
            
            const dots = card.querySelectorAll('.session-dot');
            const filled = Math.round((state.stats.translated / state.stats.total) * dots.length) || 0;
            dots.forEach((d, i) => d.className = 'session-dot' + (i < filled ? ' filled' : ''));
        }
        
        function renderEmpty() {
            const el = document.getElementById('contentArea');
            el.innerHTML = `
                <div class="empty-state">
                    <div class="empty-icon">üéôÔ∏è</div>
                    <div class="empty-title">No session selected</div>
                    <div class="drop-zone" id="dropZone">
                        <div>üìÇ Drop audio file here</div>
                        <div style="font-size:0.7rem;margin-top:0.25rem;color:var(--text-muted);">M4A, MP3, WAV, OGG, FLAC</div>
                    </div>
                </div>
            `;
            setupDropZone(document.getElementById('dropZone'));
        }
        
        function renderSessionView() {
            if (!state.currentSession) { renderEmpty(); return; }
            const s = state.currentSession;
            
            const el = document.getElementById('contentArea');
            el.innerHTML = `
                <div class="content-header">
                    <div class="content-header-left">
                        <button class="sidebar-toggle" id="sidebarToggle">‚ò∞</button>
                        <div class="session-info">
                            <input type="text" class="session-name-input" id="sessionNameInput" value="${escapeHtml(s.name)}">
                            <div class="session-meta">${escapeHtml(s.fileName)} ‚Ä¢ ${formatDuration(s.duration)} ‚Ä¢ ${s.totalChunks} chunks</div>
                        </div>
                    </div>
                    <div class="content-actions">
                        <button class="btn btn-secondary btn-sm" id="exportBtn">üì§ Export</button>
                        <button class="btn btn-primary btn-sm" id="processBtn">${state.isProcessing ? '‚èπ Stop' : '‚ñ∂Ô∏è Process'}</button>
                    </div>
                </div>
                <div class="transcript-container">
                    <div class="transcript-header">
                        <div class="column-header">
                            <span class="column-title">Original</span>
                            <button class="btn btn-ghost btn-xs" id="copyOrigBtn">üìã Copy All</button>
                        </div>
                        <div class="column-header">
                            <span class="column-title">Translation</span>
                            <button class="btn btn-ghost btn-xs" id="copyTransBtn">üìã Copy All</button>
                        </div>
                    </div>
                    <div class="transcript-scroll" id="transcriptScroll"></div>
                </div>
            `;
            
            document.getElementById('sidebarToggle').addEventListener('click', () => document.getElementById('sidebar').classList.toggle('collapsed'));
            document.getElementById('sessionNameInput').addEventListener('blur', (e) => renameSession(s.id, e.target.value.trim()));
            document.getElementById('sessionNameInput').addEventListener('keydown', (e) => { if (e.key === 'Enter') e.target.blur(); });
            document.getElementById('processBtn').addEventListener('click', () => {
                if (state.isProcessing) stopProcessing(); else startProcessing();
                document.getElementById('processBtn').textContent = state.isProcessing ? '‚èπ Stop' : '‚ñ∂Ô∏è Process';
            });
            document.getElementById('exportBtn').addEventListener('click', showExport);
            document.getElementById('copyOrigBtn').addEventListener('click', copyOriginal);
            document.getElementById('copyTransBtn').addEventListener('click', copyTranslation);
            
            renderChunks();
        }
        
        function renderChunks() {
            const el = document.getElementById('transcriptScroll');
            if (!el) return;
            el.innerHTML = '';
            
            const sorted = Array.from(state.chunks.values()).sort((a, b) => a.index - b.index);
            for (const chunk of sorted) el.appendChild(createChunkRow(chunk));
        }
        
        function createChunkRow(chunk) {
            const row = document.createElement('div');
            row.className = 'chunk-row' + (chunk.filtered ? ' filtered' : '');
            row.id = 'chunk-' + chunk.index;
            
            const id = String(chunk.index + 1).padStart(3, '0');
            const time = formatTime(chunk.startTime) + ' ‚Üí ' + formatTime(chunk.endTime);
            
            // Original cell
            let origContent = '';
            if (chunk.filtered) {
                origContent = '<div class="chunk-text filtered">‚ö†Ô∏è ' + (chunk.filterReason || 'Filtered') + '</div>';
            } else if (chunk.transcript) {
                origContent = '<div class="chunk-text">' + escapeHtml(chunk.transcript) + '</div>' +
                    '<div class="chunk-actions"><button class="chunk-action" data-action="retranscribe" data-idx="' + chunk.index + '">üîÑ Redo</button></div>';
            } else if (chunk.status === 'error') {
                origContent = '<div class="chunk-text filtered">‚ùå Error</div>';
            } else {
                origContent = '<div class="chunk-text empty">Pending...</div>';
            }
            
            // Translation cell
            let transContent = '';
            if (chunk.filtered) {
                transContent = '<div class="chunk-text empty">‚Äî</div>';
            } else if (chunk.translation) {
                const flag = chunk.translationLang === 'th' ? 'üáπüá≠' : 'üá∫üá∏';
                transContent = '<div class="chunk-text">' + flag + ' ' + escapeHtml(chunk.translation) + '</div>' +
                    '<div class="chunk-actions">' +
                        '<button class="chunk-action" data-action="retranslate" data-idx="' + chunk.index + '">üîÑ Redo</button>' +
                        '<button class="chunk-action" data-action="backtranslate" data-idx="' + chunk.index + '">‚Ü©Ô∏è Back</button>' +
                    '</div>';
                
                if (chunk.backTranslation) {
                    const bflag = chunk.transcriptLang === 'th' ? 'üáπüá≠' : 'üá∫üá∏';
                    transContent += '<div class="back-translation">' +
                        '<div class="back-translation-label"><span>‚Ü©Ô∏è Back-translation</span>' +
                        '<button class="chunk-action" data-action="redoback" data-idx="' + chunk.index + '">üîÑ</button></div>' +
                        '<div class="back-translation-text">' + bflag + ' ' + escapeHtml(chunk.backTranslation) + '</div></div>';
                }
            } else if (chunk.transcript && !chunk.filtered) {
                transContent = '<div class="chunk-text empty">Translating...</div>';
            } else {
                transContent = '<div class="chunk-text empty">‚Äî</div>';
            }
            
            row.innerHTML = `
                <div class="chunk-cell">
                    <div class="chunk-header">
                        <span class="chunk-id">${id}</span>
                        <span class="chunk-time">${time}</span>
                        ${chunk.transcriptLang ? '<span class="chunk-lang ' + chunk.transcriptLang + '">' + (chunk.transcriptLang === 'th' ? 'üáπüá≠ TH' : 'üá∫üá∏ EN') + '</span>' : ''}
                        <button class="chunk-play" data-action="play" data-idx="${chunk.index}">‚ñ∂</button>
                    </div>
                    ${origContent}
                </div>
                <div class="chunk-cell">
                    <div class="chunk-header">
                        ${chunk.translationLang ? '<span class="chunk-lang ' + chunk.translationLang + '">' + (chunk.translationLang === 'th' ? 'üáπüá≠ TH' : 'üá∫üá∏ EN') + '</span>' : ''}
                    </div>
                    ${transContent}
                </div>
            `;
            
            row.querySelectorAll('[data-action]').forEach(btn => btn.addEventListener('click', handleAction));
            return row;
        }
        
        function updateChunkUI(idx) {
            const chunk = state.chunks.get(idx);
            if (!chunk) return;
            const existing = document.getElementById('chunk-' + idx);
            if (existing) existing.replaceWith(createChunkRow(chunk));
        }
        
        function handleAction(e) {
            const action = e.target.dataset.action;
            const idx = parseInt(e.target.dataset.idx);
            
            if (action === 'play') playChunk(idx);
            else if (action === 'retranscribe') retranscribe(idx);
            else if (action === 'retranslate') retranslate(idx);
            else if (action === 'backtranslate') backTranslate(idx);
            else if (action === 'redoback') redoBackTranslate(idx);
        }
            }
        }
        
        function updateSetupWorkerUI(workerId) {
            const ws = state.workerStates.get(workerId);
            if (!ws) return;
            
            const card = document.getElementById('setup-worker-' + workerId);
            const progress = document.getElementById('setup-progress-' + workerId);
            const task = document.getElementById('setup-task-' + workerId);
            
            if (!card) return;
            
            card.className = 'setup-worker-card ' + ws.status;
            card.querySelector('.setup-worker-status').textContent = 
                ws.status === 'ready' ? 'Ready' : ws.status === 'error' ? 'Error' : 'Loading...';
            
            if (progress && ws.progress) {
                const whisper = ws.progress['whisper'] || 0;
                const thEn = ws.progress['th-en'] || 0;
                const enTh = ws.progress['en-th'] || 0;
                let pct = 0;
                if (whisper > 0) pct = whisper * 0.4;
                if (thEn > 0) pct = 40 + thEn * 0.3;
                if (enTh > 0) pct = 70 + enTh * 0.3;
                progress.style.width = pct + '%';
            }
            
            if (task) task.textContent = ws.task || '';
        }
        
        // ============================================
        // PROGRESS & INGEST UI
        // ============================================
        
        function showProgress() { document.getElementById('progressBar').classList.add('visible'); }
        function hideProgress() { document.getElementById('progressBar').classList.remove('visible'); }
        
        function updateStats() {
            const chunks = Array.from(state.chunks.values());
            state.stats.total = chunks.length;
            state.stats.transcribed = chunks.filter(c => c.transcript !== null || c.filtered).length;
            state.stats.translated = chunks.filter(c => c.translation !== null).length;
            state.stats.filtered = chunks.filter(c => c.filtered).length;
            
            const total = state.stats.total;
            const transcribed = state.stats.transcribed;
            const toTranslate = transcribed - state.stats.filtered;
            const translated = state.stats.translated;
            
            const tPct = total > 0 ? (transcribed / total) * 50 : 0;
            const trPct = toTranslate > 0 ? (translated / toTranslate) * 50 : 0;
            
            document.getElementById('progressFillTranscribe').style.width = tPct + '%';
            document.getElementById('progressFillTranslate').style.width = trPct + '%';
            document.getElementById('progressTranscribe').textContent = 'Transcribe: ' + transcribed + '/' + total;
            document.getElementById('progressTranslate').textContent = 'Translate: ' + translated + '/' + toTranslate;
            
            document.getElementById('progressLabel').textContent = 
                transcribed < total ? 'Transcribing...' : translated < toTranslate ? 'Translating...' : 'Complete';
        }
        
        function showIngest() { document.getElementById('ingestOverlay').classList.remove('hidden'); }
        function hideIngest() { document.getElementById('ingestOverlay').classList.add('hidden'); }
        
        function updateIngest(status, pct, detail) {
            document.getElementById('ingestStatus').textContent = status;
            document.getElementById('ingestProgressFill').style.width = pct + '%';
            document.getElementById('ingestDetail').textContent = detail;
        }
        
        // ============================================
        // UTILITIES
        // ============================================
        
        function toast(type, msg) {
            const el = document.createElement('div');
            el.className = 'toast ' + type;
            el.textContent = (type === 'success' ? '‚úì' : type === 'error' ? '‚úï' : '‚Ñπ') + ' ' + msg;
            document.getElementById('toastContainer').appendChild(el);
            setTimeout(() => { el.style.opacity = '0'; setTimeout(() => el.remove(), 300); }, 3000);
        }
        
        function formatBytes(b) {
            if (b < 1024) return b + ' B';
            if (b < 1024 * 1024) return (b / 1024).toFixed(1) + ' KB';
            return (b / (1024 * 1024)).toFixed(1) + ' MB';
        }
        
        function formatTime(s) {
            const m = Math.floor(s / 60);
            return m + ':' + Math.floor(s % 60).toString().padStart(2, '0');
        }
        
        function formatDuration(s) {
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const sec = Math.floor(s % 60);
            return h > 0 ? h + ':' + m.toString().padStart(2, '0') + ':' + sec.toString().padStart(2, '0') 
                         : m + ':' + sec.toString().padStart(2, '0');
        }
        
        function escapeHtml(t) {
            const d = document.createElement('div');
            d.textContent = t;
            return d.innerHTML;
        }
        
        function setupDropZone(el) {
            if (!el) return;
            el.addEventListener('click', () => document.getElementById('fileInput').click());
            el.addEventListener('dragover', (e) => { e.preventDefault(); el.classList.add('dragover'); });
            el.addEventListener('dragleave', () => el.classList.remove('dragover'));
            el.addEventListener('drop', (e) => {
                e.preventDefault();
                el.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file?.type.startsWith('audio/') || file?.name.match(/\.(m4a|mp3|wav|ogg|flac)$/i)) {
                    ingestFile(file);
                } else {
                    toast('error', 'Please drop an audio file');
                }
            });
        }
        
        // ============================================
        // EVENT LISTENERS
        // ============================================
        
        function setupEvents() {
            document.getElementById('fileInput').addEventListener('change', (e) => {
                if (e.target.files[0]) ingestFile(e.target.files[0]);
                e.target.value = '';
            });
            
            document.getElementById('newSessionBtn').addEventListener('click', () => document.getElementById('fileInput').click());
            
            document.getElementById('restartBtn').addEventListener('click', async () => {
                if (state.isProcessing) { toast('warning', 'Stop processing first'); return; }
                toast('info', 'Restarting workers...');
                await initWorkers();
            });
            
            document.getElementById('settingsBtn').addEventListener('click', () => {
                state.config.setupComplete = false;
                state.setupStep = 1;
                updateSetupUI();
                document.getElementById('setupOverlay').classList.remove('hidden');
            });
            
            document.getElementById('setupNextBtn').addEventListener('click', async () => {
                if (state.setupStep === 1) {
                    state.setupStep = 2;
                    updateSetupEstimate();
                } else if (state.setupStep === 2) {
                    state.config.workerCount = parseInt(document.getElementById('setupWorkerSlider').value);
                    state.setupStep = 3;
                    updateSetupUI();
                    createSetupWorkers();
                    await initWorkers();
                } else if (state.setupStep === 4) {
                    document.getElementById('setupOverlay').classList.add('hidden');
                }
                updateSetupUI();
            });
            
            document.getElementById('setupBackBtn').addEventListener('click', () => {
                if (state.setupStep > 1 && state.setupStep < 3) { state.setupStep--; updateSetupUI(); }
            });
            
            document.querySelectorAll('.setup-option').forEach(opt => {
                opt.addEventListener('click', () => {
                    opt.closest('.setup-step').querySelectorAll('.setup-option').forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                    if (opt.closest('.setup-step').dataset.step === '1') {
                        state.config.whisperModel = opt.dataset.value;
                        updateSetupEstimate();
                    }
                });
            });
            
            document.getElementById('setupWorkerSlider').addEventListener('input', updateSetupEstimate);
            
            document.body.addEventListener('dragover', (e) => e.preventDefault());
            document.body.addEventListener('drop', (e) => {
                e.preventDefault();
                const file = e.dataTransfer.files[0];
                if (file?.type.startsWith('audio/') || file?.name.match(/\.(m4a|mp3|wav|ogg|flac)$/i)) {
                    ingestFile(file);
                }
            });
        }
        
        // ============================================
        // INIT
        // ============================================
        
        async function init() {
            try {
                await storage.init();
                const config = await storage.getConfig();
                state.config = { ...state.config, ...config };
                
                setupEvents();
                
                if (state.config.setupComplete) {
                    document.getElementById('setupOverlay').classList.add('hidden');
                    await initWorkers();
                    await refreshSessions();
                    
                    const sessions = await storage.getAllSessions();
                    if (sessions.length > 0) await loadSession(sessions[0].id);
                    else renderEmpty();
                } else {
                    updateSetupUI();
                    updateSetupEstimate();
                }
            } catch (error) {
                console.error('Init error:', error);
                toast('error', 'Failed to initialize');
            }
        }
        
        init();
    </script>
</body>
</html>
