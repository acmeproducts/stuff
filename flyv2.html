<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>CoreNav Universe — Streamed Quadrants & Habitats (v7)</title>
<style>
  :root{
    --bg:#06070a; --fg:#e7e7e7; --line:rgba(255,255,255,.15);
    --panel-bg:rgba(0,0,0,.70); --radius:12px; --accent:#86aaf0;
  }
  html,body{height:100%;margin:0;overflow:hidden;background:var(--bg);color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial}
  #webgl{position:fixed;inset:0;width:100%;height:100%;display:block;touch-action:none}
  #loading{position:fixed;inset:0;background:#000;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:10;transition:opacity .35s}
  #loading.hidden{opacity:0;pointer-events:none}
  #progressbar{width:260px;height:4px;background:#333;margin-top:10px;border-radius:999px;overflow:hidden}
  #progress{width:0%;height:100%;background:#fff;transition:width .18s}
  #error{display:none;color:#fff;background:#8a0000;padding:10px 14px;border-radius:8px;border:1px solid #ff8a8a}
  #handle{position:fixed;top:0;left:50%;transform:translateX(-50%);border:0;background:transparent;padding:8px;z-index:6}
  #handle .bar{width:68px;height:4px;border-radius:999px;background:rgba(255,255,255,.65)}
  #panel{position:fixed;inset:0 0 auto 0;max-width:1000px;margin:0 auto;background:var(--panel-bg);border:1px solid var(--line);
         border-bottom-left-radius:var(--radius);border-bottom-right-radius:var(--radius);transform:translateY(-100%);
         transition:transform .22s cubic-bezier(.2,.8,.2,1);backdrop-filter:blur(5px);z-index:5}
  #panel.open{transform:translateY(0)}
  #panel .content{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px;padding:10px;max-height:92vh;overflow:auto}
  fieldset{border:1px solid var(--line);border-radius:10px}
  legend{padding:0 6px;color:#d0d0d0}
  label{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;font-size:13px;margin:6px 8px}
  input[type=range]{width:160px}
  select{background:#10131a;color:var(--fg);border:1px solid #2b2f3a;border-radius:8px;padding:6px 8px}
  button{background:#141821;color:var(--fg);border:1px solid #2b2f3a;border-radius:10px;padding:8px 12px;cursor:pointer}
  #dirBtn{position:fixed;bottom:14px;right:14px;z-index:6;padding:8px 12px;border-radius:999px;border:1px solid var(--line);
          background:rgba(0,0,0,.55);color:var(--fg);font-size:12px}
  #turboHint{position:fixed;bottom:14px;left:14px;z-index:6;padding:8px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.12);
             background:rgba(0,0,0,.35);color:rgba(255,255,255,.7);font-size:12px}
  #touchDot{position:fixed;width:54px;height:54px;border-radius:50%;border:2px solid rgba(255,60,60,.9);
            background:radial-gradient(rgba(255,60,60,.35), rgba(255,60,60,.08) 60%, transparent 70%);
            pointer-events:none;opacity:0;transform:translate(-50%,-50%);transition:opacity .12s}
</style>
</head>
<body>
<div id="loading">
  <div id="error"></div>
  <p>Preparing sector…</p>
  <div id="progressbar"><div id="progress"></div></div>
</div>
<canvas id="webgl"></canvas>

<button id="handle" title="Settings"><div class="bar"></div></button>
<div id="panel" aria-hidden="true">
  <div class="content">
    <fieldset><legend>Movement</legend>
      <label><span>Base Speed</span><input id="cfgSpeed" type="range" min="6" max="36" step="1" value="16"></label>
      <label><span>Speed Multiplier (1–10)</span><input id="cfgSpeedMul" type="range" min="1" max="10" step="1" value="1"></label>
      <label><span>Turbo Multiplier</span><input id="cfgTurboMul" type="range" min="1.5" max="6" step="0.1" value="3"></label>
      <label><span>Thrust Ease</span><input id="cfgThrustEase" type="range" min="0.05" max="0.6" step="0.01" value="0.22"></label>
      <label><span>Drag (Linear)</span><input id="cfgDragLin" type="range" min="0.02" max="0.5" step="0.01" value="0.16"></label>
      <label><span>Rudder Gain</span><input id="cfgRudder" type="range" min="0.5" max="3" step="0.1" value="1.4"></label>
      <label><span>Rudder Ramp</span><input id="cfgRudderRamp" type="range" min="0.2" max="3" step="0.1" value="1.2"></label>
      <label><span>Turn Damping</span><input id="cfgTurnDamp" type="range" min="0.02" max="0.6" step="0.01" value="0.18"></label>
      <label><span>Deadzone (px)</span><input id="cfgDeadzone" type="range" min="0" max="60" step="2" value="12"></label>
    </fieldset>
    <fieldset><legend>Visual</legend>
      <label><span>Star Density</span><input id="cfgStarDensity" type="range" min="0.5" max="2.5" step="0.1" value="1.4"></label>
      <label><span>Bloom</span><input id="cfgBloom" type="range" min="0" max="2.5" step="0.05" value="0.3"></label>
      <label><span>Colors</span>
        <select id="cfgColor">
          <option value="fire">Fire</option>
          <option value="neon">Neon</option>
          <option value="nature">Nature</option>
          <option value="rainbow">Rainbow</option>
        </select>
      </label>
      <label><span>Galaxy Particles</span><input id="cfgGalaxyP" type="range" min="3000" max="14000" step="1000" value="8000"></label>
      <label><span>Habitats / tile</span><input id="cfgHabitats" type="range" min="0" max="3" step="1" value="2"></label>
    </fieldset>
  </div>
</div>
<button id="dirBtn" aria-pressed="true">Forward</button>
<div id="turboHint">Hold 3s to Turbo</div>
<div id="touchDot"></div>

<script type="importmap">
{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"}}
</script>
<script type="module">
import * as THREE from "three";
import {EffectComposer} from "three/addons/postprocessing/EffectComposer.js";
import {RenderPass} from "three/addons/postprocessing/RenderPass.js";
import {UnrealBloomPass} from "three/addons/postprocessing/UnrealBloomPass.js";

/* ===== Capability check ===== */
const gl = document.createElement("canvas").getContext("webgl2") || document.createElement("canvas").getContext("webgl");
if (!gl){
  const e = document.getElementById("error");
  e.style.display="block";
  e.textContent = "WebGL is not available in this browser/profile. Enable hardware acceleration or try Chrome/Edge/Safari.";
}

/* ===== Elements & Config ===== */
const canvas = document.getElementById("webgl");
const loading = document.getElementById("loading");
const progress = document.getElementById("progress");
const panel = document.getElementById("panel");
const handle = document.getElementById("handle");
const dirBtn = document.getElementById("dirBtn");
const touchDot = document.getElementById("touchDot");

const CFG = { speedBase:16,speedMul:1,turboMul:3,thrustEase:0.22,dragLin:0.16,rudder:1.4,rudderRamp:1.2,turnDamp:0.18,deadzonePx:12,starDensity:1.4,bloom:0.3,colorMode:"fire",galaxyParticles:8000,habitatsPerTile:2 };

let holding=false, pointerId=null;
let anchorX=0, anchorY=0, curX=0, curY=0;
let holdStart=0, turbo=false, dir=1;
let yaw=0, pitch=0, yawVel=0, pitchVel=0;
let yawAcc=0, pitchAcc=0;
let speed=0;

/* ===== Three.js ===== */
let scene, camera, renderer, composer, bloomPass;
let stars;
const loaded = new Set(); const chunks = new Map();
let originOffset = new THREE.Vector3();
const CELL=1400, INIT_RADIUS=1, RADIUS=1, REBASE=18000;

/* streaming queue */
const pending = new Set();
const buildQueue = [];
let initialTarget = (2*INIT_RADIUS+1)*(2*INIT_RADIUS+1);
let initialBuilt = 0;
const BUILD_BUDGET = 1;          // chunks per frame (safer for low-end)

/* ===== Utils ===== */
function lcg(seed){ let s = seed|0; return ()=> (s = (1664525*s + 1013904223)|0) >>> 0; }
function hash2(ix, iz){ let h = ix*374761393 + iz*668265263; h = (h^(h>>>13))*1274126177; return h|0; }
function rrange(rng,a,b){ return a + (rng()/0xffffffff)*(b-a); }
function rand(a,b){ return a + Math.random()*(b-a); }

/* ===== UI ===== */
function bindUI(){
  const bind = (id, fn)=>{ const el=document.getElementById(id); if(!el) return; el.addEventListener("input", ()=>fn(el.value)); fn(el.value); };
  bind("cfgSpeed", v=> CFG.speedBase = parseFloat(v));
  bind("cfgSpeedMul", v=> CFG.speedMul = parseInt(v,10));
  bind("cfgTurboMul", v=> CFG.turboMul = parseFloat(v));
  bind("cfgThrustEase", v=> CFG.thrustEase = parseFloat(v));
  bind("cfgDragLin", v=> CFG.dragLin = parseFloat(v));
  bind("cfgRudder", v=> CFG.rudder = parseFloat(v));
  bind("cfgRudderRamp", v=> CFG.rudderRamp = parseFloat(v));
  bind("cfgTurnDamp", v=> CFG.turnDamp = parseFloat(v));
  bind("cfgDeadzone", v=> CFG.deadzonePx = parseFloat(v));
  bind("cfgStarDensity", v=> { CFG.starDensity=parseFloat(v); if (stars) reseedStars(); });
  bind("cfgBloom", v=> { CFG.bloom=parseFloat(v); if (bloomPass) bloomPass.strength=CFG.bloom; });
  bind("cfgGalaxyP", v=> { CFG.galaxyParticles=parseInt(v,10); refreshNeighborhood(); });
  bind("cfgHabitats", v=> { CFG.habitatsPerTile=parseInt(v,10); refreshNeighborhood(); });
  const colorSel = document.getElementById("cfgColor"); if (colorSel) colorSel.addEventListener("change", e=>{ CFG.colorMode=e.target.value; refreshNeighborhood(); });
  handle.addEventListener("click", ()=>{ panel.classList.toggle("open"); panel.setAttribute("aria-hidden", String(!panel.classList.contains("open"))); });
  dirBtn.addEventListener("click", ()=>{ dir*=-1; dirBtn.textContent = dir===1 ? "Forward" : "Reverse"; dirBtn.setAttribute("aria-pressed", String(dir===1)); if (navigator.vibrate) navigator.vibrate(12); });
}

/* ===== Input (tap/hold/drag) ===== */
canvas.addEventListener("pointerdown", e=>{
  if (pointerId!==null) return;
  pointerId=e.pointerId; holding=true;
  anchorX=curX=e.clientX; anchorY=curY=e.clientY;
  holdStart=performance.now(); turbo=false; updateTouchDot(e.clientX, e.clientY, false);
  canvas.setPointerCapture(e.pointerId);
  e.preventDefault();
},{passive:false});
canvas.addEventListener("pointermove", e=>{
  if (e.pointerId!==pointerId) return;
  curX=e.clientX; curY=e.clientY;
  if (holding) updateTouchDot(curX, curY, turbo);
  e.preventDefault();
},{passive:false});
function endHold(e){
  if (e.pointerId!==pointerId) return;
  holding=false; pointerId=null; turbo=false; touchDot.style.opacity=0;
  try{ canvas.releasePointerCapture(e.pointerId);}catch{}
  e.preventDefault();
}
canvas.addEventListener("pointerup", endHold, {passive:false});
canvas.addEventListener("pointercancel", endHold, {passive:false});
window.addEventListener("blur", ()=>{ holding=false; pointerId=null; turbo=false; touchDot.style.opacity=0; });

function updateTouchDot(x,y,armed){ touchDot.style.left=x+"px"; touchDot.style.top=y+"px"; touchDot.style.opacity = armed ? 1 : 0.35; }

/* ===== Scene ===== */
function initThree(){
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000000, 0.00012);
  camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 200000);
  camera.position.set(0, 6, 160);
  renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio,2));

  composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), CFG.bloom, 0.4, 0.85);
  composer.addPass(bloomPass);

  const dl=new THREE.DirectionalLight(0xffffff,.65); dl.position.set(1,1,1); scene.add(dl);
  scene.add(new THREE.AmbientLight(0x666666,.75));

  buildStars();

  // queue only center 3x3 gradually
  queueNeighborhood(new THREE.Vector3(), INIT_RADIUS);

  addEventListener("resize", onResize);
}
function onResize(){ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); composer.setSize(innerWidth, innerHeight); }

/* ===== Background stars ===== */
function buildStars(){
  if (stars){ stars.geometry.dispose(); stars.material.dispose(); scene.remove(stars); }
  const count = Math.floor(10000 * CFG.starDensity);
  const positions = new Float32Array(count*3);
  const colors = new Float32Array(count*3);
  const col = new THREE.Color();
  for (let i=0;i<count;i++){
    const r = 2200 * Math.pow(Math.random(), 0.7) + 1400;
    const theta = Math.acos(2*Math.random()-1);
    const phi = 2*Math.PI*Math.random();
    const x = r*Math.sin(theta)*Math.cos(phi);
    const y = r*Math.cos(theta);
    const z = r*Math.sin(theta)*Math.sin(phi);
    positions[i*3]=x; positions[i*3+1]=y; positions[i*3+2]=z;
    const t = Math.random();
    if (t<0.33) col.setHSL(0.58+Math.random()*0.18, 0.6, 0.8);
    else if (t<0.66) col.setHSL(0.08+Math.random()*0.10, 0.7, 0.7);
    else col.setHSL(0.68+Math.random()*0.12, 0.35, 0.85);
    colors[i*3]=col.r; colors[i*3+1]=col.g; colors[i*3+2]=col.b;
  }
  const g = new THREE.BufferGeometry();
  g.setAttribute("position", new THREE.BufferAttribute(positions, 3));
  g.setAttribute("color", new THREE.BufferAttribute(colors, 3));
  const m = new THREE.PointsMaterial({ size: 1.2, sizeAttenuation:true, vertexColors:true, transparent:true, opacity:0.95, depthWrite:false, blending:THREE.AdditiveBlending });
  stars = new THREE.Points(g, m);
  scene.add(stars);
}
function reseedStars(){ buildStars(); }

/* ===== Galaxy + Objects ===== */
function makeSpherePointCloud(radius=420, count=5000, hueBase=0.02){
  const pos = new Float32Array(count*3);
  const col = new Float32Array(count*3);
  const c = new THREE.Color();
  for(let i=0;i<count;i++){
    const u = Math.random(), v = Math.random();
    const theta = Math.acos(2*u-1), phi = 2*Math.PI*v;
    const r = radius * Math.pow(Math.random(), 1.2);
    const x = r*Math.sin(theta)*Math.cos(phi);
    const y = r*Math.cos(theta);
    const z = r*Math.sin(theta)*Math.sin(phi);
    pos[i*3]=x; pos[i*3+1]=y; pos[i*3+2]=z;
    c.setHSL(hueBase+0.1*(i/count),1,0.55);
    col[i*3]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
  }
  const g = new THREE.BufferGeometry();
  g.setAttribute("position", new THREE.BufferAttribute(pos,3));
  g.setAttribute("color", new THREE.BufferAttribute(col,3));
  const m = new THREE.PointsMaterial({ size: 1.3, vertexColors:true, transparent:true, opacity:0.95, depthWrite:false, blending:THREE.AdditiveBlending });
  return new THREE.Points(g, m);
}
function makeGridSphereLines(radius=520, seg=20, color=0x88aaff, opacity=0.14){
  const grp = new THREE.Group();
  const mat = new THREE.LineBasicMaterial({ color, transparent:true, opacity });
  const circle = (r, axis='y', steps=160)=>{
    const pts = [];
    for(let i=0;i<=steps;i++){
      const t = (i/steps)*Math.PI*2;
      if (axis==='y') pts.push(new THREE.Vector3(Math.cos(t)*r,0,Math.sin(t)*r));
      if (axis==='x') pts.push(new THREE.Vector3(0,Math.cos(t)*r,Math.sin(t)*r));
    }
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    return new THREE.Line(geo, mat.clone());
  };
  for(let i=0;i<seg;i++){ const ln=circle(radius,'y'); ln.rotation.y=(i/seg)*Math.PI; grp.add(ln); }
  for(let i=1;i<seg;i++){ const r=Math.sin((i/seg)*Math.PI)*radius; const ln=circle(r,'x'); grp.add(ln); }
  return grp;
}
function makeGalaxy({rng, position, particles=8000, radius=500, arms=3, twist=2.8, thickness=26}){
  const N = Math.max(3000, particles);
  const positions = new Float32Array(N*3);
  const colors = new Float32Array(N*3);
  const col = new THREE.Color();
  for (let i=0;i<N;i++){
    const arm = (rng()%arms);
    const t = (i/N);
    const r = Math.pow(t, 0.75) * radius * (0.85 + (rng()%1000)/1000*0.35);
    const angle = (arm/arms)*Math.PI*2 + t*twist*Math.PI*2 + ((rng()%1000)/1000 - 0.5)*0.25;
    const x = Math.cos(angle)*r + ((rng()%1000)/1000 - 0.5)*thickness;
    const y = ((rng()%1000)/1000 - 0.5) * thickness*0.6;
    const z = Math.sin(angle)*r + ((rng()%1000)/1000 - 0.5)*thickness;
    positions[i*3]=x; positions[i*3+1]=y; positions[i*3+2]=z;
    const u = t;
    if (CFG.colorMode==="fire") col.setHSL(0.02 + 0.10*u, 1.0, 0.55);
    else if (CFG.colorMode==="neon") col.setHSL(0.55 - 0.30*u, 1.0, 0.55);
    else if (CFG.colorMode==="nature") col.setHSL(0.25 + 0.15*u, 0.9, 0.55);
    else col.setHSL(u, 1.0, 0.55);
    colors[i*3]=col.r; colors[i*3+1]=col.g; colors[i*3+2]=col.b;
  }
  const g = new THREE.BufferGeometry();
  g.setAttribute("position", new THREE.BufferAttribute(positions,3));
  g.setAttribute("color", new THREE.BufferAttribute(colors,3));
  const mat = new THREE.PointsMaterial({ size: 1.4, sizeAttenuation:true, vertexColors:true, transparent:true, opacity:0.95, depthWrite:false, blending:THREE.AdditiveBlending });
  const points = new THREE.Points(g, mat);
  const group = new THREE.Group();
  group.add(points);
  group.position.copy(position);

  const shellR = radius*0.42 + rand(-50,50);
  const inner = new THREE.Mesh(new THREE.SphereGeometry(shellR, 32, 24), new THREE.MeshStandardMaterial({ color: 0x5577aa, metalness:0.2, roughness:0.6, emissive:0x334466, emissiveIntensity:0.4 }));
  const inverse = new THREE.Mesh(new THREE.SphereGeometry(shellR*1.35, 32, 24), new THREE.MeshBasicMaterial({ color: 0x88aaff, side: THREE.BackSide, transparent:true, opacity:0.18 }));
  group.add(inner, inverse);

  return group;
}

/* ===== Habitats (parking-friendly) ===== */
function makeHollowSphereHab(radius=100, thickness=12, color=0x88ccff){
  const grp = new THREE.Group(); grp.userData.parking = true;
  const outer = new THREE.Mesh(
    new THREE.SphereGeometry(radius, 48, 36, Math.PI/8, Math.PI*1.75, Math.PI/6, Math.PI*2/3),
    new THREE.MeshStandardMaterial({ color, metalness:0.35, roughness:0.35, emissive:color, emissiveIntensity:0.25 })
  );
  const inner = new THREE.Mesh(
    new THREE.SphereGeometry(radius - thickness, 48, 36, Math.PI/8, Math.PI*1.75, Math.PI/6, Math.PI*2/3),
    new THREE.MeshBasicMaterial({ color: 0x88aaff, side: THREE.BackSide, transparent:true, opacity:0.25 })
  );
  grp.add(outer, inner);
  return grp;
}
function makeRingHab(R=140, r=22, color=0xffcc66){
  const grp = new THREE.Group(); grp.userData.parking = true;
  const ring = new THREE.Mesh(
    new THREE.TorusGeometry(R, r, 20, 96, Math.PI*1.7),
    new THREE.MeshStandardMaterial({ color, metalness:0.25, roughness:0.45, emissive:color, emissiveIntensity:0.18 })
  );
  const innerBack = new THREE.Mesh(
    new THREE.TorusGeometry(R-6, r-6, 10, 64, Math.PI*1.65),
    new THREE.MeshBasicMaterial({ color: 0xffe6aa, side: THREE.BackSide, transparent:true, opacity:0.2 })
  );
  grp.add(ring, innerBack);
  return grp;
}
function makeShellBoxHab(size=180, innerR=70, color=0xff6699){
  const grp = new THREE.Group(); grp.userData.parking = true;
  const box = new THREE.Mesh(new THREE.BoxGeometry(size,size,size), new THREE.MeshBasicMaterial({ color, wireframe:true }));
  const inner = new THREE.Mesh(new THREE.SphereGeometry(innerR, 32, 24), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: color, emissiveIntensity: 0.15, metalness:0.2, roughness:0.5 }));
  grp.add(box, inner);
  return grp;
}

/* ===== Decorations ===== */
function makeDecoSet(rng, center){
  const grp = new THREE.Group();
  const colors = [0xff6ad5,0xff914d,0xff3b3b,0xffd166,0x5ad1ff,0x7dff8a,0x88ccff,0xccffee];
  for(let i=0;i<4;i++){
    const c = colors[i%colors.length];
    const type = rng()%3;
    let m;
    if (type===0){
      m = new THREE.Mesh(new THREE.IcosahedronGeometry(rrange(rng,18,38), 0), new THREE.MeshStandardMaterial({ color:c, metalness:0.25, roughness:0.4 }));
    } else if (type===1){
      m = new THREE.Mesh(new THREE.TorusKnotGeometry(rrange(rng,12,20), rrange(rng,2,5), 80, 12), new THREE.MeshStandardMaterial({ color:c, metalness:0.2, roughness:0.5 }));
    } else {
      m = new THREE.Mesh(new THREE.ConeGeometry(rrange(rng,16,30), rrange(rng,28,60), 12), new THREE.MeshStandardMaterial({ color:c, metalness:0.15, roughness:0.5 }));
    }
    const a = rrange(rng,0,Math.PI*2), d = rrange(rng, 80, 220), h = rrange(rng,-60,60);
    m.position.set(center.x + Math.cos(a)*d, center.y + h, center.z + Math.sin(a)*d);
    grp.add(m);
  }
  return grp;
}

/* ===== Chunked universe (streamed) ===== */
function scheduleChunk(ix, iz){
  const key = ix+","+iz;
  if (loaded.has(key) || pending.has(key)) return;
  pending.add(key);
  buildQueue.push(key);
}
function queueNeighborhood(world, radius){
  const cx = Math.floor(world.x/CELL), cz = Math.floor(world.z/CELL);
  for (let dz=-radius; dz<=radius; dz++) for (let dx=-radius; dx<=radius; dx++) scheduleChunk(cx+dx, cz+dz);
  updateProgress();
}
function buildOneChunk(){
  const key = buildQueue.shift();
  if (!key) return false;
  pending.delete(key);
  if (loaded.has(key)) return true;

  const [ix,iz] = key.split(",").map(n=>parseInt(n,10));
  const rng = lcg(hash2(ix,iz));
  const group = new THREE.Group(); group.userData.key=key;

  const galaxyCount = 2; // lighter than before
  for (let g=0; g<galaxyCount; g++){
    const basePos = new THREE.Vector3((ix + rrange(rng, -0.35, 0.35)) * CELL, rrange(rng, -220, 220), (iz + rrange(rng, -0.35, 0.35)) * CELL);
    const gal = makeGalaxy({ rng, position: basePos, particles: CFG.galaxyParticles, radius: rrange(rng, 360, 520), arms: 3, twist: rrange(rng, 2.2, 3.0), thickness: rrange(rng, 18, 28) });
    group.add(gal);

    // sphere made of stars + grid shell (fly.html feel)
    const globe = makeSpherePointCloud(rrange(rng, 300, 480), Math.floor(2800 + (rng()%3000)), 0.06*(rng()%10));
    const shell = makeGridSphereLines(Math.max(340, Math.random()*120+380), 18, 0x88aaff, 0.13);
    const offset = new THREE.Vector3(rrange(rng,-180,180), rrange(rng,-110,110), rrange(rng,-180,180));
    const globeGroup = new THREE.Group(); globeGroup.position.copy(basePos).add(offset); globeGroup.add(globe); globeGroup.add(shell);
    group.add(globeGroup);

    group.add(makeDecoSet(rng, basePos));
  }

  for (let i=0;i<CFG.habitatsPerTile;i++){
    const kind = rng()%3;
    let hab;
    if (kind===0) hab = makeHollowSphereHab(rrange(rng,90,150), rrange(rng,10,16), 0x88ccff);
    else if (kind===1) hab = makeRingHab(rrange(rng,120,180), rrange(rng,18,26), 0xffcc66);
    else hab = makeShellBoxHab(rrange(rng,140,200), rrange(rng,60,90), 0xff6699);

    const hp = new THREE.Vector3((ix + rrange(rng,-0.45,0.45))*CELL, rrange(rng,-160,160), (iz + rrange(rng,-0.45,0.45))*CELL);
    hab.position.copy(hp);
    hab.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
    group.add(hab);
  }

  scene.add(group);
  chunks.set(key, group);
  loaded.add(key);
  initialBuilt++;
  updateProgress();
  return true;
}
function updateProgress(){
  const totalInit = initialTarget;
  const pct = Math.max(10, Math.min(100, Math.floor((initialBuilt/totalInit)*100)));
  progress.style.width = pct + "%";
  if (initialBuilt >= totalInit) loading.classList.add("hidden");
}
function maintainNeighborhood(){
  const world = camera.position.clone().add(originOffset);
  const cx = Math.floor(world.x/CELL), cz = Math.floor(world.z/CELL);

  // schedule near tiles if not present
  for (let dz=-RADIUS; dz<=RADIUS; dz++) for (let dx=-RADIUS; dx<=RADIUS; dx++){
    scheduleChunk(cx+dx, cz+dz);
  }

  // unload far tiles
  for (const key of Array.from(loaded)){
    const [ix,iz] = key.split(",").map(n=>parseInt(n,10));
    if (Math.abs(ix-cx) > RADIUS || Math.abs(iz-cz) > RADIUS){
      const g = chunks.get(key);
      if (g){
        g.traverse(o=>{ o.geometry?.dispose?.(); if (o.material){ if (Array.isArray(o.material)) o.material.forEach(m=>m.dispose?.()); else o.material.dispose?.(); } });
        scene.remove(g); chunks.delete(key);
      }
      loaded.delete(key);
    }
  }
}
function refreshNeighborhood(){
  for (const key of Array.from(loaded)){
    const g = chunks.get(key);
    if (g){
      g.traverse(o=>{ o.geometry?.dispose?.(); if (o.material){ if (Array.isArray(o.material)) o.material.forEach(m=>m.dispose?.()); else o.material.dispose?.(); } });
      scene.remove(g); chunks.delete(key);
    }
    loaded.delete(key);
  }
  buildQueue.length = 0; pending.clear();
  initialBuilt = 0; updateProgress(); loading.classList.remove("hidden");
  const world = camera.position.clone().add(originOffset);
  queueNeighborhood(world, INIT_RADIUS);
}

/* ===== Movement Loop (ship-like; L/R stable; U/D normal) ===== */
function loop(){
  // stream a few chunks per frame to avoid stalls
  for (let i=0;i<BUILD_BUDGET; i++) if (!buildOneChunk()) break;
  maintainNeighborhood();

  const now = performance.now();
  if (holding && !turbo){
    const heldMs = now - holdStart;
    if (heldMs > 3000){ turbo = true; if (navigator.vibrate) navigator.vibrate([15,30,15]); updateTouchDot(curX, curY, true); }
  }
  if (holding){
    const dx = curX - anchorX, dy = curY - anchorY;
    const mag = Math.hypot(dx, dy);
    const dead = CFG.deadzonePx;
    if (mag > dead){
      const nx = (dx / mag) * ((mag - dead) / Math.max(60, Math.min(innerWidth, innerHeight)*0.33));
      const ny = (dy / mag) * ((mag - dead) / Math.max(60, Math.min(innerWidth, innerHeight)*0.33));
      const held = (now - holdStart) / 1000;
      const ramp = 1 + CFG.rudderRamp * Math.min(1.6, held);
      // left=left, right=right; up=up, down=down
      yawAcc   = (-nx * CFG.rudder) * ramp;
      pitchAcc = (-ny * CFG.rudder) * ramp;
    } else { yawAcc=0; pitchAcc=0; }
  } else { yawAcc=0; pitchAcc=0; }

  // Integrate with damping
  const dt = 1/60;
  const angDrag = CFG.turnDamp;
  yawVel += yawAcc * dt;     yawVel   *= Math.max(0, 1 - angDrag * dt * 60);
  pitchVel += pitchAcc * dt; pitchVel *= Math.max(0, 1 - angDrag * dt * 60);
  yaw   += yawVel * dt;
  pitch += pitchVel * dt;

  // Clamp pitch to avoid LR inversion; wrap yaw
  const CLAMP = Math.PI/2 - 0.01;
  if (pitch >  CLAMP) pitch =  CLAMP;
  if (pitch < -CLAMP) pitch = -CLAMP;
  if (yaw >  Math.PI) yaw -= 2*Math.PI;
  if (yaw < -Math.PI) yaw += 2*Math.PI;

  // Thrust with ease-in and drag; reverse via toggle
  const targetSpeed = holding ? (CFG.speedBase * CFG.speedMul * (turbo?CFG.turboMul:1) * dir) : 0;
  const ease = CFG.thrustEase;
  speed += (targetSpeed - speed) * (1 - Math.exp(-(ease*60)*dt));
  if (!holding){ speed *= Math.max(0, 1 - CFG.dragLin * dt * 60); }
  const eul = new THREE.Euler(pitch, yaw, 0, "YXZ");
  const forward = new THREE.Vector3(0,0,-1).applyEuler(eul);
  camera.position.addScaledVector(forward, speed * dt);

  // World origin rebasing
  if (camera.position.length() > REBASE){
    originOffset.add(camera.position);
    chunks.forEach(g=>g.position.sub(camera.position));
    camera.position.set(0,0,0);
  }

  if (stars) stars.position.copy(camera.position);

  chunks.forEach(grp=>{
    grp.traverse(o=>{ if (o.userData && o.userData.parking){ o.rotation.y += 0.0006; } });
  });

  camera.quaternion.setFromEuler(eul);
  try { composer.render(); } catch (err) { console.error(err); loading.classList.add("hidden"); }
  requestAnimationFrame(loop);
}

/* ===== Boot ===== */
function onResize(){ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); composer.setSize(innerWidth, innerHeight); }
addEventListener("resize", onResize);

function boot(){
  progress.style.width="10%";
  initThree();
  bindUI();
  requestAnimationFrame(loop);
}
boot();
</script>
</body>
</html>