<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Endless Flight Prototype</title>
    <style>
        :root {
            color-scheme: dark;
            --bg: radial-gradient(circle at 50% -20%, #1e2940, #090b12 55%);
            --panel-bg: rgba(0, 0, 0, 0.55);
            --accent: #8fd0ff;
            --accent-active: #ffd866;
            --text: #f2f6ff;
        }

        * { box-sizing: border-box; }

        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            background: #05070f;
            touch-action: none;
            font-family: "Inter", "SF Pro Text", system-ui, sans-serif;
            color: var(--text);
        }

        #appCanvas {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        #hud {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            align-items: center;
            padding: 10px 16px;
            border-radius: 999px;
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            box-shadow: 0 18px 45px rgba(0, 0, 0, 0.45);
            z-index: 10;
        }

        #hud button {
            appearance: none;
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.06);
            color: var(--text);
            padding: 8px 14px;
            font-size: 0.9rem;
            letter-spacing: 0.02em;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease;
        }

        #hud button[aria-pressed="true"] {
            background: rgba(255, 255, 255, 0.16);
            border-color: var(--accent-active);
            color: var(--accent-active);
        }

        #readout {
            font-size: 0.8rem;
            opacity: 0.85;
            min-width: 150px;
        }

        #helper {
            position: fixed;
            left: 16px;
            bottom: 16px;
            padding: 12px 16px;
            width: min(92vw, 320px);
            border-radius: 18px;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            font-size: 0.85rem;
            line-height: 1.45;
            color: rgba(255, 255, 255, 0.82);
        }

        #helper strong {
            color: var(--accent);
            font-weight: 600;
        }

        @media (max-width: 600px) {
            #hud {
                top: auto;
                bottom: 16px;
                flex-direction: column;
                align-items: stretch;
                padding: 14px;
                gap: 10px;
            }

            #readout {
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <canvas id="appCanvas"></canvas>
    <div id="hud" role="group" aria-label="Flight controls">
        <button id="directionToggle" type="button" aria-pressed="true" aria-label="Toggle forward reverse">
            Forward
        </button>
        <button id="turboToggle" type="button" aria-pressed="false" aria-label="Toggle turbo">
            Turbo Off
        </button>
        <div id="readout" aria-live="polite"></div>
    </div>
    <aside id="helper">
        <strong>Tap &amp; hold</strong> anywhere to thrust. Drag to steer. Use the toggle to fly forward or reverse, and Turbo for an instant burst.
    </aside>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js';

        // === Constants ===
        const FOV = 60;
        const SPEED_BASE = 12;
        const SPEED_TURBO_FACTOR = 3.0;
        const SPEED_REVERSE_FACTOR = 1.0;
        const ACCEL_GAIN = 0.18;
        const PITCH_CLAMP = {
            min: -Math.PI / 2 + THREE.MathUtils.degToRad(3),
            max: Math.PI / 2 - THREE.MathUtils.degToRad(3)
        };
        const FIXED_DT = 1 / 60;
        const MAX_FRAME_DELTA = 0.25;
        const CHUNK_SIZE = 220;
        const CHUNK_RES = 48;
        const GRID_RADIUS = 2; // produces a (2*radius + 1)^2 grid
        const REBASE_THRESHOLD = 10000;
        const PITCH_DEADZONE = 6;
        const K_YAW = 0.0025;
        const K_PITCH = 0.0020;

        // === Core Three.js setup ===
        const canvas = document.getElementById('appCanvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.setClearColor(new THREE.Color('#05070f'));

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2('#0b1629', 0.0007);

        const rigRoot = new THREE.Object3D();
        const yawPivot = new THREE.Object3D();
        const pitchPivot = new THREE.Object3D();
        const camera = new THREE.PerspectiveCamera(FOV, window.innerWidth / window.innerHeight, 0.1, 20000);
        camera.position.set(0, 2, 0);

        rigRoot.add(yawPivot);
        yawPivot.add(pitchPivot);
        pitchPivot.add(camera);
        scene.add(rigRoot);

        const hemiLight = new THREE.HemisphereLight('#89b7ff', '#0d0f16', 0.55);
        scene.add(hemiLight);

        const sun = new THREE.DirectionalLight('#fff6d5', 1.1);
        sun.position.set(120, 260, -160);
        sun.castShadow = false;
        scene.add(sun);

        const skyGeo = new THREE.SphereGeometry(9000, 32, 16);
        const skyMat = new THREE.ShaderMaterial({
            side: THREE.BackSide,
            uniforms: {
                topColor: { value: new THREE.Color('#0b1f47') },
                bottomColor: { value: new THREE.Color('#08101f') }
            },
            vertexShader: `varying vec3 vWorldPosition;\nvoid main(){\nvec4 worldPosition = modelMatrix * vec4(position, 1.0);\nvWorldPosition = worldPosition.xyz;\ngl_Position = projectionMatrix * viewMatrix * worldPosition;\n}`,
            fragmentShader: `varying vec3 vWorldPosition;\nuniform vec3 topColor;\nuniform vec3 bottomColor;\nvoid main(){\nfloat h = normalize(vWorldPosition).y * 0.5 + 0.5;\ngl_FragColor = vec4(mix(bottomColor, topColor, smoothstep(0.0, 1.0, h)), 1.0);\n}`
        });
        const skydome = new THREE.Mesh(skyGeo, skyMat);
        scene.add(skydome);

        // === Terrain generation utilities ===
        const worldOrigin = new THREE.Vector3();

        function hash2d(x, z) {
            const s = Math.sin(x * 127.1 + z * 311.7) * 43758.5453123;
            return (s - Math.floor(s));
        }

        function noise2d(x, z) {
            const xi = Math.floor(x);
            const zi = Math.floor(z);
            const xf = x - xi;
            const zf = z - zi;

            const h00 = hash2d(xi, zi);
            const h10 = hash2d(xi + 1, zi);
            const h01 = hash2d(xi, zi + 1);
            const h11 = hash2d(xi + 1, zi + 1);

            const u = xf * xf * (3 - 2 * xf);
            const v = zf * zf * (3 - 2 * zf);

            const x1 = THREE.MathUtils.lerp(h00, h10, u);
            const x2 = THREE.MathUtils.lerp(h01, h11, u);
            return THREE.MathUtils.lerp(x1, x2, v);
        }

        function fbm(x, z) {
            let value = 0;
            let amplitude = 0.85;
            let frequency = 0.0035;
            for (let i = 0; i < 6; i++) {
                value += noise2d(x * frequency, z * frequency) * amplitude;
                frequency *= 2.0;
                amplitude *= 0.5;
            }
            return value;
        }

        function sampleHeight(x, z) {
            const ridged = Math.abs(fbm(x + 9000.3, z - 4200.7));
            const valley = fbm(x - 12000.5, z + 3200.8);
            const base = fbm(x, z);
            const height = (base * 55) + (ridged * 120) - (valley * 40);
            return height;
        }

        class TerrainManager {
            constructor(sceneRef, originRef) {
                this.scene = sceneRef;
                this.origin = originRef;
                this.chunks = new Map();
            }

            key(cx, cz) {
                return `${cx},${cz}`;
            }

            ensureChunks(worldPos) {
                const centerX = Math.floor(worldPos.x / CHUNK_SIZE);
                const centerZ = Math.floor(worldPos.z / CHUNK_SIZE);
                const needed = new Set();

                for (let dz = -GRID_RADIUS; dz <= GRID_RADIUS; dz++) {
                    for (let dx = -GRID_RADIUS; dx <= GRID_RADIUS; dx++) {
                        const cx = centerX + dx;
                        const cz = centerZ + dz;
                        const id = this.key(cx, cz);
                        needed.add(id);
                        if (!this.chunks.has(id)) {
                            const mesh = this.buildChunk(cx, cz);
                            this.chunks.set(id, mesh);
                            this.scene.add(mesh);
                        }
                    }
                }

                for (const [id, mesh] of this.chunks) {
                    if (!needed.has(id)) {
                        this.scene.remove(mesh);
                        mesh.geometry.dispose();
                        mesh.material.dispose();
                        this.chunks.delete(id);
                    }
                }
            }

            buildChunk(cx, cz) {
                const geometry = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, CHUNK_RES, CHUNK_RES);
                geometry.rotateX(-Math.PI / 2);

                const positions = geometry.attributes.position;
                const colors = new Float32Array(positions.count * 3);
                const color = new THREE.Color();

                for (let i = 0; i < positions.count; i++) {
                    const vx = positions.getX(i) + cx * CHUNK_SIZE - this.origin.x;
                    const vz = positions.getZ(i) + cz * CHUNK_SIZE - this.origin.z;
                    const worldX = vx + this.origin.x;
                    const worldZ = vz + this.origin.z;
                    const h = sampleHeight(worldX, worldZ);
                    positions.setY(i, h);

                    const normalized = THREE.MathUtils.clamp((h + 80) / 220, 0, 1);
                    const hue = THREE.MathUtils.lerp(0.55, 0.3, normalized);
                    const lightness = THREE.MathUtils.lerp(0.2, 0.65, normalized);
                    color.setHSL(hue, 0.55, lightness);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }

                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.computeVertexNormals();

                const material = new THREE.MeshStandardMaterial({
                    vertexColors: true,
                    roughness: 0.9,
                    metalness: 0.05,
                    flatShading: false
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.receiveShadow = true;
                mesh.rotation.y = Math.PI;
                mesh.position.set(
                    cx * CHUNK_SIZE - this.origin.x,
                    0,
                    cz * CHUNK_SIZE - this.origin.z
                );
                mesh.userData.chunk = { cx, cz };
                return mesh;
            }

            rebase(shift) {
                for (const mesh of this.chunks.values()) {
                    mesh.position.sub(shift);
                }
            }
        }

        const terrain = new TerrainManager(scene, worldOrigin);

        // === State ===
        let yaw = 0;
        let pitch = 0;
        let velocity = 0;
        let direction = 1;
        let turboEnabled = false;
        const pointerState = {
            activeId: null,
            holding: false,
            prevX: 0,
            prevY: 0,
            dyAccum: 0
        };

        let yawSensitivity = 0;
        let pitchSensitivity = 0;

        function recalcSensitivities() {
            const viewportWidth = canvas.clientWidth || window.innerWidth;
            const viewportHeight = canvas.clientHeight || window.innerHeight;
            const fovRad = THREE.MathUtils.degToRad(camera.fov);
            yawSensitivity = K_YAW * (fovRad / Math.max(1, viewportWidth));
            pitchSensitivity = K_PITCH * (fovRad / Math.max(1, viewportHeight));
        }

        recalcSensitivities();

        // === UI controls ===
        const directionToggle = document.getElementById('directionToggle');
        const turboToggle = document.getElementById('turboToggle');
        const readout = document.getElementById('readout');

        directionToggle.addEventListener('click', () => {
            direction *= -1;
            velocity *= -1;
            const isForward = direction === 1;
            directionToggle.setAttribute('aria-pressed', String(isForward));
            directionToggle.textContent = isForward ? 'Forward' : 'Reverse';
            navigator.vibrate?.(8);
        });

        turboToggle.addEventListener('click', () => {
            turboEnabled = !turboEnabled;
            turboToggle.setAttribute('aria-pressed', String(turboEnabled));
            turboToggle.textContent = turboEnabled ? 'Turbo On' : 'Turbo Off';
            navigator.vibrate?.(12);
        });

        // === Pointer input handling ===
        function getEventXY(e) {
            return { x: e.clientX, y: e.clientY };
        }

        function handlePointerDown(e) {
            if (pointerState.activeId !== null) return;
            pointerState.activeId = e.pointerId;
            pointerState.holding = true;
            const { x, y } = getEventXY(e);
            pointerState.prevX = x;
            pointerState.prevY = y;
            pointerState.dyAccum = 0;
            canvas.setPointerCapture(e.pointerId);
            e.preventDefault();
        }

        function handlePointerMove(e) {
            if (e.pointerId !== pointerState.activeId) return;
            const { x, y } = getEventXY(e);
            const dx = x - pointerState.prevX;
            const dy = y - pointerState.prevY;
            pointerState.prevX = x;
            pointerState.prevY = y;
            pointerState.dyAccum += dy;

            yaw += dx * yawSensitivity;
            if (Math.abs(pointerState.dyAccum) > PITCH_DEADZONE) {
                pitch = THREE.MathUtils.clamp(pitch + dy * pitchSensitivity, PITCH_CLAMP.min, PITCH_CLAMP.max);
            }

            e.preventDefault();
        }

        function stopPointer(e) {
            if (e.pointerId !== pointerState.activeId) return;
            pointerState.holding = false;
            pointerState.activeId = null;
            pointerState.dyAccum = 0;
            try { canvas.releasePointerCapture(e.pointerId); } catch { /* ignore */ }
            e.preventDefault();
        }

        canvas.addEventListener('pointerdown', handlePointerDown, { passive: false });
        canvas.addEventListener('pointermove', handlePointerMove, { passive: false });
        canvas.addEventListener('pointerup', stopPointer, { passive: false });
        canvas.addEventListener('pointercancel', stopPointer, { passive: false });

        window.addEventListener('blur', () => {
            pointerState.holding = false;
            pointerState.activeId = null;
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                pointerState.holding = false;
                pointerState.activeId = null;
                velocity = 0;
            }
        });

        // === Simulation loop ===
        const forwardVector = new THREE.Vector3();
        const tmpShift = new THREE.Vector3();
        let accumulator = 0;
        let lastTime = performance.now() / 1000;

        function fixedUpdate(dt) {
            yawPivot.rotation.y = yaw;
            pitchPivot.rotation.x = pitch;

            const turboFactor = turboEnabled ? SPEED_TURBO_FACTOR : 1.0;
            const directionFactor = direction === 1 ? 1 : SPEED_REVERSE_FACTOR;
            const targetSpeed = pointerState.holding
                ? SPEED_BASE * directionFactor * turboFactor * direction
                : velocity;
            if (pointerState.holding) {
                velocity = THREE.MathUtils.lerp(velocity, targetSpeed, ACCEL_GAIN);
            } else {
                velocity = targetSpeed; // preserve momentum
            }

            forwardVector.set(0, 0, -1).applyQuaternion(camera.quaternion).normalize();
            rigRoot.position.addScaledVector(forwardVector, velocity * dt);

            if (rigRoot.position.length() > REBASE_THRESHOLD) {
                tmpShift.set(
                    Math.round(rigRoot.position.x / CHUNK_SIZE) * CHUNK_SIZE,
                    0,
                    Math.round(rigRoot.position.z / CHUNK_SIZE) * CHUNK_SIZE
                );
                if (tmpShift.lengthSq() > 0) {
                    rigRoot.position.sub(tmpShift);
                    worldOrigin.add(tmpShift);
                    terrain.rebase(tmpShift);
                }
            }

            const worldCameraPos = rigRoot.position.clone().add(worldOrigin);
            terrain.ensureChunks(worldCameraPos);
        }

        function animate() {
            const now = performance.now() / 1000;
            let delta = now - lastTime;
            lastTime = now;
            delta = Math.min(delta, MAX_FRAME_DELTA);
            accumulator += delta;

            while (accumulator >= FIXED_DT) {
                fixedUpdate(FIXED_DT);
                accumulator -= FIXED_DT;
            }

            const interpFactor = accumulator / FIXED_DT;
            skydome.position.copy(rigRoot.position);
            skydome.position.y -= 50;

            camera.updateMatrixWorld();
            renderer.render(scene, camera);

            const displaySpeed = Math.abs(velocity).toFixed(1);
            readout.textContent = `Speed: ${displaySpeed} m/s${turboEnabled ? ' • Turbo' : ''}`;

            requestAnimationFrame(animate);
        }

        animate();

        // === Resize handling ===
        function onResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height, false);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            recalcSensitivities();
        }

        window.addEventListener('resize', onResize);
        onResize();
    </script>
</body>
</html>
