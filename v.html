<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Codex Recall Launcher</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
      --bg: #f5f6fb;
      --bg-dark: #111827;
      --panel: #ffffff;
      --panel-dark: #1f2937;
      --border: #d8ddf0;
      --border-dark: #2f3a4f;
      --accent: #4f46e5;
      --accent-dark: #7c81ff;
      --muted: #6b7280;
      --muted-dark: #94a3b8;
      --danger: #dc2626;
      --success: #16a34a;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(180deg, rgba(79, 70, 229, 0.12), transparent 320px) var(--bg);
      color: #0f172a;
    }

    @media (prefers-color-scheme: dark) {
      body {
        background: linear-gradient(180deg, rgba(124, 129, 255, 0.18), transparent 320px) var(--bg-dark);
        color: #e5e7eb;
      }
    }

    header {
      padding: 28px clamp(20px, 4vw, 48px) 16px;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.75rem, 4vw, 2.4rem);
      letter-spacing: -0.03em;
    }

    header p {
      margin: 10px 0 0;
      max-width: 720px;
      color: var(--muted);
    }

    @media (prefers-color-scheme: dark) {
      header p {
        color: var(--muted-dark);
      }
    }

    main {
      padding: 0 clamp(20px, 4vw, 48px) 48px;
      display: grid;
      gap: 20px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 20px 22px;
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.08);
    }

    @media (prefers-color-scheme: dark) {
      .panel {
        background: var(--panel-dark);
        border-color: var(--border-dark);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
      }
    }

    h2 {
      margin: 0 0 16px;
      font-size: 1.1rem;
      letter-spacing: -0.01em;
    }

    .grid-two {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 20px;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .field  .field {
      margin-top: 12px;
    }

    label {
      font-size: 0.78rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    input[type="text"],
    input[type="search"],
    select,
    textarea {
      font: inherit;
      color: inherit;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.92);
      padding: 10px 12px;
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }

    textarea {
      min-height: 240px;
      resize: vertical;
    }

    @media (prefers-color-scheme: dark) {
      input[type="text"],
      input[type="search"],
      select,
      textarea {
        background: rgba(30, 41, 59, 0.95);
        border-color: var(--border-dark);
      }
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
    }

    button {
      font: inherit;
      cursor: pointer;
      border-radius: 999px;
      border: none;
      padding: 10px 18px;
      background: var(--accent);
      color: white;
      font-weight: 600;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    button.secondary {
      background: transparent;
      color: var(--accent);
      border: 1px solid var(--accent);
    }

    button.danger {
      background: var(--danger);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 12px 28px rgba(79, 70, 229, 0.2);
    }

    button.secondary:hover:not(:disabled) {
      box-shadow: 0 12px 28px rgba(79, 70, 229, 0.15);
      background: rgba(79, 70, 229, 0.1);
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 16px;
    }

    .status-bar {
      margin-top: 12px;
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(79, 70, 229, 0.08);
      border: 1px solid rgba(79, 70, 229, 0.18);
    }

    .status-bar[data-tone="error"] {
      background: rgba(220, 38, 38, 0.08);
      border-color: rgba(220, 38, 38, 0.25);
      color: #b91c1c;
    }

    .status-bar[data-tone="success"] {
      background: rgba(22, 163, 74, 0.08);
      border-color: rgba(22, 163, 74, 0.25);
      color: #047857;
    }

    .status-bar .loader {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 3px solid rgba(79, 70, 229, 0.3);
      border-top-color: rgba(79, 70, 229, 0.9);
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .file-select {
      display: grid;
      gap: 16px;
    }

    .file-select select {
      max-height: 280px;
    }

    .history-layout {
      display: grid;
      gap: 16px;
    }

    .commit-list {
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 12px;
      max-height: 320px;
      overflow: auto;
      display: grid;
      gap: 8px;
      background: rgba(255, 255, 255, 0.66);
    }

    @media (prefers-color-scheme: dark) {
      .commit-list {
        border-color: var(--border-dark);
        background: rgba(30, 41, 59, 0.85);
      }
    }

    .commit-row {
      display: flex;
      gap: 8px;
      align-items: stretch;
      flex-wrap: wrap;
    }

    .commit-item {
      border-radius: 12px;
      padding: 10px 12px;
      text-align: left;
      background: transparent;
      border: 1px solid transparent;
      display: grid;
      gap: 4px;
      color: inherit;
      transition: border 0.2s ease, background 0.2s ease;
      flex: 1;
    }

    .commit-item strong {
      font-size: 0.95rem;
      letter-spacing: 0.02em;
    }

    .commit-item span {
      font-size: 0.82rem;
      color: var(--muted);
    }

    .commit-item:hover,
    .commit-item.active {
      border-color: rgba(79, 70, 229, 0.4);
      background: rgba(79, 70, 229, 0.08);
    }

    @media (prefers-color-scheme: dark) {
      .commit-item span {
        color: var(--muted-dark);
      }
      .commit-item:hover,
      .commit-item.active {
        background: rgba(124, 129, 255, 0.14);
        border-color: rgba(124, 129, 255, 0.4);
      }
    }

    .commit-launch {
      border-radius: 10px;
      border: 1px solid var(--accent);
      background: rgba(79, 70, 229, 0.12);
      color: var(--accent);
      padding: 0 14px;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
      display: flex;
      align-items: center;
    }

    .commit-launch:hover {
      background: rgba(79, 70, 229, 0.22);
      transform: translateY(-1px);
    }

    .commit-launch:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    @media (prefers-color-scheme: dark) {
      .commit-launch {
        border-color: var(--accent-dark);
        background: rgba(124, 129, 255, 0.16);
        color: var(--accent-dark);
      }

      .commit-launch:hover {
        background: rgba(124, 129, 255, 0.28);
      }
    }

    .tab-bar {
      display: flex;
      gap: 10px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 6px;
    }

    .tab-button {
      appearance: none;
      background: none;
      border: none;
      padding: 8px 14px;
      border-radius: 10px 10px 0 0;
      font: inherit;
      cursor: pointer;
      color: var(--muted);
      transition: color 0.2s ease, background 0.2s ease;
    }

    .tab-button.active {
      color: var(--accent);
      background: rgba(79, 70, 229, 0.1);
    }

    .tab-panel {
      display: none;
      padding: 20px 0 0;
    }

    .tab-panel.active {
      display: block;
    }

    .preview-shell {
      display: grid;
      gap: 16px;
    }

    .preview-frame {
      width: 100%;
      min-height: 420px;
      border-radius: 16px;
      border: 1px solid var(--border);
      background: white;
    }

    @media (prefers-color-scheme: dark) {
      .preview-frame {
        border-color: var(--border-dark);
        background: #0f172a;
      }
    }

    .actions-grid {
      display: grid;
      gap: 16px;
    }

    .actions-grid h3 {
      margin: 0;
      font-size: 1rem;
    }

    .actions-grid form {
      display: grid;
      gap: 12px;
    }

    .launch-section {
      margin-top: 18px;
      display: grid;
      gap: 10px;
    }

    .inline-fields {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
    }

    .muted-text {
      font-size: 0.85rem;
      color: var(--muted);
    }

    @media (prefers-color-scheme: dark) {
      .muted-text {
        color: var(--muted-dark);
      }
    }

    .empty-state {
      border: 1px dashed var(--border);
      border-radius: 14px;
      padding: 32px;
      text-align: center;
      color: var(--muted);
    }

    @media (prefers-color-scheme: dark) {
      .empty-state {
        border-color: var(--border-dark);
      }
    }

    a.inline-link {
      color: var(--accent);
      text-decoration: none;
      font-weight: 600;
    }

    a.inline-link:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <header>
    <h1>Codex Recall Launcher</h1>
    <p>
      Point Codex at any repository, choose a file, and scan every revision in descending order. Search by SHA or
      timestamp, spin up isolated tabs for any snapshot under a custom name, then copy, export, or publish straight back
      to GitHub when you're satisfied.
    </p>
  </header>

  <main>
    <section class="panel">
      <h2>Authentication & defaults</h2>
      <div class="grid-two">
        <div>
          <div class="field">
            <label for="tokenInput">GitHub personal access token</label>
            <input id="tokenInput" type="text" autocomplete="off" placeholder="ghp_…" />
          </div>
          <div class="button-row">
            <button id="saveTokenBtn" type="button">Save token</button>
            <button id="clearTokenBtn" type="button" class="secondary">Forget token</button>
          </div>
          <div id="tokenStatus" class="status-bar" hidden></div>
        </div>
        <div>
          <div class="field">
            <label for="ownerInput">GitHub username / org</label>
            <input id="ownerInput" type="text" placeholder="octocat" />
          </div>
          <div class="field">
            <label for="repoInput">Repository</label>
            <input id="repoInput" type="text" placeholder="hello-world" />
          </div>
          <div class="field">
            <label for="branchInput">Branch (defaults to default branch)</label>
            <input id="branchInput" type="text" placeholder="main" />
          </div>
          <div class="button-row">
            <button id="loadRepoBtn" type="button">Load files</button>
            <button id="resetSettingsBtn" type="button" class="secondary">Reset defaults</button>
          </div>
          <div id="repoStatus" class="status-bar" hidden></div>
        </div>
      </div>
    </section>

    <section class="panel">
      <h2>Choose a file</h2>
      <div class="file-select">
        <div class="field">
          <label for="fileFilterInput">Filter files</label>
          <input id="fileFilterInput" type="search" placeholder="Type to filter filenames" autocomplete="off" />
        </div>
        <div class="field">
          <label for="fileSelect">Repository files</label>
          <select id="fileSelect" size="12"></select>
        </div>
        <div id="fileStatus" class="status-bar" hidden></div>
      </div>
    </section>

    <section class="panel">
      <div class="tab-bar">
        <button class="tab-button active" data-tab="history">History</button>
        <button class="tab-button" data-tab="preview">Preview & actions</button>
      </div>
      <div class="tab-panel active" id="historyTab">
        <div class="history-layout">
          <div class="field">
            <label for="historySearchInput">Search by SHA or date</label>
            <input id="historySearchInput" type="search" placeholder="e.g. 4d2a or 2024-03-18" autocomplete="off" />
          </div>
          <div id="historyStatus" class="status-bar" hidden></div>
          <div id="historyEmpty" class="empty-state" hidden>
            Pick a file to load every historical version in descending order.
          </div>
          <div id="historyList" class="commit-list"></div>
        </div>
      </div>
      <div class="tab-panel" id="previewTab">
        <div class="preview-shell">
          <div id="previewEmpty" class="empty-state">
            Select a commit to preview the file contents.
          </div>
          <iframe id="previewFrame" class="preview-frame" title="File preview" hidden></iframe>
          <div id="previewMeta" class="muted-text" hidden></div>
          <div class="actions-grid" id="actionsGrid" hidden>
            <div>
              <h3>Edit & update preview</h3>
              <div class="field">
                <label for="contentEditor">Editable snapshot</label>
                <textarea id="contentEditor" spellcheck="false"></textarea>
              </div>
              <div class="button-row">
                <button id="refreshPreviewBtn" type="button">Update preview</button>
                <button id="copyContentBtn" type="button" class="secondary">Copy to clipboard</button>
                <button id="downloadContentBtn" type="button" class="secondary">Download</button>
              </div>
              <div class="launch-section">
                <div class="field">
                  <label for="launchNameInput">Tab name</label>
                  <input id="launchNameInput" type="text" placeholder="snapshot.html" />
                </div>
                <div class="button-row">
                  <button id="launchTabBtn" type="button" disabled>Launch in new tab</button>
                  <button id="launchCloneBtn" type="button" class="secondary" disabled>Launch test tab</button>
                </div>
                <div id="launchStatus" class="status-bar" hidden></div>
              </div>
            </div>
            <div>
              <h3>Push or share</h3>
              <form id="publishForm">
                <div class="inline-fields">
                  <div class="field">
                    <label for="destOwnerInput">Destination owner</label>
                    <input id="destOwnerInput" type="text" />
                  </div>
                  <div class="field">
                    <label for="destRepoInput">Destination repo</label>
                    <input id="destRepoInput" type="text" />
                  </div>
                  <div class="field">
                    <label for="destBranchInput">Branch</label>
                    <input id="destBranchInput" type="text" placeholder="main" />
                  </div>
                  <div class="field">
                    <label for="destPathInput">File path</label>
                    <input id="destPathInput" type="text" />
                  </div>
                </div>
                <div class="field">
                  <label for="commitMessageInput">Commit message</label>
                  <input id="commitMessageInput" type="text" placeholder="Add snapshot" />
                </div>
                <div class="field">
                  <label for="baseBranchInput">Base branch (for new branches)</label>
                  <input id="baseBranchInput" type="text" placeholder="Default branch" />
                </div>
                <div class="button-row">
                  <button type="submit">Publish snapshot</button>
                  <button id="openGithubBtn" type="button" class="secondary">View commit on GitHub</button>
                  <button id="openPagesBtn" type="button" class="secondary">Open GitHub Pages</button>
                </div>
                <div id="publishStatus" class="status-bar" hidden></div>
              </form>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script src="codex-storage.js"></script>
  <script>
    const TOKEN_KEY = 'codexrecall.workspace.token';
    const SETTINGS_KEY = 'codexrecall.workspace.settings';

    function resolveStorage() {
      if (window.CodexStorage) return window.CodexStorage;
      try {
        if (window.localStorage) return window.localStorage;
      } catch (error) {
        console.warn('Storage unavailable, using memory storage', error);
      }
      const mem = new Map();
      return {
        getItem(key) { return mem.has(key) ? mem.get(key) : null; },
        setItem(key, value) { mem.set(key, String(value)); },
        removeItem(key) { mem.delete(key); }
      };
    }

    const storage = resolveStorage();

    const state = {
      token: null,
      owner: '',
      repo: '',
      branch: '',
      defaultBranch: '',
      files: [],
      filteredFiles: [],
      commits: [],
      filteredCommits: [],
      selectedFile: '',
      selectedCommit: null,
      content: '',
      commitUrl: '',
      committedAt: '',
      contentCache: null
    };

    state.contentCache = new Map();

    const tokenInput = document.getElementById('tokenInput');
    const tokenStatus = document.getElementById('tokenStatus');
    const saveTokenBtn = document.getElementById('saveTokenBtn');
    const clearTokenBtn = document.getElementById('clearTokenBtn');

    const ownerInput = document.getElementById('ownerInput');
    const repoInput = document.getElementById('repoInput');
    const branchInput = document.getElementById('branchInput');
    const loadRepoBtn = document.getElementById('loadRepoBtn');
    const resetSettingsBtn = document.getElementById('resetSettingsBtn');
    const repoStatus = document.getElementById('repoStatus');

    const fileFilterInput = document.getElementById('fileFilterInput');
    const fileSelect = document.getElementById('fileSelect');
    const fileStatus = document.getElementById('fileStatus');

    const tabButtons = Array.from(document.querySelectorAll('.tab-button'));
    const historyTab = document.getElementById('historyTab');
    const previewTab = document.getElementById('previewTab');

    const historySearchInput = document.getElementById('historySearchInput');
    const historyStatus = document.getElementById('historyStatus');
    const historyEmpty = document.getElementById('historyEmpty');
    const historyList = document.getElementById('historyList');

    const previewEmpty = document.getElementById('previewEmpty');
    const previewFrame = document.getElementById('previewFrame');
    const previewMeta = document.getElementById('previewMeta');
    const actionsGrid = document.getElementById('actionsGrid');
    const contentEditor = document.getElementById('contentEditor');
    const refreshPreviewBtn = document.getElementById('refreshPreviewBtn');
    const copyContentBtn = document.getElementById('copyContentBtn');
    const downloadContentBtn = document.getElementById('downloadContentBtn');
    const launchNameInput = document.getElementById('launchNameInput');
    const launchTabBtn = document.getElementById('launchTabBtn');
    const launchCloneBtn = document.getElementById('launchCloneBtn');
    const launchStatus = document.getElementById('launchStatus');

    const publishForm = document.getElementById('publishForm');
    const destOwnerInput = document.getElementById('destOwnerInput');
    const destRepoInput = document.getElementById('destRepoInput');
    const destBranchInput = document.getElementById('destBranchInput');
    const destPathInput = document.getElementById('destPathInput');
    const commitMessageInput = document.getElementById('commitMessageInput');
    const baseBranchInput = document.getElementById('baseBranchInput');
    const publishStatus = document.getElementById('publishStatus');
    const openGithubBtn = document.getElementById('openGithubBtn');
    const openPagesBtn = document.getElementById('openPagesBtn');

    function resetPreview({ clearMessage = false } = {}) {
      state.selectedCommit = null;
      state.content = '';
      state.commitUrl = '';
      state.committedAt = '';
      previewFrame.hidden = true;
      previewFrame.removeAttribute('srcdoc');
      previewEmpty.hidden = false;
      previewMeta.hidden = true;
      actionsGrid.hidden = true;
      contentEditor.value = '';
      launchNameInput.dataset.manual = '';
      launchNameInput.dataset.lastCommit = '';
      launchNameInput.value = '';
      setStatus(launchStatus, '');
      launchTabBtn.disabled = true;
      launchCloneBtn.disabled = true;
      if (clearMessage) {
        commitMessageInput.dataset.manual = '';
        commitMessageInput.value = '';
      }
    }

    function setStatus(element, message, { tone = 'info', spinner = false } = {}) {
      if (!element) return;
      if (!message) {
        element.hidden = true;
        element.innerHTML = '';
        element.removeAttribute('data-tone');
        return;
      }
      element.hidden = false;
      element.dataset.tone = tone;
      if (spinner) {
        element.innerHTML = `<span class="loader"></span><span>${message}</span>`;
      } else {
        element.textContent = message;
      }
    }

    function encodeContent(content) {
      return btoa(unescape(encodeURIComponent(content)));
    }

    function decodeContent(content) {
      try {
        return decodeURIComponent(escape(atob(content)));
      } catch (error) {
        return atob(content);
      }
    }

    function persistSettings() {
      const payload = {
        owner: ownerInput.value.trim(),
        repo: repoInput.value.trim(),
        branch: branchInput.value.trim()
      };
      storage.setItem(SETTINGS_KEY, JSON.stringify(payload));
    }

    function hydrateSettings() {
      const storedToken = storage.getItem(TOKEN_KEY);
      if (storedToken) {
        state.token = storedToken;
        tokenInput.value = storedToken;
        setStatus(tokenStatus, 'Token loaded from storage', { tone: 'success' });
      }
      const storedSettings = storage.getItem(SETTINGS_KEY);
      if (storedSettings) {
        try {
          const parsed = JSON.parse(storedSettings);
          if (parsed.owner) {
            state.owner = parsed.owner;
            ownerInput.value = parsed.owner;
          }
          if (parsed.repo) {
            state.repo = parsed.repo;
            repoInput.value = parsed.repo;
          }
          if (parsed.branch) {
            state.branch = parsed.branch;
            branchInput.value = parsed.branch;
          }
        } catch (error) {
          console.warn('Failed to parse stored settings', error);
        }
      }
      updatePublishDefaults();
    }

    function updatePublishDefaults() {
      destOwnerInput.value = state.owner || ownerInput.value.trim();
      destRepoInput.value = state.repo || repoInput.value.trim();
      const branchValue = branchInput.value.trim() || state.branch || state.defaultBranch;
      destBranchInput.value = branchValue || '';
      destPathInput.value = state.selectedFile ? state.selectedFile : '';
    }

    function buildDefaultLaunchName(commit) {
      const fileName = state.selectedFile ? state.selectedFile.split('/').pop() : 'snapshot.html';
      const dotIndex = fileName.lastIndexOf('.');
      const base = dotIndex >= 0 ? fileName.slice(0, dotIndex) : fileName;
      const extension = dotIndex >= 0 ? fileName.slice(dotIndex) : '.html';
      const sha = (commit?.sha || state.selectedCommit?.sha || '').slice(0, 7);
      const safeBase = base.replace(/[^a-z0-9._-]/gi, '-').replace(/-/g, '-').replace(/^-|-$/g, '') || 'snapshot';
      const safeSha = sha.replace(/[^a-f0-9]/gi, '') || 'draft';
      return `${safeBase}-${safeSha}${extension}`;
    }

    function updateLaunchName(commit) {
      if (launchNameInput.dataset.manual === 'true') return;
      const target = commit || state.selectedCommit;
      launchNameInput.value = buildDefaultLaunchName(target);
    }

    function appendSuffix(name, suffix) {
      if (!suffix) return name;
      const trimmed = (name || '').trim();
      if (!trimmed) return suffix;
      const lowerSuffix = suffix.toLowerCase();
      const dotIndex = trimmed.lastIndexOf('.');
      const base = dotIndex > 0 ? trimmed.slice(0, dotIndex) : trimmed;
      const extension = dotIndex > 0 ? trimmed.slice(dotIndex) : '';
      if (base.toLowerCase().endsWith(`-${lowerSuffix}`)) {
        return trimmed;
      }
      return `${base}-${suffix}${extension}`;
    }

    function resolveLaunchName(commit, { variant = 'default' } = {}) {
      const baseName = (launchNameInput.value || '').trim() || buildDefaultLaunchName(commit);
      if (variant === 'test') {
        return appendSuffix(baseName, 'test');
      }
      return baseName;
    }

    function openContentInNewTab(content, tabName) {
      const win = window.open('', '_blank');
      if (!win) {
        throw new Error('Popup blocked. Allow pop-ups to launch snapshots.');
      }
      win.document.open();
      win.document.write(content);
      win.document.close();
      if (tabName) {
        try {
          win.document.title = tabName;
        } catch (error) {
          // ignore title write failures
        }
      }
      try {
        win.focus();
      } catch (error) {
        // ignore focus failures
      }
    }

    function resetHistory() {
      state.commits = [];
      state.filteredCommits = [];
      state.contentCache = new Map();
      historyList.innerHTML = '';
      historyEmpty.textContent = 'Pick a file to load every historical version in descending order.';
      historyEmpty.hidden = false;
    }

    function encodePath(path) {
      return path.split('/').map(encodeURIComponent).join('/');
    }

    async function apiFetch(path, options = {}) {
      if (!state.token) {
        throw new Error('Set a GitHub token first.');
      }
      const headers = new Headers(options.headers || {});
      headers.set('Accept', 'application/vnd.githubjson');
      headers.set('Authorization', `Bearer ${state.token}`);
      headers.set('X-GitHub-Api-Version', '2022-11-28');
      const response = await fetch(`https://api.github.com${path}`, { ...options, headers });
      if (!response.ok) {
        let message = `${response.status} ${response.statusText}`;
        try {
          const data = await response.json();
          if (data?.message) {
            message = data.message;
          }
        } catch (error) {
          // ignore
        }
        const error = new Error(message);
        error.status = response.status;
        throw error;
      }
      return response.json();
    }

    async function loadRepositoryFiles() {
      const owner = ownerInput.value.trim();
      const repo = repoInput.value.trim();
      const branch = branchInput.value.trim();
      if (!owner || !repo) {
        setStatus(repoStatus, 'Provide both the owner and repository name.', { tone: 'error' });
        return;
      }
      persistSettings();
      setStatus(fileStatus, '', {});
      setStatus(repoStatus, 'Loading repository files…', { spinner: true });
      try {
        const repoData = await apiFetch(`/repos/${owner}/${repo}`);
        state.defaultBranch = repoData.default_branch || 'main';
        const targetBranch = branch || state.defaultBranch;
        state.branch = targetBranch;
        const tree = await apiFetch(`/repos/${owner}/${repo}/git/trees/${encodeURIComponent(targetBranch)}?recursive=1`);
        const files = Array.isArray(tree.tree)
          ? tree.tree.filter(node => node.type === 'blob').map(node => node.path).sort((a, b) => a.localeCompare(b))
          : [];
        state.owner = owner;
        state.repo = repo;
        state.files = files;
        state.selectedFile = '';
        resetHistory();
        resetPreview({ clearMessage: true });
        setStatus(historyStatus, '', {});
        fileFilterInput.value = '';
        applyFileFilter();
        updatePublishDefaults();
        if (tree.truncated) {
          setStatus(fileStatus, 'GitHub truncated the file listing; use the filter to narrow the search.', { tone: 'error' });
        } else {
          setStatus(fileStatus, '', {});
        }
        setStatus(repoStatus, `Loaded ${files.length.toLocaleString()} files from ${owner}/${repo}@${targetBranch}`, { tone: 'success' });
      } catch (error) {
        console.error('Failed to load repo files', error);
        setStatus(repoStatus, `Unable to load repository files: ${error.message}`, { tone: 'error' });
        state.files = [];
        state.filteredFiles = [];
        state.selectedFile = '';
        resetHistory();
        resetPreview({ clearMessage: true });
        setStatus(historyStatus, '', {});
        renderFileOptions();
      }
    }

    function applyFileFilter() {
      const filter = fileFilterInput.value.trim().toLowerCase();
      if (!filter) {
        state.filteredFiles = state.files.slice();
      } else {
        state.filteredFiles = state.files.filter(file => file.toLowerCase().includes(filter));
      }
      renderFileOptions();
    }

    function renderFileOptions() {
      fileSelect.innerHTML = '';
      if (!state.filteredFiles.length) {
        const option = document.createElement('option');
        option.textContent = state.files.length ? 'No files match the filter' : 'Load a repository to list files';
        option.disabled = true;
        fileSelect.appendChild(option);
        fileSelect.disabled = true;
        return;
      }
      fileSelect.disabled = false;
      for (const file of state.filteredFiles) {
        const option = document.createElement('option');
        option.value = file;
        option.textContent = file;
        if (file === state.selectedFile) {
          option.selected = true;
        }
        fileSelect.appendChild(option);
      }
    }

    async function loadFileHistory(filePath) {
      if (!state.owner || !state.repo) {
        setStatus(historyStatus, 'Load a repository first.', { tone: 'error' });
        return;
      }
      if (!filePath) {
        state.selectedFile = '';
        resetHistory();
        resetPreview({ clearMessage: true });
        renderHistory();
        setStatus(historyStatus, '', {});
        return;
      }
      state.selectedFile = filePath;
      state.contentCache = new Map();
      updatePublishDefaults();
      resetPreview();
      setStatus(historyStatus, `Loading history for ${filePath}…`, { spinner: true });
      try {
        const commits = await fetchAllCommits({ owner: state.owner, repo: state.repo, path: filePath, branch: state.branch || state.defaultBranch });
        state.commits = commits;
        applyHistoryFilter();
        if (!commits.length) {
          setStatus(historyStatus, `No commits found for ${filePath}.`, { tone: 'error' });
        } else {
          setStatus(historyStatus, `Loaded ${commits.length} commits.`, { tone: 'success' });
        }
      } catch (error) {
        console.error('Failed to load commit history', error);
        state.commits = [];
        applyHistoryFilter();
        setStatus(historyStatus, `Unable to load history: ${error.message}`, { tone: 'error' });
      }
    }

    async function fetchAllCommits({ owner, repo, path, branch }) {
      const perPage = 100;
      let page = 1;
      const commits = [];
      let hasMore = true;
      while (hasMore && page <= 10) {
        const query = new URLSearchParams({ per_page: String(perPage), page: String(page), path, sha: branch || '' });
        const data = await apiFetch(`/repos/${owner}/${repo}/commits?${query.toString()}`);
        if (!Array.isArray(data) || !data.length) {
          hasMore = false;
          break;
        }
        commits.push(...data);
        if (data.length < perPage) {
          hasMore = false;
        } else {
          page = 1;
        }
      }
      return commits.sort((a, b) => new Date(b.commit?.author?.date || b.commit?.committer?.date || 0) - new Date(a.commit?.author?.date || a.commit?.committer?.date || 0));
    }

    function applyHistoryFilter() {
      const filter = historySearchInput.value.trim().toLowerCase();
      if (!filter) {
        state.filteredCommits = state.commits.slice();
      } else {
        state.filteredCommits = state.commits.filter(commit => {
          const sha = (commit.sha || '').toLowerCase();
          const date = (commit.commit?.author?.date || commit.commit?.committer?.date || '').toLowerCase();
          return sha.includes(filter) || date.includes(filter);
        });
      }
      renderHistory();
    }

    function renderHistory() {
      historyList.innerHTML = '';
      if (!state.selectedFile) {
        historyEmpty.textContent = 'Pick a file to load every historical version in descending order.';
        historyEmpty.hidden = false;
        return;
      }
      if (!state.filteredCommits.length) {
        historyEmpty.textContent = 'No commits matched the current filters yet.';
        historyEmpty.hidden = false;
        return;
      }
      historyEmpty.hidden = true;
      for (const commit of state.filteredCommits) {
        const row = document.createElement('div');
        row.className = 'commit-row';

        const loadBtn = document.createElement('button');
        loadBtn.type = 'button';
        loadBtn.className = 'commit-item';
        const sha = commit.sha || '';
        const message = (commit.commit?.message || '').split('\n')[0];
        const authored = commit.commit?.author?.date || commit.commit?.committer?.date || '';
        const formatted = authored ? new Date(authored).toLocaleString() : 'Unknown date';
        loadBtn.innerHTML = `
          <strong>${sha.slice(0, 7)}</strong>
          <span>${formatted}</span>
          <span>${escapeHtml(message)}</span>
        `;
        if (state.selectedCommit && state.selectedCommit.sha === commit.sha) {
          loadBtn.classList.add('active');
        }
        loadBtn.addEventListener('click', () => selectCommit(commit));

        const launchBtn = document.createElement('button');
        launchBtn.type = 'button';
        launchBtn.className = 'commit-launch';
        launchBtn.textContent = 'Launch tab';
        launchBtn.title = 'Open this snapshot in a new tab';
        launchBtn.addEventListener('click', event => {
          event.stopPropagation();
          launchCommitVersion(commit);
        });

        row.appendChild(loadBtn);
        row.appendChild(launchBtn);
        historyList.appendChild(row);
      }
    }

    function escapeHtml(value) {
      const div = document.createElement('div');
      div.textContent = value;
      return div.innerHTML;
    }

    async function fetchCommitContent(commit) {
      if (!commit) {
        throw new Error('Pick a commit to launch.');
      }
      if (!state.selectedFile) {
        throw new Error('Select a file first.');
      }
      if (!state.contentCache) {
        state.contentCache = new Map();
      }
      if (state.contentCache.has(commit.sha)) {
        return state.contentCache.get(commit.sha);
      }
      const data = await apiFetch(`/repos/${state.owner}/${state.repo}/contents/${encodePath(state.selectedFile)}?ref=${commit.sha}`);
      const raw = decodeContent(data.content);
      state.contentCache.set(commit.sha, raw);
      return raw;
    }

    async function selectCommit(commit) {
      state.selectedCommit = commit;
      renderHistory();
      await loadCommitContent(commit);
      switchToTab('preview');
    }

    async function loadCommitContent(commit) {
      if (!commit || !state.selectedFile) return;
      setStatus(historyStatus, '', {});
      setStatus(fileStatus, '', {});
      setStatus(publishStatus, '', {});
      setStatus(fileStatus, `Fetching ${state.selectedFile} at ${commit.sha.slice(0,7)}…`, { spinner: true });
      try {
        if (launchNameInput.dataset.manual === 'true' && launchNameInput.dataset.lastCommit !== commit.sha) {
          launchNameInput.dataset.manual = '';
        }
        const raw = await fetchCommitContent(commit);
        state.content = raw;
        state.commitUrl = commit.html_url || `https://github.com/${state.owner}/${state.repo}/commit/${commit.sha}`;
        state.committedAt = commit.commit?.author?.date || commit.commit?.committer?.date || '';
        if (commitMessageInput.dataset.manual !== 'true') {
          const normalized = state.selectedFile ? state.selectedFile.replace(/^\//, '') : state.selectedFile;
          commitMessageInput.value = `Add snapshot of ${normalized}`;
        }
        updateLaunchName(commit);
        launchNameInput.dataset.lastCommit = commit.sha;
        previewFrame.hidden = false;
        previewEmpty.hidden = true;
        previewFrame.srcdoc = raw;
        contentEditor.value = raw;
        const author = commit.commit?.author?.name || commit.commit?.committer?.name || 'Unknown author';
        const metaPieces = [
          `Commit <strong>${commit.sha.slice(0,7)}</strong>`,
          `by <strong>${escapeHtml(author)}</strong>`,
          state.committedAt ? `on ${new Date(state.committedAt).toLocaleString()}` : ''
        ].filter(Boolean);
        previewMeta.innerHTML = metaPieces.join(' • ');
        previewMeta.hidden = false;
        actionsGrid.hidden = false;
        launchTabBtn.disabled = false;
        launchCloneBtn.disabled = false;
        setStatus(launchStatus, '');
        setStatus(fileStatus, `Loaded ${state.selectedFile} from commit ${commit.sha.slice(0,7)}.`, { tone: 'success' });
      } catch (error) {
        console.error('Failed to load file content', error);
        setStatus(fileStatus, `Unable to fetch file content: ${error.message}`, { tone: 'error' });
      }
    }

    async function launchCommitVersion(commit) {
      if (!state.selectedFile) {
        setStatus(launchStatus, 'Select a file before launching a snapshot.', { tone: 'error' });
        return;
      }
      const target = commit || state.selectedCommit;
      if (!target) {
        setStatus(launchStatus, 'Pick a commit to launch.', { tone: 'error' });
        return;
      }
      setStatus(launchStatus, 'Preparing snapshot…', { spinner: true });
      try {
        if (!state.selectedCommit || state.selectedCommit.sha !== target.sha) {
          await selectCommit(target);
        }
        const snapshot = await fetchCommitContent(target);
        const tabName = resolveLaunchName(target);
        openContentInNewTab(snapshot, tabName);
        setStatus(launchStatus, `Opened ${tabName} in a new tab.`, { tone: 'success' });
      } catch (error) {
        console.error('Failed to launch snapshot tab', error);
        setStatus(launchStatus, `Unable to launch tab: ${error.message}`, { tone: 'error' });
      }
    }

    function launchEditedVersion() {
      if (!state.selectedCommit) {
        setStatus(launchStatus, 'Pick a commit before launching a test tab.', { tone: 'error' });
        return;
      }
      if (!contentEditor.value.trim()) {
        setStatus(launchStatus, 'Load a commit and make any edits before launching a test tab.', { tone: 'error' });
        return;
      }
      setStatus(launchStatus, 'Opening test tab…', { spinner: true });
      try {
        const name = resolveLaunchName(state.selectedCommit, { variant: 'test' });
        openContentInNewTab(contentEditor.value, name);
        setStatus(launchStatus, `Opened ${name} for testing in a new tab.`, { tone: 'success' });
      } catch (error) {
        console.error('Failed to launch edited snapshot', error);
        setStatus(launchStatus, `Unable to launch tab: ${error.message}`, { tone: 'error' });
      }
    }

    function switchToTab(tab) {
      tabButtons.forEach(button => {
        const isActive = button.dataset.tab === tab;
        button.classList.toggle('active', isActive);
      });
      historyTab.classList.toggle('active', tab === 'history');
      previewTab.classList.toggle('active', tab === 'preview');
    }

    async function publishSnapshot(event) {
      event.preventDefault();
      if (!state.content) {
        setStatus(publishStatus, 'Load a commit first.', { tone: 'error' });
        return;
      }
      const owner = destOwnerInput.value.trim() || state.owner;
      const repo = destRepoInput.value.trim() || state.repo;
      const branch = destBranchInput.value.trim() || state.branch || state.defaultBranch;
      const pathInput = destPathInput.value.trim() || state.selectedFile;
      const normalizedPath = pathInput ? pathInput.replace(/^\//, '') : '';
      const message = commitMessageInput.value.trim() || `Add snapshot of ${normalizedPath}`;
      const baseBranch = baseBranchInput.value.trim();
      if (!owner || !repo || !branch || !normalizedPath) {
        setStatus(publishStatus, 'Owner, repo, branch, and path are required.', { tone: 'error' });
        return;
      }
      try {
        destPathInput.value = normalizedPath;
        setStatus(publishStatus, `Publishing ${normalizedPath} to ${owner}/${repo}@${branch}…`, { spinner: true });
        await ensureBranchExists({ owner, repo, branch, baseBranch });
        const existing = await fetchExistingFile({ owner, repo, path: normalizedPath, branch });
        const payload = {
          message,
          content: encodeContent(contentEditor.value),
          branch
        };
        if (existing?.sha) {
          payload.sha = existing.sha;
        }
        await apiFetch(`/repos/${owner}/${repo}/contents/${encodePath(normalizedPath)}`, {
          method: 'PUT',
          body: JSON.stringify(payload)
        });
        setStatus(publishStatus, `Snapshot pushed to ${owner}/${repo}@${branch}!`, { tone: 'success' });
      } catch (error) {
        console.error('Failed to publish snapshot', error);
        setStatus(publishStatus, `Unable to publish snapshot: ${error.message}`, { tone: 'error' });
      }
    }

    async function ensureBranchExists({ owner, repo, branch, baseBranch }) {
      try {
        await apiFetch(`/repos/${owner}/${repo}/git/ref/heads/${encodeURIComponent(branch)}`);
        return;
      } catch (error) {
        if (error.status !== 404) throw error;
      }
      const fallbackBranch = baseBranch || state.defaultBranch || 'main';
      const baseRef = await apiFetch(`/repos/${owner}/${repo}/git/ref/heads/${encodeURIComponent(fallbackBranch)}`);
      const sha = baseRef.object?.sha;
      if (!sha) {
        throw new Error(`Cannot create branch ${branch}; base ${fallbackBranch} not found.`);
      }
      await apiFetch(`/repos/${owner}/${repo}/git/refs`, {
        method: 'POST',
        body: JSON.stringify({ ref: `refs/heads/${branch}`, sha })
      });
    }

    async function fetchExistingFile({ owner, repo, path, branch }) {
      try {
        return await apiFetch(`/repos/${owner}/${repo}/contents/${encodePath(path)}?ref=${branch}`);
      } catch (error) {
        if (error.status === 404) return null;
        throw error;
      }
    }

    function updatePreviewFromEditor() {
      const updated = contentEditor.value;
      previewFrame.srcdoc = updated;
      state.content = updated;
      setStatus(fileStatus, 'Preview updated from editor.', { tone: 'success' });
    }

    async function copyContent() {
      try {
        await navigator.clipboard.writeText(contentEditor.value);
        setStatus(fileStatus, 'Snapshot copied to clipboard.', { tone: 'success' });
      } catch (error) {
        console.error('Failed to copy', error);
        setStatus(fileStatus, `Unable to copy: ${error.message}`, { tone: 'error' });
      }
    }

    function downloadContent() {
      const blob = new Blob([contentEditor.value], { type: 'text/html;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      const name = resolveLaunchName(state.selectedCommit);
      link.href = url;
      link.download = name;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      setStatus(fileStatus, 'Snapshot downloaded.', { tone: 'success' });
    }

    function openGithub() {
      if (!state.commitUrl) return;
      window.open(state.commitUrl, '_blank', 'noopener');
    }

    function openPages() {
      const owner = destOwnerInput.value.trim() || state.owner;
      const repo = destRepoInput.value.trim() || state.repo;
      const branch = destBranchInput.value.trim() || 'gh-pages';
      const pathValue = destPathInput.value.trim() || state.selectedFile;
      const normalizedPath = pathValue ? pathValue.replace(/^\//, '') : '';
      if (!owner || !repo || !normalizedPath) return;
      destPathInput.value = normalizedPath;
      const base = branch === 'gh-pages'
        ? `https://${owner}.github.io/${repo}`
        : `https://${owner}.github.io/${repo}/${encodeURIComponent(branch)}`;
      const url = `${base}/${encodePath(normalizedPath)}`;
      window.open(url, '_blank', 'noopener');
    }

    saveTokenBtn.addEventListener('click', () => {
      const token = tokenInput.value.trim();
      if (!token) {
        setStatus(tokenStatus, 'Enter a personal access token.', { tone: 'error' });
        return;
      }
      storage.setItem(TOKEN_KEY, token);
      state.token = token;
      setStatus(tokenStatus, 'Token saved locally for this browser.', { tone: 'success' });
    });

    clearTokenBtn.addEventListener('click', () => {
      storage.removeItem(TOKEN_KEY);
      state.token = null;
      tokenInput.value = '';
      setStatus(tokenStatus, 'Token removed. API requests will fail until you add one again.', { tone: 'error' });
    });

    resetSettingsBtn.addEventListener('click', () => {
      storage.removeItem(SETTINGS_KEY);
      ownerInput.value = '';
      repoInput.value = '';
      branchInput.value = '';
      state.owner = '';
      state.repo = '';
      state.branch = '';
      state.files = [];
      state.filteredFiles = [];
      renderFileOptions();
      setStatus(repoStatus, 'Defaults reset.', { tone: 'success' });
    });

    loadRepoBtn.addEventListener('click', () => {
      loadRepositoryFiles();
    });

    ownerInput.addEventListener('change', persistSettings);
    repoInput.addEventListener('change', persistSettings);
    branchInput.addEventListener('change', persistSettings);

    fileFilterInput.addEventListener('input', () => {
      applyFileFilter();
    });

    fileSelect.addEventListener('change', () => {
      const value = fileSelect.value;
      loadFileHistory(value);
    });

    historySearchInput.addEventListener('input', () => {
      applyHistoryFilter();
    });

    tabButtons.forEach(button => {
      button.addEventListener('click', () => {
        switchToTab(button.dataset.tab);
      });
    });

    refreshPreviewBtn.addEventListener('click', () => {
      updatePreviewFromEditor();
    });

    copyContentBtn.addEventListener('click', () => {
      copyContent();
    });

    downloadContentBtn.addEventListener('click', () => {
      downloadContent();
    });

    launchTabBtn.addEventListener('click', () => {
      launchCommitVersion(state.selectedCommit);
    });

    launchCloneBtn.addEventListener('click', () => {
      launchEditedVersion();
    });

    launchNameInput.addEventListener('input', () => {
      const value = launchNameInput.value.trim();
      if (value) {
        launchNameInput.dataset.manual = 'true';
        if (state.selectedCommit) {
          launchNameInput.dataset.lastCommit = state.selectedCommit.sha;
        }
      } else {
        launchNameInput.dataset.manual = '';
        if (state.selectedCommit) {
          updateLaunchName(state.selectedCommit);
        }
      }
    });

    publishForm.addEventListener('submit', publishSnapshot);
    openGithubBtn.addEventListener('click', openGithub);
    openPagesBtn.addEventListener('click', openPages);
    commitMessageInput.addEventListener('input', () => {
      commitMessageInput.dataset.manual = commitMessageInput.value.trim() ? 'true' : '';
    });

    hydrateSettings();

    // If URL has query params (owner, repo, path, sha) use them to preload state
    const params = new URLSearchParams(window.location.search);
    if (params.has('owner')) {
      ownerInput.value = params.get('owner');
      state.owner = params.get('owner');
    }
    if (params.has('repo')) {
      repoInput.value = params.get('repo');
      state.repo = params.get('repo');
    }
    if (params.has('branch')) {
      branchInput.value = params.get('branch');
      state.branch = params.get('branch');
    }
    if (params.has('token')) {
      tokenInput.value = params.get('token');
      saveTokenBtn.click();
    }

    if (state.owner && state.repo) {
      loadRepositoryFiles().then(() => {
        const path = params.get('path');
        const sha = params.get('sha');
        if (path) {
          const normalizedPath = path.replace(/^\//, '');
          fileSelect.value = normalizedPath;
          loadFileHistory(normalizedPath).then(() => {
            if (sha) {
              const commit = state.commits.find(entry => entry.sha === sha);
              if (commit) {
                selectCommit(commit);
              }
            }
          });
        }
      }).catch(() => {});
    }
  </script>
</body>
</html>