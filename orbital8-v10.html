<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Triangle Grid Mixed Patterns</title>
  <style>
    html, body { margin: 0; background: #555; overflow: hidden; }
    canvas { display: block; }
    #controls {
      position: absolute; bottom: 10px; left: 10px; right: 10px;
      display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;
    }
    button {
      font-size: 14px;
      padding: 6px 12px;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="controls">
  <button onclick="setPattern('checkerboard')">Checkerboard</button>
  <button onclick="setPattern('radial')">Radial</button>
  <button onclick="setPattern('wave')">Wave</button>
  <button onclick="setPattern('mod')">Modulo</button>
  <button onclick="setPattern('primes')">Primes</button>
</div>
<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
let w = canvas.width = window.innerWidth;
let h = canvas.height = window.innerHeight;

const cols = 10, rows = 10, size = 60;
const colors = ['#000', '#fff', '#0ff', '#f0f', '#ff0'];
const tiles = [];

let patternMode = 'checkerboard';
let blendMode = null;
let loopIndex = 0;
let frameCount = 0;

function createTiles() {
  tiles.length = 0;
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const cx = x * size + size / 2 + 50;
      const cy = y * size + size / 2 + 50;
      tiles.push({ cx, cy, state: [0, 0, 0, 0], x, y });
    }
  }
}

function drawTriangle(cx, cy, quad, color) {
  const s = size / 2;
  ctx.beginPath();
  if (quad === 0) { ctx.moveTo(cx, cy); ctx.lineTo(cx - s, cy - s); ctx.lineTo(cx + s, cy - s); }
  if (quad === 1) { ctx.moveTo(cx, cy); ctx.lineTo(cx + s, cy - s); ctx.lineTo(cx + s, cy + s); }
  if (quad === 2) { ctx.moveTo(cx, cy); ctx.lineTo(cx + s, cy + s); ctx.lineTo(cx - s, cy + s); }
  if (quad === 3) { ctx.moveTo(cx, cy); ctx.lineTo(cx - s, cy + s); ctx.lineTo(cx - s, cy - s); }
  ctx.closePath();
  ctx.fillStyle = color;
  ctx.fill();
}

function drawTile(tile) {
  for (let i = 0; i < 4; i++) {
    drawTriangle(tile.cx, tile.cy, i, colors[tile.state[i]]);
  }
}

function drawAll() {
  ctx.clearRect(0, 0, w, h);
  for (let t of tiles) drawTile(t);
}

const modes = {
  checkerboard(tile, tri) {
    return (tile.x + tile.y + tri) % 2;
  },
  radial(tile, tri) {
    let dx = tile.cx - w / 2, dy = tile.cy - h / 2;
    let dist = Math.sqrt(dx * dx + dy * dy);
    return Math.floor((dist / 50 + tri) % colors.length);
  },
  wave(tile, tri) {
    return Math.floor((Math.sin(tile.x / 2 + tri) + 1) * 2);
  },
  mod(tile, tri) {
    return (tile.x * rows + tile.y + tri) % colors.length;
  },
  primes(tile, tri) {
    let i = tile.y * cols + tile.x;
    function isPrime(n) {
      if (n < 2) return false;
      for (let d = 2; d * d <= n; d++) if (n % d === 0) return false;
      return true;
    }
    return isPrime(i) ? (tri % 2) + 1 : 0;
  }
};

function setPattern(name) {
  patternMode = name;
  blendMode = null;
}

function updatePatternCycle() {
  const keys = Object.keys(modes);
  const i = Math.floor(Math.random() * keys.length);
  const j = Math.floor(Math.random() * keys.length);
  patternMode = keys[i];
  blendMode = keys[j] !== patternMode ? keys[j] : null;
}

function updateOneTriangle() {
  const totalTriangles = tiles.length * 4;
  const triIndex = loopIndex % totalTriangles;
  const tileId = Math.floor(triIndex / 4);
  const triId = triIndex % 4;
  const tile = tiles[tileId];
  let value = 0;

  if (tile && modes[patternMode]) {
    value = modes[patternMode](tile, triId);
    if (blendMode && modes[blendMode]) {
      const blendVal = modes[blendMode](tile, triId);
      value = (value + blendVal) % colors.length;
    }
    tile.state[triId] = value;
  }

  if (loopIndex % 300 === 0) updatePatternCycle();
  loopIndex++;
  frameCount++;
}

function animationLoop() {
  updateOneTriangle();
  drawAll();
  requestAnimationFrame(animationLoop);
}

function handleClick(e) {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  for (let tile of tiles) {
    if (Math.abs(mx - tile.cx) <= size / 2 && Math.abs(my - tile.cy) <= size / 2) {
      const dx = mx - tile.cx;
      const dy = my - tile.cy;
      let quad = 0;
      if (dx > 0 && dy < 0) quad = 1;
      else if (dx > 0 && dy > 0) quad = 2;
      else if (dx < 0 && dy > 0) quad = 3;
      tile.state[quad] = (tile.state[quad] + 1) % colors.length;
    }
  }
}

canvas.addEventListener('click', handleClick);
createTiles();
drawAll();
animationLoop();
</script>
</body>
</html>
