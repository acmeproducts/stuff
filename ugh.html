<!-- Infinite Quilt-Baseline-7.0.0-2026-01-08 12:05 AM -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>Infinite Quilt — Baseline Optimized</title>
<style>
  :root {
    --bg: #0b0c0f; --fg: #e6e6e6; --muted: #a9b2bf; --accent: #6aa9ff; --panel: #0e1219; --border: #1e2531;
    --safe-bottom: env(safe-area-inset-bottom, 0px);
    --safe-top: env(safe-area-inset-top, 0px);
  }
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
  html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, sans-serif; overflow: hidden; }
  #app { position: fixed; inset: 0; display: grid; grid-template-rows: 1fr auto; }
  canvas { display: block; width: 100%; height: 100%; touch-action: none; background: var(--bg); }
  
  #bar {
    position: fixed; left: 0; right: 0; bottom: 0;
    padding: 10px 12px calc(10px + var(--safe-bottom));
    display: flex; gap: 10px; justify-content: center; align-items: center;
    background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.5) 50%, rgba(0,0,0,0.8) 100%);
    z-index: 100;
  }
  .btn {
    min-width: 52px; min-height: 44px; padding: 10px 14px; border: 1px solid var(--border);
    background: var(--panel); color: var(--fg); border-radius: 14px; font-weight: 650;
    display: flex; align-items: center; justify-content: center; cursor: pointer;
  }
  .btn.toggle.on { outline: 2px solid var(--accent); background: #161b22; }
  .btn:active { transform: translateY(1px); }

  #readout {
    position: fixed; left: 10px; top: calc(8px + var(--safe-top));
    padding: 6px 10px; border: 1px solid var(--border); background: rgba(14,18,25,0.85);
    border-radius: 10px; font-size: 11px; color: var(--muted); font-variant-numeric: tabular-nums;
    z-index: 110; pointer-events: none; white-space: pre-line; backdrop-filter: blur(4px);
  }

  #drawer {
    position: fixed; left: 0; right: 0; bottom: calc(78px + var(--safe-bottom));
    margin: 0 auto; max-width: 900px;
    transform: translateY(115%); transition: transform .3s ease;
    padding: 10px 12px; z-index: 90;
  }
  #drawer.open { transform: translateY(0%); }
  .panel {
    background: rgba(14,18,25,0.98); border: 1px solid var(--border);
    border-radius: 16px; padding: 12px;
    display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.6);
  }
  .row { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
  label { font-size: 11px; color: var(--muted); text-transform: uppercase; letter-spacing: 1px; }
  input[type=range] { flex: 1; accent-color: var(--accent); }
  input[type=number] { width: 85px; background: #0f131b; color: var(--fg); border: 1px solid var(--border); border-radius: 10px; padding: 6px 8px; }
  
  #master-footer {
    position: fixed; bottom: 2px; left: 0; right: 0; text-align: center;
    font-size: 9px; color: var(--muted); opacity: 0.5; pointer-events: none; z-index: 101;
  }
  @media(min-width:720px) { .panel { grid-template-columns: repeat(3, 1fr); } }
</style>
</head>
<body>
<div id="app">
  <canvas id="c"></canvas>
  <div id="readout">Initializing Baseline...</div>
  
  <div id="drawer">
    <div class="panel">
      <div class="row"><label>Base px</label><input id="tilepx" type="number" value="256"></div>
      <div class="row"><label>Stroke</label><input id="stroke" type="range" min="0.5" max="4" step="0.1" value="1.2"></div>
      <div class="row"><label>Complexity</label><input id="layers" type="range" min="1" max="6" step="1" value="3"></div>
      <div class="row"><label>Snap</label><button id="snap" class="btn toggle on">Snap</button></div>
      <div class="row"><label>Grid</label><button id="grid" class="btn toggle on">Grid</button></div>
      <div class="row"><label>Bands</label><button id="bands" class="btn toggle">Bands</button></div>
      <div class="row"><label>Max Zoom</label><input id="maxlvl" type="number" value="1024"></div>
      <div class="row"><label>Seed</label><input id="seed" type="number" value="1337"></div>
      <div class="row"><label>PNG scale</label><input id="scale" type="range" min="1" max="4" step="1" value="1"></div>
    </div>
  </div>

  <div id="bar">
    <button id="gear" class="btn">⚙︎</button>
    <button id="minus" class="btn">−</button>
    <button id="plus" class="btn">＋</button>
    <button id="home" class="btn">⟲</button>
    <button id="shot" class="btn">PNG</button>
  </div>
  
  <footer id="master-footer">Infinite Quilt Baseline-7.0.0-2026-01-08 12:05 AM</footer>
</div>

<script>
/**
 * RE-ENGINEERED BASELINE ARCHITECTURE
 * 1. Predictive Hierarchical Cache: identifying tiles for Z to Z+10 in advance.
 * 2. Relative Origin Math: Prevents floating point jitter by anchoring to camera.
 * 3. Atomic Processing: Background queue renders exactly 1 tile per frame to prevent crashes.
 */

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
let DPR = Math.min(2, window.devicePixelRatio || 1);

const state = {
  cam: { x: 0, y: 0, z: 0 },
  seed: 1337,
  basePx: 256,
  snapOn: true,
  gridOn: true,
  bandsOn: false,
  maxLvl: 1024,
  cache: new Map(),
  queue: [],
  lastZBase: -999,
  isPinching: false
};

// Baseline PRNG (Original)
function lcg(s) {
  let h = (s >>> 0) || 1;
  return function() { h = (h * 1664525 + 1013904223) >>> 0; return h / 4294967296; };
}

function hashTile(z, i, j) {
  // Incorporate zoom level to ensure unique patterns per hierarchical depth
  let s = (((i | 0) * 374761393) ^ ((j | 0) * 668265263) ^ (z * 1337) ^ state.seed) >>> 0;
  return lcg(s ^ (s >>> 13));
}

// Procedural Drawing Baseline
function renderTile(z, i, j) {
  const size = state.basePx * DPR;
  const buffer = document.createElement('canvas');
  buffer.width = size; buffer.height = size;
  const tctx = buffer.getContext('2d');

  const rand = hashTile(z, i, j);
  const r1 = rand();
  const baseCol = `hsl(${Math.floor(360 * r1)}, 35%, ${50 + Math.floor(20 * (rand() - 0.5))}%)`;
  const accCol  = `hsl(${(Math.floor(360 * r1) + 40) % 360}, 60%, 65%)`;
  
  tctx.fillStyle = baseCol; 
  tctx.fillRect(0, 0, size, size);

  const layers = parseInt(document.getElementById('layers').value);
  const strokeW = parseFloat(document.getElementById('stroke').value) * DPR;

  tctx.save();
  tctx.beginPath(); tctx.rect(0, 0, size, size); tctx.clip();

  for (let L = 0; L < layers; L++) {
    const div = Math.pow(2, L + 1);
    const step = size / div;
    tctx.lineWidth = strokeW * (1 + L * 0.25);
    tctx.strokeStyle = L % 2 === 0 ? 'rgba(255,255,255,0.12)' : 'rgba(0,0,0,0.15)';
    tctx.beginPath();
    for (let g = 1; g < div; g++) {
      tctx.moveTo(g * step, 0); tctx.lineTo(g * step, size);
      tctx.moveTo(0, g * step); tctx.lineTo(size, g * step);
    }
    tctx.stroke();
  }

  // Visual Accents (Baseline Logic)
  tctx.lineWidth = strokeW * 1.5; tctx.strokeStyle = accCol; tctx.fillStyle = 'rgba(255,255,255,0.06)';
  const pr = lcg(((i * 73856093) ^ (j * 19349663) ^ (z * 13) ^ state.seed) >>> 0);
  for (let k = 0; k < 4; k++) {
    const u = pr(), v = pr(), w = 0.08 + 0.25 * pr(), h = 0.08 + 0.25 * pr();
    tctx.beginPath(); tctx.rect(u * (1 - w) * size, v * (1 - h) * size, w * size, h * size); tctx.fill(); tctx.stroke();
  }

  if (state.gridOn) {
    tctx.lineWidth = strokeW * 1.2; 
    tctx.strokeStyle = 'rgba(0,0,0,0.35)'; 
    tctx.strokeRect(0, 0, size, size); 
  }
  tctx.restore();
  return buffer;
}

function getCachedTile(z, i, j) {
  const key = `${z}_${i}_${j}_${state.seed}`;
  if (state.cache.has(key)) return state.cache.get(key);
  // Synchronous fallback (rarely used due to queue)
  const t = renderTile(z, i, j);
  if (state.cache.size > 1000) state.cache.delete(state.cache.keys().next().value);
  state.cache.set(key, t);
  return t;
}

// Background Task: PRE-CALCULATE 10 LEVELS AHEAD
function updateQueue(zBase) {
  if (zBase === state.lastZBase) return;
  state.lastZBase = zBase;
  state.queue = []; 

  // Looking 10 levels deep from current
  const ahead = 10;
  for (let l = -1; l <= ahead; l++) {
    const tz = zBase + l;
    if (Math.abs(tz) > state.maxLvl) continue;
    
    const worldScale = Math.pow(2, tz);
    const ci = Math.floor(state.cam.x * worldScale);
    const cj = Math.floor(state.cam.y * worldScale);
    
    for (let di = -1; di <= 1; di++) {
      for (let dj = -1; dj <= 1; dj++) {
        const key = `${tz}_${ci+di}_${cj+dj}_${state.seed}`;
        if (!state.cache.has(key)) {
          state.queue.push({ z: tz, i: ci+di, j: cj+dj, key });
        }
      }
    }
  }
}

function processQueue() {
  if (state.queue.length > 0) {
    const job = state.queue.shift();
    if (!state.cache.has(job.key)) {
      state.cache.set(job.key, renderTile(job.z, job.i, job.j));
    }
  }
}

// Math & Interaction
function resize() {
  DPR = Math.min(2, window.devicePixelRatio || 1);
  canvas.width = window.innerWidth * DPR;
  canvas.height = window.innerHeight * DPR;
}

function pxPerWorld() { return state.basePx * Math.pow(2, state.cam.z); }

function screenToWorld(px, py) {
  const s = pxPerWorld(), cx = canvas.width * 0.5, cy = canvas.height * 0.5;
  return { x: state.cam.x + (px - cx) / s, y: state.cam.y + (py - cy) / s };
}

function zoomAt(px, py, dz) {
  const before = screenToWorld(px, py);
  state.cam.z = Math.max(-state.maxLvl, Math.min(state.maxLvl, state.cam.z + dz));
  if (state.snapOn && !state.isPinching) state.cam.z = Math.round(state.cam.z * 4) / 4;
  const after = screenToWorld(px, py);
  state.cam.x += (before.x - after.x);
  state.cam.y += (before.y - after.y);
  updateQueue(Math.floor(state.cam.z));
}

// Event Setup
const pointers = new Map();
let pDist = 0, lastTap = 0;

canvas.addEventListener('pointerdown', e => {
  canvas.setPointerCapture(e.pointerId);
  pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
});

canvas.addEventListener('pointerup', e => {
  pointers.delete(e.pointerId);
  if (pointers.size < 2) pDist = 0;
  state.isPinching = false;
  const now = performance.now();
  if (now - lastTap < 300) zoomAt(e.clientX * DPR, e.clientY * DPR, 1);
  lastTap = now;
});

canvas.addEventListener('pointermove', e => {
  if (!pointers.has(e.pointerId)) return;
  const p = pointers.get(e.pointerId);
  const dx = e.clientX - p.x, dy = e.clientY - p.y;
  p.x = e.clientX; p.y = e.clientY;

  if (pointers.size === 1) {
    const s = pxPerWorld();
    state.cam.x -= (dx * DPR) / s;
    state.cam.y -= (dy * DPR) / s;
  } else if (pointers.size === 2) {
    state.isPinching = true;
    const pts = Array.from(pointers.values());
    const d = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
    if (pDist > 0) zoomAt((pts[0].x+pts[1].x)/2*DPR, (pts[0].y+pts[1].y)/2*DPR, Math.log2(d / pDist));
    pDist = d;
  }
});

canvas.addEventListener('wheel', e => { e.preventDefault(); zoomAt(e.clientX * DPR, e.clientY * DPR, -Math.sign(e.deltaY) * 0.25); }, { passive: false });

function setupUI() {
  const toggle = (id, k) => {
    const b = document.getElementById(id);
    b.onclick = () => { state[k] = !state[k]; b.classList.toggle('on', state[k]); state.cache.clear(); updateQueue(Math.floor(state.cam.z)); };
  };
  toggle('snap', 'snapOn'); toggle('grid', 'gridOn'); toggle('bands', 'bandsOn');
  document.getElementById('gear').onclick = () => document.getElementById('drawer').classList.toggle('open');
  document.getElementById('home').onclick = () => { state.cam = { x: 0, y: 0, z: 0 }; state.cache.clear(); updateQueue(0); };
  document.getElementById('plus').onclick = () => zoomAt(canvas.width / 2, canvas.height / 2, 1);
  document.getElementById('minus').onclick = () => zoomAt(canvas.width / 2, canvas.height / 2, -1);
  document.getElementById('tilepx').onchange = e => { state.basePx = +e.target.value; state.cache.clear(); updateQueue(Math.floor(state.cam.z)); };
}

function render() {
  resize();
  ctx.fillStyle = '#0b0c0f';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const zBase = Math.floor(state.cam.z);
  const zFrac = state.cam.z - zBase;
  const zoomScale = Math.pow(2, zFrac);
  const currentTileSize = state.basePx * zoomScale * DPR;

  const cx = canvas.width * 0.5, cy = canvas.height * 0.5;
  const worldScale = Math.pow(2, zBase);

  // Precision Anchor Logic
  const imin = Math.floor(state.cam.x * worldScale - cx / currentTileSize);
  const imax = Math.ceil(state.cam.x * worldScale + cx / currentTileSize);
  const jmin = Math.floor(state.cam.y * worldScale - cy / currentTileSize);
  const jmax = Math.ceil(state.cam.y * worldScale + cy / currentTileSize);

  if (state.bandsOn) {
    ctx.globalAlpha = Math.max(0, Math.min(0.2 * Math.abs(zFrac - 0.5), 0.2));
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.globalAlpha = 1;
  }

  for (let j = jmin; j <= jmax; j++) {
    for (let i = imin; i <= imax; i++) {
      const tile = getCachedTile(zBase, i, j);
      // RELATIVE CALCULATION: Subtraction BEFORE scaling prevents deep-zoom jitter
      const dx = cx + (i - state.cam.x * worldScale) * currentTileSize;
      const dy = cy + (j - state.cam.y * worldScale) * currentTileSize;
      ctx.drawImage(tile, dx, dy, currentTileSize + 0.5, currentTileSize + 0.5);
    }
  }

  document.getElementById('readout').textContent = `X: ${state.cam.x.toPrecision(8)}\nY: ${state.cam.y.toPrecision(8)}\nZ: ${state.cam.z.toFixed(2)}\nQueued: ${state.queue.length}`;
}

setupUI();
updateQueue(0);
(function loop() { processQueue(); render(); requestAnimationFrame(loop); })();
</script>
</body>
</html>