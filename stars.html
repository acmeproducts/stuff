<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Starfield Strike — Mobile/Tablet</title>
<style>
  :root{
    --ui-bg: rgba(0,0,0,0.55);
    --ui-border: rgba(255,255,255,0.18);
    --ui-fg:#eaeaea;
    --accent:#9ad1ff;
  }
  html, body { margin:0; padding:0; height:100%; background:#000; color:#ddd;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial;
    -webkit-user-select: none; user-select:none; touch-action: none;
    -webkit-touch-callout: none;
  }
  #wrap { position:relative; width:100%; height:100vh; overflow:hidden; }
  canvas { position:absolute; inset:0; width:100%; height:100%; display:block; }
  #bg{ z-index:0; } #game{ z-index:1; }

  /* ===== Drawer (tiny handle) ===== */
  #drawer{ position:absolute; right:0; top:50%; transform:translateY(-50%); z-index:3; display:flex; align-items:center; pointer-events:auto; }
  #drawer .panel{
    width:0; max-width:320px; overflow:hidden; transition: width 160ms ease;
    background:var(--ui-bg); border:1px solid var(--ui-border); border-right:none; border-radius:10px 0 0 10px;
    color:var(--ui-fg); padding:10px 0;
  }
  #drawer.open .panel{ width:min(70vw, 280px); }
  #drawer .handle{
    width:18px; height:84px; margin-left:4px; border-radius:9px 0 0 9px;
    background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.2); border-right:0;
    display:flex; align-items:center; justify-content:center; color:#ccc; font-size:12px; writing-mode:vertical-rl; text-orientation:mixed;
    cursor:pointer; touch-action:manipulation;
  }
  #drawer .content{ padding:0 12px; }
  #drawer h2{ font-size:13px; margin:0 0 6px 0; color:#fff; }
  #drawer label{ display:block; font-size:12px; margin-top:8px; }
  #drawer input[type="range"], #drawer input[type="number"]{ width:100%; }
  #drawer .row{ display:grid; grid-template-columns:1fr 1fr; gap:8px; }
  #drawer small{ color:#aac; }

  /* ===== Mobile on-screen controls ===== */
  #controls{
    position:absolute; left:0; right:0; bottom:0; z-index:2; pointer-events:auto;
    padding: calc(env(safe-area-inset-bottom, 0) + 10px) 12px 12px 12px;
    display:flex; justify-content:space-between; gap:12px;
  }
  .pad-area{
    position:relative; width: 34vw; height: 34vw; max-width:260px; max-height:260px; min-width:140px; min-height:140px;
  }
  .pad{
    position:absolute; inset:0; border-radius:50%;
    background: rgba(255,255,255,0.035);
    border:1px solid rgba(255,255,255,0.10);
    backdrop-filter: blur(2px);
  }
  .stick{
    position:absolute; width:36%; height:36%; left:32%; top:32%; border-radius:50%;
    background: rgba(255,255,255,0.16);
    border:1px solid rgba(255,255,255,0.32);
    transition: transform 70ms ease-out;
  }
  .buttons{ display:flex; flex-direction:column; gap:10px; align-items:flex-end; }
  .btn{
    min-width: 108px; min-height: 52px; padding:9px 12px; font-size:16px;
    border-radius:12px; background: rgba(255,255,255,0.07); color:#f2f2f2; border:1px solid rgba(255,255,255,0.2);
  }
  .btn:active{ transform: translateY(1px); }

  /* Landscape: make joystick smaller & less obtrusive */
  @media (orientation:landscape){
    .pad-area{ width: 24vw; height:24vw; max-width: 200px; max-height:200px; opacity:0.8; }
    .btn{ min-width: 96px; min-height: 46px; font-size:15px; }
    #drawer .handle{ height:64px; }
  }

  /* Desktop: hide on-screen controls */
  @media (hover:hover) and (pointer:fine){
    #controls{ display:none; }
  }

  /* Footer info */
  #footer{
    position:absolute; left:10px; bottom:10px; z-index:2; color:#9aa; font-size:12px;
    background: rgba(0,0,0,0.45); padding:6px 8px; border:1px solid var(--ui-border); border-radius:6px;
  }
  #footer kbd{ background:#0a0a0a; border:1px solid #333; border-radius:4px; padding:1px 4px; font-size:11px; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="bg" aria-hidden="true"></canvas>
  <canvas id="game" aria-label="Starfield Strike game canvas"></canvas>

  <!-- Slim right-edge drawer with tiny handle -->
  <div id="drawer" aria-label="Config">
    <div class="panel" role="region" aria-labelledby="configTitle">
      <div class="content">
        <h2 id="configTitle">Config</h2>
        <label for="density">Density <span id="densityVal"></span></label>
        <input id="density" type="range" min="0" max="0.2" step="0.001" value="0.035" />
        <div class="row">
          <div>
            <label for="speedX">Speed X</label>
            <input id="speedX" type="number" step="1" value="60" />
          </div>
          <div>
            <label for="speedY">Speed Y</label>
            <input id="speedY" type="number" step="1" value="0" />
          </div>
        </div>
        <small>Shader: <code>fract(uv)*step(random(floor(uv)), density)</code></small>
      </div>
    </div>
    <div class="handle" id="handle" title="Open settings">SET</div>
  </div>

  <!-- Mobile/Tablet controls -->
  <div id="controls" aria-label="On-screen controls">
    <div class="pad-area" id="joyArea" aria-label="Joystick">
      <div class="pad"></div>
      <div class="stick" id="stick"></div>
    </div>
    <div class="buttons">
      <button class="btn" id="fireBtn" aria-label="Fire">FIRE</button>
      <button class="btn" id="pauseBtn" aria-label="Pause/Resume">PAUSE</button>
      <button class="btn" id="startBtn" aria-label="Start/Restart">START</button>
    </div>
  </div>

  <div id="footer">
    <strong>Starfield Strike</strong> — Mobile/Tablet: joystick + buttons. Desktop: <kbd>WASD</kbd>/<kbd>←→↑↓</kbd>, <kbd>Space</kbd>, <kbd>P</kbd>, <kbd>Enter</kbd>.
  </div>
</div>

<script>
/* Block page gestures that break gameplay (esp. iOS/iPadOS Safari) */
addEventListener('gesturestart', e => e.preventDefault(), {passive:false});
addEventListener('touchmove',   e => { if (e.touches.length) e.preventDefault(); }, {passive:false});

/* ============ Starfield (WebGL) ============ */
(function(){
  const bg = document.getElementById('bg');
  let gl = bg.getContext('webgl', {premultipliedAlpha:false, alpha:false, antialias:false, preserveDrawingBuffer:false});
  let fallback2D = null;

  const vsSource = `
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    varying vec2 v_pos;
    void main(){
      v_pos = (a_position * 0.5 + 0.5) * u_resolution; // pixel space
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  `;
  const fsSource = `
    precision mediump float;
    uniform float u_time;
    uniform vec2  u_starSpeed;
    uniform float u_density;
    uniform sampler2D u_texture;
    uniform vec2  u_texturePixelSize; // 1/texSize
    varying vec2 v_pos;

    float random(vec2 st){
      return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }
    void main(){
      vec2 uv = (v_pos + u_time * u_starSpeed) * u_texturePixelSize;
      uv = fract(uv) * step(random(floor(uv)), u_density);
      gl_FragColor = texture2D(u_texture, uv);
    }
  `;

  function shader(t,s){ const o=gl.createShader(t); gl.shaderSource(o,s); gl.compileShader(o);
    if(!gl.getShaderParameter(o, gl.COMPILE_STATUS)){ console.warn(gl.getShaderInfoLog(o)); return null;} return o; }
  function program(vs,fs){ const p=gl.createProgram(); gl.attachShader(p,vs); gl.attachShader(p,fs); gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){ console.warn(gl.getProgramInfoLog(p)); return null;} return p; }

  // 1x1 white texture => visible stars wherever step()==1
  function makeWhiteTex(){
    const t = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, t);
    const white = new Uint8Array([255,255,255,255]);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1,1,0, gl.RGBA, gl.UNSIGNED_BYTE, white);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    return {tex:t, size:1};
  }

  let prog=null, u={}, aPos=-1, vbo=null, tex=null;
  let t0 = performance.now()/1000;
  let density = 0.035; let speedX = 60.0, speedY = 0.0;

  function init(){
    if(!gl) return false;
    const vs=shader(gl.VERTEX_SHADER, vsSource), fs=shader(gl.FRAGMENT_SHADER, fsSource);
    if(!vs||!fs) return false;
    prog = program(vs,fs); if(!prog) return false;
    gl.useProgram(prog);

    vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1,-1, 1,-1, -1,1, 1,-1, 1,1, -1,1 ]), gl.STATIC_DRAW);
    aPos = gl.getAttribLocation(prog, 'a_position'); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);

    u.time = gl.getUniformLocation(prog,'u_time');
    u.starSpeed = gl.getUniformLocation(prog,'u_starSpeed');
    u.density = gl.getUniformLocation(prog,'u_density');
    u.texture = gl.getUniformLocation(prog,'u_texture');
    u.texel = gl.getUniformLocation(prog,'u_texturePixelSize');

    tex = makeWhiteTex();
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, tex.tex);
    gl.uniform1i(u.texture, 0);
    gl.uniform2f(u.texel, 1/tex.size, 1/tex.size);

    gl.disable(gl.DEPTH_TEST); gl.disable(gl.BLEND);
    resize();
    return true;
  }

  function resize(){
    const dpr = Math.max(1, Math.min(2, devicePixelRatio||1));
    const w = Math.floor(bg.clientWidth*dpr), h = Math.floor(bg.clientHeight*dpr);
    if(bg.width!==w || bg.height!==h){ bg.width=w; bg.height=h; gl && gl.viewport(0,0,w,h); }
  }

  function render(nowMs){
    if(gl && prog){
      const t = nowMs/1000 - t0;
      gl.useProgram(prog);
      gl.uniform1f(u.time, t);
      gl.uniform2f(u.starSpeed, speedX, speedY);
      gl.uniform1f(u.density, density);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    } else if (fallback2D){
      fallback2D();
    }
  }

  function makeFallback(){
    const x = bg.getContext('2d'); const N = 1000;
    const stars = Array.from({length:N}, ()=>({x:Math.random()*bg.width, y:Math.random()*bg.height, a:0.5+Math.random()*0.5}));
    return function(){
      x.fillStyle='#000'; x.fillRect(0,0,bg.width,bg.height);
      x.fillStyle='#fff';
      const scale=Math.min(1, Math.max(0, density*5));
      for(const s of stars){
        x.globalAlpha = s.a * (0.2 + 0.8*scale);
        x.fillRect(s.x|0, s.y|0, 1, 1);
        s.x -= speedX*0.016; s.y -= speedY*0.016;
        if(s.x<0) s.x += bg.width; if(s.y<0) s.y += bg.height;
        if(s.x>bg.width) s.x -= bg.width; if(s.y>bg.height) s.y -= bg.height;
      }
      x.globalAlpha = 1;
    };
  }

  const ok = init();
  if(!ok){ gl=null; fallback2D = makeFallback(); }
  addEventListener('resize', resize, {passive:true});

  // Expose live setters for the drawer controls
  const densityEl = document.getElementById('density');
  const densityVal= document.getElementById('densityVal');
  const sx = document.getElementById('speedX');
  const sy = document.getElementById('speedY');
  function updateLabels(){ densityVal.textContent = density.toFixed(3); sx.value = String(Math.round(speedX)); sy.value = String(Math.round(speedY)); }
  densityEl.addEventListener('input', e => { density = Math.max(0, Math.min(0.2, parseFloat(e.target.value)||0)); updateLabels(); });
  sx.addEventListener('change', e => { speedX = parseFloat(e.target.value)||0; updateLabels(); });
  sy.addEventListener('change', e => { speedY = parseFloat(e.target.value)||0; updateLabels(); });
  updateLabels();

  // Hook into game loop
  window.__starfield__ = { render, resize };
})();

/* ============ Game + Mobile Controls ============ */
(function(){
  const game = document.getElementById('game'), ctx = game.getContext('2d');
  let width=0, height=0, dpr=1, state='menu';

  const player={ x:140, y:220, r:14, speed:280, cooldown:0, fireDelay:0.20, alive:true, inv:0 };
  const bullets=[], rocks=[]; let score=0,lastSpawn=0,elapsed=0,lives=3;

  // Keyboard (desktop) remains supported
  const keys=Object.create(null);
  addEventListener('keydown',e=>{ keys[e.key.toLowerCase()]=true; if(e.key===' ') e.preventDefault();
    if(e.key==='Enter'){ if(state==='menu'||state==='gameover'){ resetGame(); state='playing'; } }
    if(e.key.toLowerCase()==='p'){ state = (state==='playing') ? 'paused' : (state==='paused' ? 'playing' : 'paused'); }
  });
  addEventListener('keyup',e=>{ keys[e.key.toLowerCase()]=false; });

  // Drawer handle
  const drawer = document.getElementById('drawer'), handle = document.getElementById('handle');
  handle.addEventListener('click', ()=> drawer.classList.toggle('open'));

  // Virtual joystick + buttons
  const joyArea=document.getElementById('joyArea'), stick=document.getElementById('stick');
  const fireBtn=document.getElementById('fireBtn'), pauseBtn=document.getElementById('pauseBtn'), startBtn=document.getElementById('startBtn');
  let joyActive=false, joyCenter=null, joyVec={x:0,y:0}, autoFire=false;

  function setStick(dx,dy){
    const a=joyArea.getBoundingClientRect(), maxR=Math.min(a.width,a.height)*0.5;
    const len=Math.hypot(dx,dy), cl=Math.min(len,maxR*0.8);
    const nx=(len?dx/len:0)*cl, ny=(len?dy/len:0)*cl;
    stick.style.transform=`translate(${nx}px, ${ny}px)`;
  }
  function joyStart(x,y){ const a=joyArea.getBoundingClientRect();
    joyActive=true; joyCenter={x:a.left+a.width/2, y:a.top+a.height/2}; joyMove(x,y); }
  function joyMove(x,y){ if(!joyActive) return;
    const dx=x-joyCenter.x, dy=y-joyCenter.y; const a=joyArea.getBoundingClientRect(); const maxR=Math.min(a.width,a.height)*0.5;
    joyVec.x = Math.max(-1,Math.min(1, dx/(maxR*0.8)));
    joyVec.y = Math.max(-1,Math.min(1, dy/(maxR*0.8)));
    setStick(dx,dy);
  }
  function joyEnd(){ joyActive=false; joyVec.x=0; joyVec.y=0; stick.style.transform='translate(0,0)'; }

  joyArea.addEventListener('pointerdown', e=>{ e.preventDefault(); joyArea.setPointerCapture(e.pointerId); joyStart(e.clientX,e.clientY); });
  joyArea.addEventListener('pointermove', e=>{ if(!joyActive) return; e.preventDefault(); joyMove(e.clientX,e.clientY); });
  joyArea.addEventListener('pointerup',   e=>{ e.preventDefault(); joyArea.releasePointerCapture(e.pointerId); joyEnd(); });
  joyArea.addEventListener('pointercancel', joyEnd);

  fireBtn.addEventListener('pointerdown', e=>{ e.preventDefault(); autoFire=true; shoot(); });
  fireBtn.addEventListener('pointerup', ()=> autoFire=false);
  fireBtn.addEventListener('pointercancel', ()=> autoFire=false);
  pauseBtn.addEventListener('click', ()=>{ if(state==='playing'){ state='paused'; } else if(state==='paused'){ state='playing'; } });
  startBtn.addEventListener('click', ()=>{ if(state==='menu'||state==='gameover'){ resetGame(); state='playing'; } });

  function resize(){
    dpr = Math.max(1, Math.min(2, devicePixelRatio||1));
    const w = Math.floor(game.clientWidth*dpr), h = Math.floor(game.clientHeight*dpr);
    if(game.width!==w || game.height!==h){ game.width=w; game.height=h; width=w; height=h; }
    if(window.__starfield__) window.__starfield__.resize();
  }

  function resetGame(){
    bullets.length=0; rocks.length=0; score=0; elapsed=0; lastSpawn=0; lives=3;
    player.x=140; player.y=height/2; player.cooldown=0; player.alive=true; player.inv=1.0;
  }
  function spawnRock(){ const y=Math.random()*height; const r=10+Math.random()*24; const sp=120+Math.random()*240;
    rocks.push({x:width+r+10, y, r, vx:-sp, vy:(Math.random()-0.5)*50}); }
  function shoot(){ if(player.cooldown>0||!player.alive||state!=='playing') return;
    bullets.push({x:player.x+player.r+4, y:player.y, r:4, vx:480}); player.cooldown=player.fireDelay; }

  function update(dt){
    if(state!=='playing') return;
    elapsed+=dt; score+=dt*10;
    if(player.cooldown>0) player.cooldown-=dt;
    if(player.inv>0) player.inv-=dt;

    const up=keys['arrowup']||keys['w']||joyVec.y<-0.1,
          down=keys['arrowdown']||keys['s']||joyVec.y>0.1,
          left=keys['arrowleft']||keys['a']||joyVec.x<-0.1,
          right=keys['arrowright']||keys['d']||joyVec.x>0.1;
    const sp=player.speed, jx=Math.abs(joyVec.x), jy=Math.abs(joyVec.y);
    if(up) player.y -= sp*dt*Math.max(0.4, jy||1);
    if(down) player.y += sp*dt*Math.max(0.4, jy||1);
    if(left) player.x -= sp*dt*Math.max(0.4, jx||1);
    if(right) player.x += sp*dt*Math.max(0.4, jx||1);
    if(autoFire) shoot();

    player.x=Math.max(player.r, Math.min(width*0.5, player.x));
    player.y=Math.max(player.r, Math.min(height-player.r, player.y));

    for(let i=bullets.length-1;i>=0;--i){ const b=bullets[i]; b.x+=b.vx*dt; if(b.x-b.r>width){ bullets.splice(i,1); } }

    lastSpawn+=dt; const minInt=0.35; const diff=Math.min(1.0, elapsed/60.0); const target=Math.max(minInt, 0.9-0.55*diff);
    if(lastSpawn>=target){ spawnRock(); lastSpawn=0; }

    for(let i=rocks.length-1;i>=0;--i){ const r=rocks[i]; r.x+=r.vx*dt; r.y+=r.vy*dt;
      if(r.y<-r.r) r.y=height+r.r; if(r.y>height+r.r) r.y=-r.r;
      if(r.x<-r.r-50){ rocks.splice(i,1); continue; } }

    for(let i=rocks.length-1;i>=0;--i){ const ro=rocks[i];
      for(let j=bullets.length-1;j>=0;--j){ const b=bullets[j]; const dx=ro.x-b.x, dy=ro.y-b.y;
        if(dx*dx+dy*dy <= (ro.r+b.r)*(ro.r+b.r)){ bullets.splice(j,1); rocks.splice(i,1); score+=25; break; } } }

    if(player.alive && player.inv<=0){
      for(let i=rocks.length-1;i>=0;--i){ const ro=rocks[i]; const dx=ro.x-player.x, dy=ro.y-player.y;
        if(dx*dx+dy*dy <= (ro.r+player.r)*(ro.r+player.r)){ lives-=1; player.inv=1.5; rocks.splice(i,1);
          if(lives<=0){ player.alive=false; state='gameover'; break; } } }
    }
  }

  function draw(){
    ctx.clearRect(0,0,width,height);
    if(player.alive){
      ctx.save(); ctx.translate(player.x,player.y);
      const tilt= ((keys['arrowup']||keys['w']||joyVec.y<-0.1)?-0.15:0) + ((keys['arrowdown']||keys['s']||joyVec.y>0.1)?0.15:0);
      ctx.rotate(tilt);
      const blink = (player.inv>0) ? (Math.floor(performance.now()/100)%2===0) : true;
      if(blink){
        ctx.beginPath(); ctx.moveTo(-player.r,-player.r*0.7); ctx.lineTo(-player.r,player.r*0.7); ctx.lineTo(player.r,0); ctx.closePath();
        ctx.fillStyle='#8fd1ff'; ctx.fill(); ctx.lineWidth=2*(width/1200); ctx.strokeStyle='#dff3ff'; ctx.stroke();
      }
      ctx.restore();
    }
    ctx.fillStyle='#fff';
    for(const b of bullets){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }
    for(const ro of rocks){
      ctx.save(); ctx.translate(ro.x,ro.y); ctx.beginPath(); const n=7;
      for(let i=0;i<n;i++){ const a=(i/n)*Math.PI*2;
        const rad=ro.r*(0.75+0.3*Math.sin(i*1.7+(ro.x+ro.y)*0.01));
        const px=Math.cos(a)*rad, py=Math.sin(a)*rad;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.closePath(); ctx.fillStyle='#7a868e'; ctx.fill();
      ctx.strokeStyle='#c3ccd2'; ctx.lineWidth=1.5*(width/1200); ctx.stroke(); ctx.restore();
    }
    ctx.fillStyle='#eaeaea'; ctx.font=Math.round(16*(width/1280))+'px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.textAlign='left'; ctx.fillText('Score: '+Math.floor(score), 12, 24); ctx.fillText('Lives: '+lives, 12, 44);
    if(state==='menu'){ banner('STARFIELD STRIKE','Tap START or press Enter'); }
    else if(state==='paused'){ banner('PAUSED','Tap PAUSE or press P'); }
    else if(state==='gameover'){ banner('GAME OVER','Tap START or press Enter'); ctx.fillText('Final Score: '+Math.floor(score), 12, 64); }
  }
  function banner(title,subtitle){
    ctx.save(); ctx.textAlign='center'; const ts=Math.round(42*(width/1280)), ss=Math.round(18*(width/1280));
    ctx.font='bold '+ts+'px system-ui, -apple-system, Segoe UI, Roboto, Arial'; ctx.fillStyle='#fff';
    ctx.fillText(title, width/2, height*0.33);
    ctx.font=ss+'px system-ui, -apple-system, Segoe UI, Roboto, Arial'; ctx.fillStyle='#c9d6ff';
    ctx.fillText(subtitle, width/2, height*0.33 + ts*0.9);
    ctx.restore();
  }

  function tick(now){
    if(window.__starfield__) window.__starfield__.render(now);
    const t=now*0.001; if(!tick.last) tick.last=t;
    const dt=Math.min(0.05, Math.max(0.0001, t - tick.last)); tick.last=t;
    if(state==='playing') update(dt); draw();
    requestAnimationFrame(tick);
  }
  function init(){ resize(); addEventListener('resize', resize, {passive:true}); requestAnimationFrame(tick); }
  init();
})();
</script>
</body>
</html>