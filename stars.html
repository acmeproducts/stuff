<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"
/>
<title>Starfield Strike — Mobile First</title>
<style>
  :root{
    --ui-bg: rgba(0,0,0,0.55);
    --ui-border: rgba(255,255,255,0.18);
    --ui-fg:#eaeaea;
  }
  html, body {
    margin:0; padding:0; height:100%;
    background:#000; color:#ddd;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans';
    touch-action: none; /* prevent scroll/zoom during gameplay */
  }
  #wrap { position:relative; width:100%; height:100vh; overflow:hidden; }
  canvas { position:absolute; inset:0; width:100%; height:100%; display:block; }
  #bg   { z-index:0; }
  #game { z-index:1; }

  /* HUD (collapsible on small screens) */
  #hud {
    position:absolute; right:12px; top:12px; z-index:3;
    background: var(--ui-bg); color: var(--ui-fg);
    padding:10px 12px; border:1px solid var(--ui-border); border-radius:10px;
    width:min(60vw, 320px);
    -webkit-backdrop-filter: blur(4px); backdrop-filter: blur(4px);
  }
  #hud h1{ font-size:14px; margin:0 0 6px 0; }
  #hud label { display:block; font-size:12px; margin-top:6px; }
  #hud input[type="range"], #hud input[type="number"]{ width:100%; }
  #hud .row{ display:grid; grid-template-columns:1fr 1fr; gap:8px; }
  #hud button{
    width:100%; margin-top:8px; padding:10px;
    background:#0f0f0f; color:#eee; border:1px solid #333; border-radius:8px;
  }
  #hud[data-collapsed="true"] .content{ display:none; }
  #hud .header{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
  #hud .toggle{ background:#111; color:#ddd; border:1px solid #333; border-radius:6px; padding:6px 8px; }

  /* Mobile on-screen controls */
  #controls{
    position:absolute; left:0; right:0; bottom:0; z-index:2; pointer-events:auto;
    padding: env(safe-area-inset-bottom) 12px 12px 12px;
    display:flex; justify-content:space-between; gap:12px;
  }
  .pad-area{
    position:relative; width: 42vw; max-width: 330px; height: 42vw; max-height: 330px;
  }
  .pad{
    position:absolute; inset:0; border-radius:50%;
    background: rgba(255,255,255,0.05);
    border:1px solid rgba(255,255,255,0.12);
  }
  .stick{
    position:absolute; width:35%; height:35%;
    left:32.5%; top:32.5%; border-radius:50%;
    background: rgba(255,255,255,0.18);
    border:1px solid rgba(255,255,255,0.35);
    transition: transform 80ms ease-out;
  }

  .buttons{ display:flex; flex-direction:column; gap:12px; align-items:flex-end; }
  .btn{
    min-width: 120px; min-height: 56px; padding:10px 14px; font-size:16px;
    border-radius:12px; background: rgba(255,255,255,0.07);
    color:#f2f2f2; border:1px solid rgba(255,255,255,0.2);
  }
  .btn:active{ transform: translateY(1px); }

  #footer{
    position:absolute; left:12px; bottom:12px; z-index:2;
    color:#9aa; font-size:12px; background: var(--ui-bg);
    padding:6px 8px; border:1px solid var(--ui-border); border-radius:6px; max-width: 70vw;
  }
  #footer kbd{ background:#0a0a0a; border:1px solid #333; border-radius:4px; padding:1px 4px; font-size:11px; }

  /* Desktop: hide touch controls */
  @media (hover:hover) and (pointer:fine){
    #controls{ display:none; }
    #footer{ max-width: none; }
  }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="bg"></canvas>
  <canvas id="game"></canvas>

  <div id="hud" data-collapsed="true" aria-label="Starfield Controls">
    <div class="header">
      <h1>Starfield</h1>
      <button id="toggleHud" class="toggle" aria-expanded="false">Panel</button>
    </div>
    <div class="content">
      <label for="density">Density <span id="densityVal"></span></label>
      <input id="density" type="range" min="0" max="1" step="0.001" value="0.010" />
      <div class="row">
        <div>
          <label for="speedX">Speed X</label>
          <input id="speedX" type="number" step="1" value="60" />
        </div>
        <div>
          <label for="speedY">Speed Y</label>
          <input id="speedY" type="number" step="1" value="0" />
        </div>
      </div>
      <button id="reset">Reset Starfield</button>
      <div style="font-size:12px; color:#b8c; margin-top:6px">
        Shader matches your effect: <code>uv=(pos+time*speed)*texel; uv=fract(uv)*step(random(floor(uv)),density); color=texture2D(texture,uv)</code>.
      </div>
    </div>
  </div>

  <!-- On-screen controls (mobile-first) -->
  <div id="controls" aria-label="On-screen controls">
    <div class="pad-area" id="joyArea" aria-label="Joystick">
      <div class="pad"></div>
      <div class="stick" id="stick"></div>
    </div>
    <div class="buttons">
      <button class="btn" id="fireBtn" aria-label="Fire">FIRE</button>
      <button class="btn" id="pauseBtn" aria-label="Pause/Resume">PAUSE</button>
      <button class="btn" id="startBtn" aria-label="Start/Restart">START</button>
    </div>
  </div>

  <div id="footer">
    <strong>Starfield Strike</strong> — Mobile: joystick + buttons below.
    Desktop: <kbd>WASD</kbd>/<kbd>Arrows</kbd> move, <kbd>Space</kbd> shoot, <kbd>P</kbd> pause, <kbd>Enter</kbd> start.
  </div>
</div>

<script>
/* Prevent pinch/scroll during gameplay on mobile (esp. iOS Safari) */
window.addEventListener('gesturestart', e => { e.preventDefault(); }, { passive:false });
window.addEventListener('touchmove', e => { if (e.touches.length > 0) e.preventDefault(); }, { passive:false });

/* ===========================
   WebGL Starfield Background
   (Godot canvas_item effect → WebGL)
   =========================== */
(function(){
  const bg = document.getElementById('bg');
  let gl = bg.getContext('webgl', { premultipliedAlpha:false, alpha:false, antialias:false });
  let fallback2D = null;

  // Fullscreen quad; pass pixel position to fragment (position ~ Godot VERTEX)
  const vsSource = `
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    varying vec2 v_pos;
    void main(){
      v_pos = (a_position * 0.5 + 0.5) * u_resolution;
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  `;

  // Fragment shader mirrors your logic:
  // uv = (position + time * starSpeed) * texturePixelSize;
  // uv = fract(uv) * step(random(floor(uv)), density);
  // color = texture2D(texture, uv);
  const fsSource = `
    precision mediump float;
    uniform vec2 u_resolution;
    uniform float u_time;
    uniform vec2 u_starSpeed;
    uniform float u_density;
    uniform sampler2D u_texture;
    uniform vec2 u_texturePixelSize;
    varying vec2 v_pos;

    float random(vec2 st){
      return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
    }

    void main(){
      vec2 position = v_pos;
      vec2 uv = (position + u_time * u_starSpeed) * u_texturePixelSize;
      uv = fract(uv) * step(random(floor(uv)), u_density);
      vec4 col = texture2D(u_texture, uv);
      gl_FragColor = col;
    }
  `;

  function makeShader(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      console.warn('Shader compile error:', gl.getShaderInfoLog(s));
      return null;
    }
    return s;
  }
  function makeProgram(vs, fs){
    const p = gl.createProgram();
    gl.attachShader(p, vs); gl.attachShader(p, fs);
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
      console.warn('Program link error:', gl.getProgramInfoLog(p));
      return null;
    }
    return p;
  }

  // Create a small star "sprite" texture: black with a soft white dot.
  function makeStarTexture(size = 64){
    const c = document.createElement('canvas');
    c.width = c.height = size;
    const x = c.getContext('2d');
    x.fillStyle = 'black'; x.fillRect(0,0,size,size);
    const g = x.createRadialGradient(size*0.5, size*0.5, size*0.05, size*0.5, size*0.5, size*0.5);
    g.addColorStop(0.00, 'rgba(255,255,255,1)');
    g.addColorStop(0.30, 'rgba(255,255,255,0.70)');
    g.addColorStop(0.60, 'rgba(255,255,255,0.25)');
    g.addColorStop(1.00, 'rgba(255,255,255,0.00)');
    x.fillStyle = g;
    x.beginPath(); x.arc(size*0.5, size*0.5, size*0.5*0.5, 0, Math.PI*2); x.fill();

    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, c);
    return { tex, size };
  }

  let program=null, u=null, buffer=null, star=null;
  let startTime = performance.now() / 1000;
  let userDensity = 0.010;
  let speedX = 60.0, speedY = 0.0;

  function init(){
    if(!gl) return false;
    const vs = makeShader(gl.VERTEX_SHADER, vsSource);
    const fs = makeShader(gl.FRAGMENT_SHADER, fsSource);
    if(!vs || !fs) return false;
    program = makeProgram(vs, fs);
    if(!program) return false;

    gl.useProgram(program);
    buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1,-1,  1,-1,  -1, 1,
       1,-1,  1, 1,  -1, 1
    ]), gl.STATIC_DRAW);

    const aPos = gl.getAttribLocation(program, 'a_position');
    gl.enableVertexAttribArray(aPos);
    gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

    u = {
      res: gl.getUniformLocation(program, 'u_resolution'),
      time: gl.getUniformLocation(program, 'u_time'),
      starSpeed: gl.getUniformLocation(program, 'u_starSpeed'),
      density: gl.getUniformLocation(program, 'u_density'),
      samp: gl.getUniformLocation(program, 'u_texture'),
      texel: gl.getUniformLocation(program, 'u_texturePixelSize'),
    };

    star = makeStarTexture(64);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, star.tex);
    gl.uniform1i(u.samp, 0);
    gl.uniform2f(u.texel, 1/star.size, 1/star.size);

    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
    resize();
    return true;
  }

  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = Math.floor(bg.clientWidth * dpr);
    const h = Math.floor(bg.clientHeight * dpr);
    if(bg.width !== w || bg.height !== h){
      bg.width = w; bg.height = h;
      if(gl){
        gl.viewport(0,0,w,h);
        if(program && u && u.res){
          gl.useProgram(program);
          gl.uniform2f(u.res, w, h);
        }
      }
    }
  }

  function render(now){
    if(gl && program){
      const t = now/1000 - startTime;
      gl.useProgram(program);
      gl.uniform1f(u.time, t);
      gl.uniform2f(u.starSpeed, speedX, speedY);
      gl.uniform1f(u.density, userDensity);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    } else if (fallback2D){
      fallback2D();
    }
  }

  function makeFallback(){
    const x = bg.getContext('2d');
    const stars = [];
    for(let i=0;i<800;i++){
      stars.push({ x:Math.random()*bg.width, y:Math.random()*bg.height, r:Math.random()*1.5+0.2, a:Math.random()*0.8+0.2 });
    }
    return function(){
      x.fillStyle = 'black'; x.fillRect(0,0,bg.width,bg.height);
      for(const s of stars){
        x.globalAlpha = s.a * (0.2 + 0.8 * (userDensity * 50.0));
        x.beginPath(); x.arc(s.x,s.y,s.r,0,Math.PI*2); x.fillStyle='#fff'; x.fill();
        s.x -= speedX * 0.016; s.y -= speedY * 0.016;
        if(s.x < 0) s.x += bg.width;
        if(s.y < 0) s.y += bg.height;
        if(s.x > bg.width) s.x -= bg.width;
        if(s.y > bg.height) s.y -= bg.height;
      }
      x.globalAlpha = 1;
    };
  }

  const ok = init();
  if(!ok){ gl = null; fallback2D = makeFallback(); }
  window.addEventListener('resize', resize, { passive:true });

  // Hook up UI
  const densityEl = document.getElementById('density');
  const densityVal = document.getElementById('densityVal');
  const sx = document.getElementById('speedX');
  const sy = document.getElementById('speedY');
  const reset = document.getElementById('reset');
  function updateLabels(){
    densityVal.textContent = Number(userDensity).toFixed(3);
    sx.value = String(Math.round(speedX));
    sy.value = String(Math.round(speedY));
  }
  densityEl.addEventListener('input', e => { userDensity = Math.max(0, Math.min(1, parseFloat(e.target.value)||0)); updateLabels(); });
  sx.addEventListener('change', e => { speedX = parseFloat(e.target.value)||0; updateLabels(); });
  sy.addEventListener('change', e => { speedY = parseFloat(e.target.value)||0; updateLabels(); });
  reset.addEventListener('click', () => { userDensity = 0.010; speedX = 60; speedY = 0; densityEl.value = '0.010'; updateLabels(); });
  updateLabels();

  // Export to game loop
  window.__starfield__ = { render, resize };
})();

/* ===========================
   2D Game Layer + Mobile Nav
   =========================== */
(function(){
  const game = document.getElementById('game');
  const ctx  = game.getContext('2d');

  let width=0, height=0, dpr=1;
  let state = 'menu'; // 'menu'|'playing'|'paused'|'gameover'

  const player = { x:120, y:200, r:14, speed:280, cooldown:0, fireDelay:0.20, alive:true, inv:0 };
  const bullets = [];
  const rocks   = [];
  let score = 0, lastSpawn = 0, elapsed = 0, lives = 3;

  // Desktop keyboard controls preserved
  const keys = Object.create(null);
  window.addEventListener('keydown', (e)=>{
    keys[e.key.toLowerCase()] = true;
    if(e.key === ' ') e.preventDefault();
    if(e.key === 'Enter'){ if(state==='menu' || state==='gameover'){ resetGame(); state='playing'; } }
    if(e.key.toLowerCase()==='p'){ state = (state==='playing') ? 'paused' : (state==='paused' ? 'playing' : 'paused'); }
  });
  window.addEventListener('keyup', (e)=>{ keys[e.key.toLowerCase()] = false; });

  // Mobile joystick + buttons
  const joyArea = document.getElementById('joyArea');
  const stick   = document.getElementById('stick');
  const fireBtn = document.getElementById('fireBtn');
  const pauseBtn= document.getElementById('pauseBtn');
  const startBtn= document.getElementById('startBtn');

  let joyActive=false, joyCenter=null, joyVec={x:0,y:0}, autoFire=false;

  function setStick(dx,dy){
    const area=joyArea.getBoundingClientRect();
    const maxR=Math.min(area.width,area.height)*0.5;
    const len=Math.hypot(dx,dy);
    const cl = Math.min(len, maxR*0.8);
    const nx=(len>0?dx/len:0)*cl, ny=(len>0?dy/len:0)*cl;
    stick.style.transform = `translate(${nx}px, ${ny}px)`;
  }
  function joyStart(x,y){
    const a=joyArea.getBoundingClientRect();
    joyActive=true; joyCenter={ x:a.left+a.width/2, y:a.top+a.height/2 };
    joyMove(x,y);
  }
  function joyMove(x,y){
    if(!joyActive) return;
    const dx=x-joyCenter.x, dy=y-joyCenter.y;
    const a=joyArea.getBoundingClientRect(); const maxR=Math.min(a.width,a.height)*0.5;
    joyVec.x = Math.max(-1, Math.min(1, dx/(maxR*0.8)));
    joyVec.y = Math.max(-1, Math.min(1, dy/(maxR*0.8)));
    setStick(dx,dy);
  }
  function joyEnd(){ joyActive=false; joyVec.x=0; joyVec.y=0; stick.style.transform='translate(0,0)'; }

  joyArea.addEventListener('pointerdown', e=>{ e.preventDefault(); joyArea.setPointerCapture(e.pointerId); joyStart(e.clientX,e.clientY); });
  joyArea.addEventListener('pointermove',  e=>{ if(!joyActive) return; e.preventDefault(); joyMove(e.clientX,e.clientY); });
  joyArea.addEventListener('pointerup',    e=>{ e.preventDefault(); joyArea.releasePointerCapture(e.pointerId); joyEnd(); });
  joyArea.addEventListener('pointercancel',()=> joyEnd());

  fireBtn.addEventListener('pointerdown', e=>{ e.preventDefault(); autoFire=true; shoot(); });
  fireBtn.addEventListener('pointerup',   ()=>{ autoFire=false; });
  fireBtn.addEventListener('pointercancel',()=>{ autoFire=false; });

  pauseBtn.addEventListener('click', ()=>{ state = (state==='playing') ? 'paused' : (state==='paused' ? 'playing' : state); });
  startBtn.addEventListener('click', ()=>{ if(state==='menu'||state==='gameover'){ resetGame(); state='playing'; } });

  // HUD collapse toggle
  const hud = document.getElementById('hud');
  const toggleHud = document.getElementById('toggleHud');
  toggleHud.addEventListener('click', ()=>{
    const collapsed = hud.getAttribute('data-collapsed') === 'true';
    hud.setAttribute('data-collapsed', collapsed ? 'false' : 'true');
    toggleHud.setAttribute('aria-expanded', collapsed ? 'true' : 'false');
  });

  function resize(){
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = Math.floor(game.clientWidth * dpr);
    const h = Math.floor(game.clientHeight * dpr);
    if(game.width !== w || game.height !== h){
      game.width = w; game.height = h; width = w; height = h;
    }
    if(window.__starfield__) window.__starfield__.resize();
  }

  function resetGame(){
    bullets.length = 0; rocks.length = 0; score = 0; elapsed = 0; lastSpawn = 0; lives = 3;
    player.x = 120; player.y = height/2; player.cooldown = 0; player.alive = true; player.inv = 1.0;
  }

  function spawnRock(){
    const y = Math.random()*height;
    const r = 10 + Math.random()*24;
    const sp= 120 + Math.random()*240;
    rocks.push({ x: width + r + 10, y, r, vx: -sp, vy: (Math.random()-0.5)*50 });
  }

  function shoot(){
    if(player.cooldown>0 || !player.alive || state!=='playing') return;
    bullets.push({ x: player.x + player.r + 4, y: player.y, r: 4, vx: 480 });
    player.cooldown = player.fireDelay;
  }

  function update(dt){
    if(state!=='playing') return;

    elapsed += dt; score += dt*10;
    if(player.cooldown>0) player.cooldown -= dt;
    if(player.inv>0) player.inv -= dt;

    // Movement: keyboard OR joystick (analog scaling)
    const up   = keys['arrowup']   || keys['w'] || joyVec.y < -0.1;
    const down = keys['arrowdown'] || keys['s'] || joyVec.y >  0.1;
    const left = keys['arrowleft'] || keys['a'] || joyVec.x < -0.1;
    const right= keys['arrowright']|| keys['d'] || joyVec.x >  0.1;

    const sp=player.speed, jx=Math.abs(joyVec.x), jy=Math.abs(joyVec.y);
    if(up)    player.y -= sp*dt * Math.max(0.4, jy || 1);
    if(down)  player.y += sp*dt * Math.max(0.4, jy || 1);
    if(left)  player.x -= sp*dt * Math.max(0.4, jx || 1);
    if(right) player.x += sp*dt * Math.max(0.4, jx || 1);

    if(autoFire) shoot();

    // Keep player on left half for readability
    player.x = Math.max(player.r, Math.min(width*0.5, player.x));
    player.y = Math.max(player.r, Math.min(height - player.r, player.y));

    // Bullets
    for(let i=bullets.length-1;i>=0;--i){
      const b = bullets[i];
      b.x += b.vx * dt;
      if(b.x - b.r > width){ bullets.splice(i,1); continue; }
    }

    // Spawning & rocks update
    lastSpawn += dt;
    const minInt = 0.35;
    const diff   = Math.min(1.0, elapsed / 60.0);
    const target = Math.max(minInt, 0.9 - 0.55 * diff);
    if(lastSpawn >= target){ spawnRock(); lastSpawn = 0; }

    for(let i=rocks.length-1;i>=0;--i){
      const r = rocks[i];
      r.x += r.vx * dt; r.y += r.vy * dt;
      if(r.y < -r.r) r.y = height + r.r;
      if(r.y > height + r.r) r.y = -r.r;
      if(r.x < -r.r - 50){ rocks.splice(i,1); continue; }
    }

    // Collisions: bullets vs rocks
    for(let i=rocks.length-1;i>=0;--i){
      const ro = rocks[i];
      for(let j=bullets.length-1;j>=0;--j){
        const b = bullets[j];
        const dx = ro.x - b.x, dy = ro.y - b.y;
        if(dx*dx + dy*dy <= (ro.r + b.r)*(ro.r + b.r)){
          bullets.splice(j,1);
          rocks.splice(i,1);
          score += 25;
          break;
        }
      }
    }

    // Collisions: player vs rocks
    if(player.alive && player.inv <= 0){
      for(let i=rocks.length-1;i>=0;--i){
        const ro = rocks[i];
        const dx = ro.x - player.x, dy = ro.y - player.y;
        if(dx*dx + dy*dy <= (ro.r + player.r)*(ro.r + player.r)){
          lives -= 1;
          player.inv = 1.5;
          rocks.splice(i,1);
          if(lives <= 0){ player.alive = false; state='gameover'; break; }
        }
      }
    }
  }

  function draw(){
    ctx.clearRect(0,0,width,height);

    // Player
    if(player.alive){
      ctx.save();
      ctx.translate(player.x, player.y);
      const tilt = ((keys['arrowup']||keys['w']||joyVec.y<-0.1) ? -0.15 : 0) +
                   ((keys['arrowdown']||keys['s']||joyVec.y>0.1) ?  0.15 : 0);
      ctx.rotate(tilt);
      const blink = (player.inv>0) ? (Math.floor(performance.now()/100)%2===0) : true;
      if(blink){
        ctx.beginPath();
        ctx.moveTo(-player.r, -player.r*0.7);
        ctx.lineTo(-player.r,  player.r*0.7);
        ctx.lineTo( player.r,  0);
        ctx.closePath();
        ctx.fillStyle = '#8fd1ff'; ctx.fill();
        ctx.lineWidth = 2 * (width/1200);
        ctx.strokeStyle = '#dff3ff'; ctx.stroke();
      }
      ctx.restore();
    }

    // Bullets
    ctx.fillStyle = '#fff';
    for(const b of bullets){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }

    // Rocks
    for(const ro of rocks){
      ctx.save(); ctx.translate(ro.x, ro.y);
      ctx.beginPath();
      const n=7;
      for(let i=0;i<n;i++){
        const a = (i/n)*Math.PI*2;
        const radius = ro.r * (0.75 + 0.3*Math.sin(i*1.7 + (ro.x+ro.y)*0.01));
        const px = Math.cos(a)*radius, py = Math.sin(a)*radius;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.closePath();
      ctx.fillStyle = '#7a868e'; ctx.fill();
      ctx.strokeStyle = '#c3ccd2'; ctx.lineWidth = 1.5 * (width/1200); ctx.stroke();
      ctx.restore();
    }

    // HUD text
    ctx.fillStyle = '#eaeaea';
    ctx.font = Math.round(16 * (width/1280)) + 'px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Score: ' + Math.floor(score), 12, 24);
    ctx.fillText('Lives: ' + lives,        12, 44);

    if(state==='menu'){ banner('STARFIELD STRIKE','Tap START or press Enter'); }
    else if(state==='paused'){ banner('PAUSED','Tap PAUSE or press P'); }
    else if(state==='gameover'){
      banner('GAME OVER','Tap START or press Enter');
      ctx.fillText('Final Score: ' + Math.floor(score), 12, 64);
    }
  }

  function banner(title, subtitle){
    ctx.save();
    ctx.textAlign = 'center';
    const ts = Math.round(42 * (width/1280));
    const ss = Math.round(18 * (width/1280));
    ctx.font = 'bold ' + ts + 'px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillStyle = '#ffffff';
    ctx.fillText(title, width/2, height*0.33);
    ctx.font = ss + 'px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillStyle = '#c9d6ff';
    ctx.fillText(subtitle, width/2, height*0.33 + ts*0.9);
    ctx.restore();
  }

  function tick(now){
    if(window.__starfield__){ window.__starfield__.render(now); }
    const t = now * 0.001;
    if(!tick.last) tick.last = t;
    const dt = Math.min(0.05, Math.max(0.0001, t - tick.last));
    tick.last = t;

    if(state==='playing'){ update(dt); }
    draw();
    requestAnimationFrame(tick);
  }

  function init(){
    resize();
    window.addEventListener('resize', resize, { passive:true });
    requestAnimationFrame(tick);
  }

  init();
})();
</script>
</body>
</html>