<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>A Gift to My Babydoll</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas { display: block; }

        #overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.5rem;
            text-align: center;
            opacity: 1;
            transition: opacity 2s ease;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            width: 80%;
            z-index: 10;
        }

        #rec-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 20px;
            color: white;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 150;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        #rec-dot {
            width: 10px;
            height: 10px;
            background-color: white;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }
        @keyframes pulse { 0% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(1.2); } 100% { opacity: 1; transform: scale(1); } }

        #master-footer {
            position: fixed;
            bottom: 10px;
            right: 15px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 100;
        }

        /* --- UI Controls --- */
        #settings-trigger {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
            transition: background 0.3s;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        #settings-trigger:active { transform: scale(0.95); }
        #settings-trigger svg { fill: white; width: 24px; height: 24px; }

        #settings-panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 320px;
            height: 100%; /* JS will override this for mobile stability */
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            box-shadow: -5px 0 20px rgba(0,0,0,0.2);
            transform: translateX(100%);
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            z-index: 201;
            padding: 70px 25px 30px 25px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }
        #settings-panel.open { transform: translateX(0); }

        #close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 24px;
            color: #666;
            cursor: pointer;
            padding: 10px;
        }

        .control-group { display: flex; flex-direction: column; gap: 8px; }
        .control-label { font-size: 13px; color: #555; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }
        
        input[type=range] { width: 100%; -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 18px; width: 18px; border-radius: 50%;
            background: #8ec5fc; cursor: pointer; margin-top: -7px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #ddd; border-radius: 2px;
        }

        .toggle-container { display: flex; justify-content: space-between; align-items: center; }
        .toggle-switch { position: relative; display: inline-block; width: 44px; height: 22px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc; transition: .4s; border-radius: 22px;
        }
        .slider:before {
            position: absolute; content: ""; height: 16px; width: 16px;
            left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: #8ec5fc; }
        input:checked + .slider:before { transform: translateX(22px); }

        textarea {
            width: 100%;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #ddd;
            background: #fff;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
            height: 80px;
        }

        .file-upload {
            border: 1px dashed #ccc;
            padding: 15px;
            text-align: center;
            border-radius: 6px;
            cursor: pointer;
            background: #f9f9f9;
            color: #666;
            font-size: 13px;
        }
        .file-upload:hover { background: #f0f0f0; }

        .theme-btn {
            background: #f0f0f0; border: none; padding: 12px; border-radius: 8px;
            color: #555; font-size: 14px; cursor: pointer; transition: background 0.2s; text-align: center;
        }
        .theme-btn:active { background: #e0e0e0; }
        #clear-btn { background: #ffebee; color: #c62828; margin-top: 10px; }
        #save-btn { background: #e8f5e9; color: #2e7d32; }
        #record-btn { background: #ffe0b2; color: #e65100; font-weight: bold; }
        #record-btn.recording { background: #ffcdd2; color: #c62828; animation: pulse-btn 2s infinite; }
        @keyframes pulse-btn { 0% { background: #ffcdd2; } 50% { background: #ef9a9a; } 100% { background: #ffcdd2; } }

    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="gameCanvas"></canvas>
        <div id="overlay">Tap to Bloom<br>Double Tap for Hearts<br><span style="font-size:0.7em; opacity:0.8">Drag to Flow</span></div>
        <div id="rec-indicator"><div id="rec-dot"></div>REC</div>
        <div id="master-footer">A Gift to My Babydoll - v3.4 - 2025-12-01 09:15 PM</div>
    </div>

    <div id="settings-trigger">
        <svg viewBox="0 0 24 24"><path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/></svg>
    </div>

    <div id="settings-panel">
        <div id="close-btn">&times;</div>
        
        <div class="control-group toggle-container">
            <span class="control-label">Sound</span>
            <label class="toggle-switch">
                <input type="checkbox" id="audio-toggle" checked>
                <span class="slider"></span>
            </label>
        </div>

        <div class="control-group">
            <span class="control-label">Background</span>
            <label class="file-upload">
                Select Image
                <input type="file" id="bg-upload" accept="image/*" style="display: none;">
            </label>
            <button class="theme-btn" id="reset-bg-btn" style="margin-top:5px; padding:6px; font-size:11px;">Reset to Gradient</button>
        </div>

        <div class="control-group">
            <span class="control-label">Custom Words / Commands</span>
            <textarea id="custom-words" placeholder="e.g. Joy, Peace. Commands: /cheat"></textarea>
        </div>

        <div class="control-group">
            <span class="control-label">Fade Rate</span>
            <input type="range" id="decay-slider" min="0" max="5" step="1" value="2">
        </div>

        <div class="control-group">
            <span class="control-label">Growth Speed</span>
            <input type="range" id="speed-slider" min="1" max="100" value="50">
        </div>
        
        <div class="control-group">
            <button class="theme-btn" id="record-btn">Record Video</button>
            <button class="theme-btn" id="save-btn">Save Snapshot</button>
            <button class="theme-btn" id="theme-btn">Cycle Colors</button>
            <button class="theme-btn" id="clear-btn">Clear Garden</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const recIndicator = document.getElementById('rec-indicator');
        
        // --- Audio Engine ---
        const ZenAudio = {
            ctx: null, enabled: true, masterGain: null, dest: null,
            // Extended Pentatonic Scale
            scale: [130.81, 146.83, 164.81, 196.00, 220.00, 261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25, 783.99, 880.00, 1046.50, 1174.66, 1318.51],

            init: function() {
                if (!this.ctx && (window.AudioContext || window.webkitAudioContext)) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.3;
                    this.dest = this.ctx.createMediaStreamDestination();
                    this.masterGain.connect(this.ctx.destination);
                    this.masterGain.connect(this.dest);
                }
                if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            },

            getFreq: function(y, height) {
                const norm = 1 - Math.max(0, Math.min(1, y / height));
                const index = Math.floor(norm * this.scale.length);
                return this.scale[Math.min(index, this.scale.length - 1)];
            },

            // Instruments
            playPluck: function(freq, volume = 0.3) {
                if (!this.ctx || !this.enabled) return;
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 2.0, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                const delayLength = Math.floor(this.ctx.sampleRate / freq);
                let idx = 0, last = 0;
                const noise = new Float32Array(delayLength).map(() => Math.random()*2-1);
                for (let i = 0; i < buffer.length; i++) {
                    const sample = (noise[idx] + last) * 0.5 * 0.992;
                    last = noise[idx]; noise[idx] = sample;
                    data[i] = sample * volume;
                    idx = (idx + 1) % delayLength;
                }
                const src = this.ctx.createBufferSource(); src.buffer = buffer;
                src.connect(this.masterGain); src.start();
            },

            playHarmonicCluster: function(count, baseFreq) {
                if (!this.ctx || !this.enabled) return;
                let baseIndex = 0;
                let closest = 10000;
                this.scale.forEach((f, i) => { if(Math.abs(f-baseFreq)<closest) { closest=Math.abs(f-baseFreq); baseIndex=i; }});
                
                for(let i=0; i<count; i++) {
                    const offset = Math.floor(Math.random() * 5) - 2; 
                    let noteIndex = Math.max(0, Math.min(this.scale.length-1, baseIndex + offset));
                    let freq = this.scale[noteIndex];
                    const delay = Math.random() * 0.2; 
                    setTimeout(() => { this.playChime(freq, 0.15); }, delay * 1000); 
                }
            },

            playChime: function(freq, volume = 0.1) {
                if (!this.ctx || !this.enabled) return;
                const osc = this.ctx.createOscillator(); osc.type = 'sine'; osc.frequency.value = freq * 2;
                const g = this.ctx.createGain(); g.connect(this.masterGain);
                const now = this.ctx.currentTime;
                g.gain.setValueAtTime(0, now); g.gain.linearRampToValueAtTime(volume, now+0.02); g.gain.exponentialRampToValueAtTime(0.001, now+1.5);
                osc.start(now); osc.stop(now+1.5);
            },

            playDiscovery: function() {
                if (!this.ctx || !this.enabled) return;
                [261.63, 329.63, 392.00, 523.25].forEach((f, i) => { setTimeout(() => this.playChime(f, 0.2), i * 150); });
            }
        };

        // --- Video Recorder ---
        let mediaRecorder, recordedChunks = [], isRecording = false;
        function toggleRecording() { isRecording ? stopRecording() : startRecording(); }
        function startRecording() {
            ZenAudio.init();
            const stream = canvas.captureStream(30);
            if (ZenAudio.dest && ZenAudio.dest.stream.getAudioTracks().length > 0) stream.addTrack(ZenAudio.dest.stream.getAudioTracks()[0]);
            
            let mimeType = 'video/mp4';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
                mimeType = 'video/webm;codecs=h264';
                if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'video/webm';
            }

            try { mediaRecorder = new MediaRecorder(stream, { mimeType }); } 
            catch (e) { alert("Recording not supported."); return; }

            recordedChunks = [];
            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
            mediaRecorder.onstop = saveRecording;
            mediaRecorder.start();
            isRecording = true;
            recIndicator.style.opacity = 1;
            document.getElementById('record-btn').classList.add('recording');
            document.getElementById('settings-panel').classList.remove('open');
        }
        function stopRecording() {
            if (mediaRecorder) mediaRecorder.stop();
            isRecording = false;
            recIndicator.style.opacity = 0;
            document.getElementById('record-btn').classList.remove('recording');
        }
        function saveRecording() {
            const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.style.display = "none"; a.href = url;
            a.download = `gift-video-${Date.now()}.${mediaRecorder.mimeType.includes("mp4") ? "mp4" : "webm"}`;
            document.body.appendChild(a); a.click();
            setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
        }

        // --- Layout & Resize Logic ---
        let width, height;
        function resize() { 
            width = window.innerWidth; 
            height = window.innerHeight; 
            canvas.width = width; 
            canvas.height = height; 
            // Correct panel height for mobile
            document.getElementById('settings-panel').style.height = window.innerHeight + 'px';
        }
        
        window.addEventListener('resize', resize);
        
        // Specific listener for orientation changes to force re-calc and close panel
        window.addEventListener('orientationchange', () => {
            document.getElementById('settings-panel').classList.remove('open'); // Auto close to prevent layout glitches
            setTimeout(resize, 200); // Delay to allow rotation animation to finish
        });
        
        resize();

        // --- Config ---
        const themes = [
            { bg: ['#e0c3fc', '#8ec5fc'], text: '#4a148c' },
            { bg: ['#fad0c4', '#ffd1ff'], text: '#880e4f' },
            { bg: ['#d299c2', '#fef9d7'], text: '#3e2723' },
            { bg: ['#a1c4fd', '#c2e9fb'], text: '#01579b' },
            { bg: ['#d4fc79', '#96e6a1'], text: '#1b5e20' } 
        ];
        const decayRates = [0.0, 0.002, 0.005, 0.01, 0.02, 0.05]; 
        
        const config = {
            currentThemeIndex: 0,
            defaultWords: [
                "Peace", "Gentle", "Warmth", "Love", "Hope", "Empathy", "Calm", "Grace", "Kindness", "Light", "Joy", "Bliss",
                "Serenity", "Breathe Deep", "Be Here", "Soften", "Let Go", "You Are Enough", "Tranquility", "Balance", "Harmony",
                "Inner Peace", "Radiate", "Stillness", "Presence", "Gratitude", "Acceptance", "Flow", "Healing", "Strength",
                "Wisdom", "Patience", "Courage", "Trust", "Clarity", "Unity", "Wholeness"
            ],
            customWords: [],
            speedMultiplier: 1.0,
            decayValue: 0.005,
            useGradient: true,
            bgImageObj: null
        };

        const secretWords = [
            "Huoi I Love You", "You are my Sunshine", "I Love You My Sweetheart", "My Babydoll", "â¤ï¸â¤ï¸â¤ï¸", "ðŸ¥°â¤ï¸â™¥ï¸ðŸ§¡ðŸ«°",
            "whereever you go that's where I want to be", "Forever Yours", "My One and Only", "Soulmate", "Endless Love",
            "My Heart is Yours", "Together Always", "You Complete Me", "My Happy Place", "Love of My Life", "Dream Come True",
            "My Everything", "Cherished", "Adored", "My Rock", "Purest Love", "Only You", "Sweetheart", "Darling",
            "Beloved", "My Angel", "Home is You", "Infinite Love", "Unconditional", "My Better Half", "Twin Flame"
        ];

        let entities = [];
        let systemMessages = [];
        let gardenLevel = 0; 
        let foundEggs = JSON.parse(localStorage.getItem('garden_egg_ids') || "[]");
        
        const rhythmSequences = [
            { code: "TTT", id: 1 }, { code: "HH", id: 2 }, { code: "TTH", id: 3 }, 
            { code: "HTH", id: 4 }, { code: "TTTT", id: 5 }, { code: "HHT", id: 6 },
            { code: "THTH", id: 7 }, { code: "HTTH", id: 8 }, { code: "THH", id: 9 }, { code: "HHH", id: 10 }
        ];
        let inputBuffer = "";

        function checkDragUnlock(durationMs) {
            const seconds = durationMs / 1000;
            const targetLevel = 10 + Math.floor(seconds - 1);
            if (targetLevel > 10 && targetLevel <= 20) {
                const id = `DRAG_${targetLevel}`;
                if (!foundEggs.includes(id)) triggerUnlock(id, targetLevel);
            }
        }

        const maxLevelFound = foundEggs.reduce((max, id) => {
            let lvl = 0;
            if (typeof id === 'number') lvl = Math.floor(foundEggs.length / 2);
            else if (typeof id === 'string' && id.startsWith('DRAG_')) lvl = parseInt(id.split('_')[1]);
            return Math.max(max, lvl);
        }, 0);
        gardenLevel = maxLevelFound;

        function registerInput(type) {
            inputBuffer += type;
            if (inputBuffer.length > 5) inputBuffer = inputBuffer.slice(-5);
            rhythmSequences.forEach(seq => { if (inputBuffer.endsWith(seq.code)) triggerUnlock(seq.id, seq.id); });
        }

        function triggerUnlock(id, levelStrength) {
            inputBuffer = ""; 
            if (!foundEggs.includes(id)) {
                foundEggs.push(id);
                localStorage.setItem('garden_egg_ids', JSON.stringify(foundEggs));
                if (levelStrength > gardenLevel) gardenLevel = levelStrength;
                entities.push(new Mandala(width/2, height/2, gardenLevel));
                ZenAudio.playDiscovery();
            }
        }

        const random = (min, max) => Math.random() * (max - min) + min;
        function getPastelColor() { return `hsla(${random(0, 360)}, 70%, 80%,`; }
        function getRandomWord() {
            if (config.customWords.length > 0) return config.customWords[Math.floor(Math.random() * config.customWords.length)];
            return config.defaultWords[Math.floor(Math.random() * config.defaultWords.length)];
        }

        // --- Visual Entities ---
        class Word {
            constructor(x, y, text) {
                this.x = x; this.y = y; this.text = text || getRandomWord();
                this.velocity = -0.5; this.alpha = 0; this.life = 0; this.fadeIn = true;
                this.color = themes[config.currentThemeIndex].text; 
            }
            update() {
                this.y += this.velocity * config.speedMultiplier;
                if (this.fadeIn) { this.alpha += 0.02 * config.speedMultiplier; if (this.alpha>=1) this.fadeIn=false; }
                else if (config.decayValue > 0) this.alpha -= config.decayValue * config.speedMultiplier;
            }
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = Math.max(0, this.alpha);
                ctx.font = "20px sans-serif"; ctx.fillStyle = this.color;
                ctx.textAlign = "center"; ctx.shadowBlur = 4; ctx.shadowColor = "rgba(0,0,0,0.5)";
                ctx.fillText(this.text, this.x, this.y); ctx.restore();
            }
            isDead() { return this.alpha <= 0 && !this.fadeIn; }
        }

        class Bloom {
            constructor(x, y, size=null) {
                this.x = x; this.y = y; this.size = 0; this.maxSize = size || random(30, 80);
                this.colorBase = getPastelColor(); this.petals = Math.floor(random(5, 9));
                this.alpha = 1; this.level = gardenLevel;
            }
            update() {
                if (this.size < this.maxSize) this.size += 0.5 * config.speedMultiplier;
                else if (config.decayValue > 0) this.alpha -= config.decayValue * config.speedMultiplier;
            }
            draw(ctx) {
                ctx.save();
                if (this.level >= 10) { ctx.shadowBlur = 20; ctx.shadowColor = "white"; }
                for(let i=0; i<3; i++) {
                    ctx.fillStyle = this.colorBase + (this.alpha * (1 - i*0.2)) + ')';
                    ctx.beginPath();
                    for (let j = 0; j < this.petals; j++) {
                        const angle = (j / this.petals) * Math.PI * 2;
                        const petalSize = (this.size - (i*5));
                        if (petalSize <= 0) continue;
                        ctx.moveTo(this.x, this.y);
                        if (this.level < 5) ctx.arc(this.x + Math.cos(angle)*(petalSize*0.5), this.y + Math.sin(angle)*(petalSize*0.5), petalSize*0.4, 0, Math.PI*2);
                        else ctx.ellipse(this.x + Math.cos(angle)*(petalSize*0.5), this.y + Math.sin(angle)*(petalSize*0.5), petalSize*0.4, petalSize*0.2, angle, 0, Math.PI*2);
                    }
                    ctx.fill();
                }
                ctx.restore();
            }
            isDead() { return this.alpha <= 0; }
        }

        class HeartCloud {
            constructor(x, y) {
                this.x = x; this.y = y; this.alpha = 1;
                this.hearts = [];
                const count = Math.floor(random(2, 9));
                const colors = ["â¤ï¸", "ðŸ§¡", "ðŸ’›", "ðŸ’š", "ðŸ’™", "ðŸ’œ", "ðŸ¤Ž", "ðŸ¤"];
                const isHeartShape = Math.random() < 0.3;
                
                for(let i=0; i<count; i++) {
                    let ox, oy;
                    if(isHeartShape) {
                        const t = (i/count) * Math.PI * 2;
                        ox = (16 * Math.pow(Math.sin(t), 3)) * 2;
                        oy = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 2;
                    } else {
                        ox = random(-40, 40); oy = random(-40, 40);
                    }
                    this.hearts.push({
                        ox: ox, oy: oy, size: random(10, 40) + (gardenLevel * 1.5),
                        char: colors[Math.floor(Math.random()*colors.length)]
                    });
                }
                ZenAudio.playHarmonicCluster(count, ZenAudio.getFreq(y, height));
            }
            update() {
                this.y -= 0.5 * config.speedMultiplier;
                if (config.decayValue > 0) this.alpha -= config.decayValue * config.speedMultiplier;
            }
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = Math.max(0, this.alpha);
                this.hearts.forEach(h => {
                    ctx.font = `${h.size}px serif`;
                    ctx.fillText(h.char, this.x + h.ox, this.y + h.oy);
                });
                ctx.restore();
            }
            isDead() { return this.alpha <= 0; }
        }

        class CometTrail {
            constructor(x, y) {
                this.x = x; this.y = y; this.size = random(3, 8) + (gardenLevel*0.5); 
                this.alpha = 1; 
                this.color = `hsl(${random(200, 260)}, 100%, 80%)`;
            }
            update() { this.size *= 0.95; this.alpha -= 0.02; }
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = Math.max(0, this.alpha);
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
            isDead() { return this.alpha <= 0; }
        }

        class Ripple {
            constructor(x, y) {
                this.x = x; this.y = y; this.r = 0; this.alpha = 0.5;
            }
            update() { this.r += 2; this.alpha -= 0.015; }
            draw(ctx) {
                ctx.save(); ctx.strokeStyle = `rgba(255,255,255,${Math.max(0,this.alpha)})`;
                ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.stroke();
                ctx.restore();
            }
            isDead() { return this.alpha <= 0; }
        }

        class Mandala {
            constructor(x, y, level) {
                this.x = x; this.y = y; this.r = 0; this.maxR = 300; this.alpha = 1; this.level = level;
                this.rot = 0;
            }
            update() { this.r += 1.5; this.alpha -= 0.005; this.rot += 0.02; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rot); ctx.globalAlpha = Math.max(0, this.alpha);
                ctx.strokeStyle = `hsla(${this.r % 360}, 70%, 70%, 0.8)`; ctx.lineWidth = 2;
                const layers = 3 + Math.floor(this.level/5);
                for(let l=1; l<=layers; l++) {
                    const petals = 6 * l;
                    ctx.beginPath();
                    for(let i=0; i<petals; i++) {
                        const angle = (Math.PI*2/petals) * i;
                        const dist = this.r * (l/layers);
                        const px = Math.cos(angle) * dist; const py = Math.sin(angle) * dist;
                        ctx.moveTo(px, py); ctx.arc(px, py, dist * 0.2, 0, Math.PI*2);
                    }
                    ctx.stroke();
                }
                ctx.restore();
            }
            isDead() { return this.alpha <= 0; }
        }

        // --- Inputs ---
        let lastTap = 0, touchStart = 0, isDragging = false;
        let lastDragY = 0;
        
        function handleStart(x, y) { 
            ZenAudio.init(); touchStart = Date.now(); isDragging = true;
            document.getElementById('overlay').style.opacity = 0;
            lastDragY = y;
        }
        
        function handleMove(x, y) {
            if (isDragging) {
                // Audio: String Crossing (Harp Effect)
                if (Math.abs(y - lastDragY) > 15) { 
                    const freq = ZenAudio.getFreq(y, height);
                    ZenAudio.playPluck(freq, 0.15); 
                    lastDragY = y;
                }
                entities.push(new CometTrail(x, y));
                if (Math.random() < 0.1) entities.push(new Ripple(x, y));
            }
        }

        function handleEnd(x, y) {
            isDragging = false; 
            const dur = Date.now() - touchStart; const diff = Date.now() - lastTap; const freq = ZenAudio.getFreq(y, height);
            checkDragUnlock(dur);
            if (dur < 300) registerInput("T"); else registerInput("H");

            if (diff < 300 && dur < 300) {
                entities.push(new HeartCloud(x, y));
                entities.push(new Word(x, y-60));
            } else {
                if (dur < 300) {
                    entities.push(new Bloom(x, y)); entities.push(new Word(x, y-30)); ZenAudio.playPluck(freq, 0.3);
                } else {
                    entities.push(new Bloom(x, y, 150)); ZenAudio.playChime(freq * 0.5, 0.2);
                }
            }
            lastTap = Date.now();
        }

        canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        canvas.addEventListener('mouseup', e => handleEnd(e.clientX, e.clientY));
        canvas.addEventListener('touchstart', e => { e.preventDefault(); handleStart(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
        canvas.addEventListener('touchmove', e => { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
        canvas.addEventListener('touchend', e => { e.preventDefault(); if(e.changedTouches.length) handleEnd(e.changedTouches[0].clientX, e.changedTouches[0].clientY); });

        // --- Background Storage ---
        const bgUpload = document.getElementById('bg-upload');
        function loadBgFromStorage() {
            const storedBg = localStorage.getItem('garden_bg');
            if (storedBg) {
                config.useGradient = false;
                const img = new Image();
                img.onload = () => { config.bgImageObj = img; };
                img.src = storedBg;
            }
        }
        loadBgFromStorage();
        bgUpload.addEventListener('change', e => {
            const file = e.target.files[0]; if (!file) return;
            const r = new FileReader();
            r.onload = evt => { 
                try { 
                    localStorage.setItem('garden_bg', evt.target.result); 
                    config.useGradient = false; 
                    const img = new Image();
                    img.onload = () => { config.bgImageObj = img; };
                    img.src = evt.target.result;
                } catch(e) { alert("Image too large!"); } 
            };
            r.readAsDataURL(file);
        });
        document.getElementById('reset-bg-btn').addEventListener('click', () => { 
            localStorage.removeItem('garden_bg'); 
            config.useGradient = true; 
            config.bgImageObj = null;
        });

        // --- Settings ---
        const panel = document.getElementById('settings-panel');
        document.getElementById('settings-trigger').addEventListener('click', () => panel.classList.add('open'));
        document.getElementById('close-btn').addEventListener('click', () => panel.classList.remove('open'));
        document.getElementById('audio-toggle').addEventListener('change', e => ZenAudio.enabled = e.target.checked);
        document.getElementById('decay-slider').addEventListener('input', e => config.decayValue = decayRates[e.target.value]);
        document.getElementById('speed-slider').addEventListener('input', e => config.speedMultiplier = 0.2 + (e.target.value/100)*1.8);
        document.getElementById('record-btn').addEventListener('click', toggleRecording);
        document.getElementById('clear-btn').addEventListener('click', () => { entities = []; systemMessages = []; });
        document.getElementById('theme-btn').addEventListener('click', () => config.currentThemeIndex = (config.currentThemeIndex + 1) % themes.length);
        document.getElementById('save-btn').addEventListener('click', () => { const a = document.createElement('a'); a.download = 'garden.png'; a.href = canvas.toDataURL(); a.click(); });

        const cBox = document.getElementById('custom-words');
        cBox.value = localStorage.getItem('garden_words') || "";
        parseWords(cBox.value);
        cBox.addEventListener('blur', e => { localStorage.setItem('garden_words', e.target.value); parseWords(e.target.value); });
        
        function parseWords(val) {
            systemMessages = [];
            if (val.trim() === '/cheat') { systemMessages.push("--- SECRETS ---"); rhythmSequences.forEach(s => systemMessages.push(s.code)); systemMessages.push("Drag 2-11s for levels 11-20"); }
            else if (val.trim() === '6969') { config.customWords = [...new Set([...config.defaultWords, ...secretWords])]; }
            else { config.customWords = val.split(',').map(s => s.trim()).filter(s => s.length); }
        }

        function loop() {
            // LAYER 1: Background (Drawn First)
            if (config.useGradient || !config.bgImageObj) {
                const t = themes[config.currentThemeIndex]; const g = ctx.createLinearGradient(0,0,0,height);
                g.addColorStop(0, t.bg[0]); g.addColorStop(1, t.bg[1]); ctx.fillStyle = g; ctx.fillRect(0,0,width,height);
            } else {
                // Robust Cover Logic (recalculated every frame)
                const img = config.bgImageObj;
                // Calculate scale to cover
                const scale = Math.max(width / img.width, height / img.height);
                const w = img.width * scale;
                const h = img.height * scale;
                const x = (width - w) / 2;
                const y = (height - h) / 2;
                ctx.drawImage(img, x, y, w, h);
            }

            // LAYER 2: Visuals (Drawn Second)
            for (let i = entities.length - 1; i >= 0; i--) {
                if (!(entities[i] instanceof Word)) {
                    entities[i].update(); entities[i].draw(ctx);
                    if (entities[i].isDead()) entities.splice(i, 1);
                }
            }

            // LAYER 3: Words (Drawn Last / On Top / Z-1000)
            for (let i = entities.length - 1; i >= 0; i--) {
                if (entities[i] instanceof Word) {
                    entities[i].update(); entities[i].draw(ctx);
                    if (entities[i].isDead()) entities.splice(i, 1);
                }
            }

            if (systemMessages.length) {
                ctx.save(); ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.fillRect(width/2-150, 40, 300, 20+systemMessages.length*20);
                ctx.fillStyle = "white"; ctx.font = "14px monospace"; ctx.textAlign = "center";
                systemMessages.forEach((m, i) => ctx.fillText(m, width/2, 65+i*20)); ctx.restore();
            }
            requestAnimationFrame(loop);
        }
        loop();
    </script>
</body>
</html>