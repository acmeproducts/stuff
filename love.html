<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>A Gift to My Babydoll</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas { display: block; }

        #overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.5rem;
            text-align: center;
            opacity: 1;
            transition: opacity 2s ease;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            width: 80%;
            z-index: 10;
        }

        #rec-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 20px;
            color: white;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 150;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        #rec-dot {
            width: 10px; height: 10px; background-color: white; border-radius: 50%; animation: pulse 1s infinite;
        }
        @keyframes pulse { 0% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(1.2); } 100% { opacity: 1; transform: scale(1); } }

        #master-footer {
            position: fixed;
            bottom: 10px;
            right: 15px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 100;
        }

        /* Sequence Display */
        #sequence-display {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: none;
            z-index: 100;
        }
        .seq-dot {
            font-size: 24px; color: rgba(255,255,255,0.8); text-shadow: 0 0 5px rgba(0,0,0,0.5);
            transition: transform 0.2s, opacity 0.5s;
        }
        .seq-fade { opacity: 0; transform: translateY(-20px); }

        /* --- UI Controls --- */
        .icon-btn {
            position: absolute;
            width: 44px; height: 44px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            z-index: 200;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(5px);
            transition: background 0.3s;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .icon-btn:active { transform: scale(0.95); }
        .icon-btn svg { fill: white; width: 24px; height: 24px; }

        #settings-trigger { top: 20px; right: 20px; }
        #secrets-trigger { top: 20px; left: 20px; }

        /* Secrets Panel */
        #secrets-panel, #settings-panel {
            position: absolute; top: 0; width: 320px; height: 100%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            box-shadow: -5px 0 20px rgba(0,0,0,0.2);
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            z-index: 201;
            padding: 70px 25px 30px 25px;
            box-sizing: border-box;
            display: flex; flex-direction: column; gap: 15px; overflow-y: auto;
        }
        #settings-panel { right: 0; transform: translateX(100%); }
        #settings-panel.open { transform: translateX(0); }
        
        #secrets-panel { left: 0; transform: translateX(-100%); box-shadow: 5px 0 20px rgba(0,0,0,0.2); }
        #secrets-panel.open { transform: translateX(0); }

        .close-btn {
            position: absolute; top: 20px; right: 20px;
            font-size: 24px; color: #666; cursor: pointer; padding: 10px;
        }

        .secret-item {
            background: #f5f5f5; padding: 12px; border-radius: 8px;
            border-left: 4px solid #ccc;
        }
        .secret-item.found { border-left-color: #ffd700; background: #fffbe6; }
        .secret-title { font-weight: bold; font-size: 14px; color: #333; }
        .secret-code { font-family: monospace; color: #666; font-size: 12px; margin-top: 4px; }

        /* Control Styles */
        .control-group { display: flex; flex-direction: column; gap: 8px; }
        .control-label { font-size: 13px; color: #555; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }
        input[type=range] { width: 100%; -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 18px; width: 18px; border-radius: 50%;
            background: #8ec5fc; cursor: pointer; margin-top: -7px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #ddd; border-radius: 2px; }
        .toggle-container { display: flex; justify-content: space-between; align-items: center; }
        .toggle-switch { position: relative; display: inline-block; width: 44px; height: 22px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 22px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #8ec5fc; }
        input:checked + .slider:before { transform: translateX(22px); }
        textarea { width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #ddd; background: #fff; font-family: inherit; font-size: 14px; resize: vertical; height: 80px; }
        .file-upload { border: 1px dashed #ccc; padding: 15px; text-align: center; border-radius: 6px; cursor: pointer; background: #f9f9f9; color: #666; font-size: 13px; }
        .theme-btn { background: #f0f0f0; border: none; padding: 12px; border-radius: 8px; color: #555; font-size: 14px; cursor: pointer; transition: background 0.2s; text-align: center; }
        .theme-btn:active { background: #e0e0e0; }
        #record-btn { background: #ffe0b2; color: #e65100; font-weight: bold; }
        #record-btn.recording { background: #ffcdd2; color: #c62828; animation: pulse-btn 2s infinite; }
        @keyframes pulse-btn { 0% { background: #ffcdd2; } 50% { background: #ef9a9a; } 100% { background: #ffcdd2; } }

    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="gameCanvas"></canvas>
        <div id="overlay">Tap to Bloom<br>Double Tap for Hearts<br><span style="font-size:0.7em; opacity:0.8">Hold to Deepen ‚Ä¢ Drag to Flow</span></div>
        <div id="rec-indicator"><div id="rec-dot"></div>REC</div>
        <div id="sequence-display"></div>
        <div id="master-footer">A Gift to My Babydoll - v3.5 - 2025-12-01 08:45 PM</div>
    </div>

    <div id="settings-trigger" class="icon-btn">
        <svg viewBox="0 0 24 24"><path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/></svg>
    </div>
    <div id="secrets-trigger" class="icon-btn">
        <svg viewBox="0 0 24 24"><path d="M12.65,10C11.83,7.67,9.61,6,7,6C3.69,6,1,8.69,1,12s2.69,6,6,6c2.61,0,4.83-1.67,5.65-4H17v4h4v-4h2v-4H12.65z M7,14 c-1.1,0-2-0.9-2-2s0.9-2,2-2s2,0.9,2,2S8.1,14,7,14z"/></svg>
    </div>

    <div id="secrets-panel">
        <div class="close-btn" id="close-secrets">&times;</div>
        <h3>Secrets Journal</h3>
        <div id="secrets-list"></div>
    </div>

    <div id="settings-panel">
        <div class="close-btn" id="close-settings">&times;</div>
        
        <div class="control-group toggle-container">
            <span class="control-label">Sound</span>
            <label class="toggle-switch"><input type="checkbox" id="audio-toggle" checked><span class="slider"></span></label>
        </div>
        <div class="control-group">
            <span class="control-label">Background</span>
            <label class="file-upload">Select Image <input type="file" id="bg-upload" accept="image/*" style="display: none;"></label>
            <button class="theme-btn" id="reset-bg-btn" style="margin-top:5px; padding:6px; font-size:11px;">Reset to Gradient</button>
        </div>
        <div class="control-group">
            <span class="control-label">Custom Words</span>
            <textarea id="custom-words" placeholder="e.g. Joy, Peace"></textarea>
        </div>
        <div class="control-group">
            <span class="control-label">Fade Rate</span>
            <input type="range" id="decay-slider" min="0" max="5" step="1" value="2">
        </div>
        <div class="control-group">
            <span class="control-label">Growth Speed</span>
            <input type="range" id="speed-slider" min="1" max="100" value="50">
        </div>
        <div class="control-group">
            <button class="theme-btn" id="record-btn">Record Video</button>
            <button class="theme-btn" id="save-btn">Save Snapshot</button>
            <button class="theme-btn" id="theme-btn">Cycle Colors</button>
            <button class="theme-btn" id="clear-btn">Clear Garden</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const recIndicator = document.getElementById('rec-indicator');
        
        // --- Audio Engine ---
        const ZenAudio = {
            ctx: null, enabled: true, masterGain: null, dest: null,
            scale: [130.81, 146.83, 164.81, 196.00, 220.00, 261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25, 783.99, 880.00, 1046.50, 1174.66, 1318.51],
            init: function() {
                if (!this.ctx && (window.AudioContext || window.webkitAudioContext)) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain(); this.masterGain.gain.value = 0.3;
                    this.dest = this.ctx.createMediaStreamDestination();
                    this.masterGain.connect(this.ctx.destination); this.masterGain.connect(this.dest);
                }
                if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            },
            getFreq: function(y, height) {
                const norm = 1 - Math.max(0, Math.min(1, y / height));
                const index = Math.floor(norm * this.scale.length);
                return this.scale[Math.min(index, this.scale.length - 1)];
            },
            playPluck: function(freq, volume = 0.3) {
                if (!this.ctx || !this.enabled) return;
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 2.0, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                const delayLength = Math.floor(this.ctx.sampleRate / freq);
                let idx = 0, last = 0;
                const noise = new Float32Array(delayLength).map(() => Math.random()*2-1);
                for (let i = 0; i < buffer.length; i++) {
                    const sample = (noise[idx] + last) * 0.5 * 0.992;
                    last = noise[idx]; noise[idx] = sample; data[i] = sample * volume; idx = (idx + 1) % delayLength;
                }
                const src = this.ctx.createBufferSource(); src.buffer = buffer; src.connect(this.masterGain); src.start();
            },
            playHarmonicCluster: function(count, baseFreq) {
                if (!this.ctx || !this.enabled) return;
                let baseIndex = 0;
                let closest = 10000;
                this.scale.forEach((f, i) => { if(Math.abs(f-baseFreq)<closest) { closest=Math.abs(f-baseFreq); baseIndex=i; }});
                for(let i=0; i<count; i++) {
                    const offset = Math.floor(Math.random() * 5) - 2; 
                    let noteIndex = Math.max(0, Math.min(this.scale.length-1, baseIndex + offset));
                    setTimeout(() => { this.playChime(this.scale[noteIndex], 0.15); }, Math.random() * 200); 
                }
            },
            playChime: function(freq, volume = 0.1) {
                if (!this.ctx || !this.enabled) return;
                const osc = this.ctx.createOscillator(); osc.type = 'sine'; osc.frequency.value = freq * 2;
                const g = this.ctx.createGain(); g.connect(this.masterGain);
                const now = this.ctx.currentTime;
                g.gain.setValueAtTime(0, now); g.gain.linearRampToValueAtTime(volume, now+0.02); g.gain.exponentialRampToValueAtTime(0.001, now+1.5);
                osc.start(now); osc.stop(now+1.5);
            },
            playDiscovery: function() {
                if (!this.ctx || !this.enabled) return;
                [261.63, 329.63, 392.00, 523.25].forEach((f, i) => { setTimeout(() => this.playChime(f, 0.2), i * 150); });
            },
            startDragTone: function(freq) {
                if (!this.ctx || !this.enabled) return;
                if (!this.dragOsc) {
                    this.dragOsc = this.ctx.createOscillator(); this.dragOsc.type = 'triangle';
                    this.dragGain = this.ctx.createGain(); this.dragGain.gain.value = 0;
                    this.dragOsc.connect(this.dragGain); this.dragGain.connect(this.masterGain);
                    this.dragOsc.start();
                }
                this.dragOsc.frequency.setTargetAtTime(freq, this.ctx.currentTime, 0.1);
                this.dragGain.gain.setTargetAtTime(0.1, this.ctx.currentTime, 0.1);
            },
            updateDragTone: function(freq, volume) {
                if(this.dragOsc) {
                    this.dragOsc.frequency.setTargetAtTime(freq, this.ctx.currentTime, 0.1);
                    this.dragGain.gain.setTargetAtTime(volume, this.ctx.currentTime, 0.1);
                }
            },
            stopDragTone: function() { if(this.dragGain) this.dragGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.2); }
        };

        // --- Video Recorder ---
        let mediaRecorder, recordedChunks = [], isRecording = false;
        function toggleRecording() { isRecording ? stopRecording() : startRecording(); }
        function startRecording() {
            ZenAudio.init();
            const stream = canvas.captureStream(30);
            if (ZenAudio.dest && ZenAudio.dest.stream.getAudioTracks().length > 0) stream.addTrack(ZenAudio.dest.stream.getAudioTracks()[0]);
            let mimeType = 'video/mp4';
            if (!MediaRecorder.isTypeSupported(mimeType)) { mimeType = 'video/webm;codecs=h264'; if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'video/webm'; }
            try { mediaRecorder = new MediaRecorder(stream, { mimeType }); } catch (e) { alert("Recording not supported."); return; }
            recordedChunks = []; mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
            mediaRecorder.onstop = saveRecording; mediaRecorder.start(); isRecording = true;
            recIndicator.style.opacity = 1;
            document.getElementById('record-btn').classList.add('recording');
            document.getElementById('settings-panel').classList.remove('open');
        }
        function stopRecording() { if (mediaRecorder) mediaRecorder.stop(); isRecording = false; recIndicator.style.opacity = 0; document.getElementById('record-btn').classList.remove('recording'); }
        function saveRecording() {
            const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType });
            const url = URL.createObjectURL(blob); const a = document.createElement("a");
            a.style.display = "none"; a.href = url; a.download = `gift-video-${Date.now()}.${mediaRecorder.mimeType.includes("mp4") ? "mp4" : "webm"}`;
            document.body.appendChild(a); a.click(); setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
        }

        // --- Layout ---
        let width, height;
        function resize() { 
            width = window.innerWidth; height = window.innerHeight; canvas.width = width; canvas.height = height; 
            document.getElementById('settings-panel').style.height = window.innerHeight + 'px';
            document.getElementById('secrets-panel').style.height = window.innerHeight + 'px';
        }
        window.addEventListener('resize', resize);
        window.addEventListener('orientationchange', () => { document.getElementById('settings-panel').classList.remove('open'); document.getElementById('secrets-panel').classList.remove('open'); setTimeout(resize, 200); });
        resize();

        // --- Config ---
        const themes = [
            { bg: ['#e0c3fc', '#8ec5fc'], text: '#4a148c' },
            { bg: ['#fad0c4', '#ffd1ff'], text: '#880e4f' },
            { bg: ['#d299c2', '#fef9d7'], text: '#3e2723' },
            { bg: ['#a1c4fd', '#c2e9fb'], text: '#01579b' },
            { bg: ['#d4fc79', '#96e6a1'], text: '#1b5e20' } 
        ];
        const decayRates = [0.0, 0.002, 0.005, 0.01, 0.02, 0.05]; 
        const config = {
            currentThemeIndex: 0,
            defaultWords: ["Peace", "Gentle", "Warmth", "Love", "Hope", "Empathy", "Calm", "Grace", "Kindness", "Light", "Joy", "Bliss", "Serenity", "Breathe Deep", "Be Here", "Soften", "Let Go", "You Are Enough", "Tranquility", "Balance", "Harmony", "Inner Peace", "Radiate", "Stillness", "Presence", "Gratitude", "Acceptance", "Flow", "Healing", "Strength", "Wisdom", "Patience", "Courage", "Trust", "Clarity", "Unity", "Wholeness"],
            customWords: [],
            speedMultiplier: 1.0,
            decayValue: 0.005,
            useGradient: true,
            bgImageObj: null
        };
        const secretWords = ["Huoi I Love You", "You are my Sunshine", "I Love You My Sweetheart", "My Babydoll", "‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è", "ü•∞‚ù§Ô∏è‚ô•Ô∏èüß°ü´∞", "whereever you go that's where I want to be", "Forever Yours", "My One and Only", "Soulmate", "Endless Love", "My Heart is Yours", "Together Always", "You Complete Me", "My Happy Place", "Love of My Life", "Dream Come True", "My Everything", "Cherished", "Adored", "My Rock", "Purest Love", "Only You", "Sweetheart", "Darling", "Beloved", "My Angel", "Home is You", "Infinite Love", "Unconditional", "My Better Half", "Twin Flame"];

        let entities = [];
        let gardenLevel = 0; 
        let foundEggs = JSON.parse(localStorage.getItem('garden_egg_ids') || "[]");
        
        // --- SECRETS SYSTEM ---
        const rhythmSequences = [
            { code: "TTT", id: 1, name: "Zen Master (Tap Tap Tap)" }, 
            { code: "HH", id: 2, name: "Deep Breath (Hold Hold)" }, 
            { code: "TTH", id: 3, name: "Heartbeat (Tap Tap Hold)" }, 
            { code: "HTH", id: 4, name: "Sunrise (Hold Tap Hold)" }, 
            { code: "TTTT", id: 5, name: "Rainfall (4 Taps)" }, 
            { code: "HHT", id: 6, name: "Mountain (Hold Hold Tap)" },
            { code: "THTH", id: 7, name: "River Flow (T-H-T-H)" }, 
            { code: "HTTH", id: 8, name: "Lotus Open (H-T-T-H)" }, 
            { code: "THH", id: 9, name: "Wind (Tap Hold Hold)" }, 
            { code: "HHH", id: 10, name: "The Void (3 Holds)" }
        ];
        
        let inputBuffer = "";
        const seqDisplay = document.getElementById('sequence-display');

        function updateSecretsUI() {
            const list = document.getElementById('secrets-list');
            list.innerHTML = "";
            
            // Rhythm Secrets
            rhythmSequences.forEach(s => {
                const isFound = foundEggs.includes(s.id);
                const el = document.createElement('div');
                el.className = `secret-item ${isFound ? 'found' : ''}`;
                el.innerHTML = `<div class="secret-title">${isFound ? s.name : '??? (Locked)'}</div><div class="secret-code">${s.code.replace(/T/g, '‚óè ').replace(/H/g, '‚ñ¨ ')}</div>`;
                list.appendChild(el);
            });
            
            // Drag Secrets (11-20)
            const el = document.createElement('div');
            el.className = `secret-item ${gardenLevel > 10 ? 'found' : ''}`;
            el.innerHTML = `<div class="secret-title">Flow Master (Drag 2-11s)</div><div class="secret-code">Level: ${Math.max(0, gardenLevel-10)}/10</div>`;
            list.appendChild(el);
        }

        function checkDragUnlock(durationMs) {
            const seconds = durationMs / 1000;
            const targetLevel = 10 + Math.floor(seconds - 1);
            if (targetLevel > 10 && targetLevel <= 20) {
                const id = `DRAG_${targetLevel}`;
                if (!foundEggs.includes(id)) triggerUnlock(id, targetLevel);
            }
        }

        const maxLevelFound = foundEggs.reduce((max, id) => {
            let lvl = 0;
            if (typeof id === 'number') lvl = Math.floor(foundEggs.length / 2);
            else if (typeof id === 'string' && id.startsWith('DRAG_')) lvl = parseInt(id.split('_')[1]);
            return Math.max(max, lvl);
        }, 0);
        gardenLevel = maxLevelFound;

        function registerInput(type) {
            inputBuffer += type;
            if (inputBuffer.length > 5) inputBuffer = inputBuffer.slice(-5);
            
            // Visual Feedback
            const span = document.createElement('span');
            span.className = 'seq-dot';
            span.innerText = type === 'T' ? '‚óè' : '‚ñ¨';
            seqDisplay.appendChild(span);
            setTimeout(() => { span.classList.add('seq-fade'); setTimeout(() => span.remove(), 500); }, 1000);

            rhythmSequences.forEach(seq => { if (inputBuffer.endsWith(seq.code)) triggerUnlock(seq.id, seq.id); });
        }

        function triggerUnlock(id, levelStrength) {
            inputBuffer = ""; 
            if (!foundEggs.includes(id)) {
                foundEggs.push(id);
                localStorage.setItem('garden_egg_ids', JSON.stringify(foundEggs));
                if (levelStrength > gardenLevel) gardenLevel = levelStrength;
                entities.push(new Mandala(width/2, height/2, gardenLevel));
                ZenAudio.playDiscovery();
                updateSecretsUI();
            }
        }

        // --- Helper ---
        const random = (min, max) => Math.random() * (max - min) + min;
        function getPastelColor() { return `hsla(${random(0, 360)}, 70%, 80%,`; }
        function getRandomWord() {
            if (config.customWords.length > 0) return config.customWords[Math.floor(Math.random() * config.customWords.length)];
            return config.defaultWords[Math.floor(Math.random() * config.defaultWords.length)];
        }

        // --- Entities ---
        class Word {
            constructor(x, y, text) { this.x = x; this.y = y; this.text = text || getRandomWord(); this.velocity = -0.5; this.alpha = 0; this.life = 0; this.fadeIn = true; this.color = themes[config.currentThemeIndex].text; }
            update() { this.y += this.velocity * config.speedMultiplier; if (this.fadeIn) { this.alpha += 0.02 * config.speedMultiplier; if (this.alpha>=1) this.fadeIn=false; } else if (config.decayValue > 0) this.alpha -= config.decayValue * config.speedMultiplier; }
            draw(ctx) { ctx.save(); ctx.globalAlpha = Math.max(0, this.alpha); ctx.font = "20px sans-serif"; ctx.fillStyle = this.color; ctx.textAlign = "center"; ctx.shadowBlur = 4; ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.fillText(this.text, this.x, this.y); ctx.restore(); }
            isDead() { return this.alpha <= 0 && !this.fadeIn; }
        }

        class Bloom {
            constructor(x, y, size=null) { this.x = x; this.y = y; this.size = 0; this.maxSize = size || random(30, 80); this.colorBase = getPastelColor(); this.petals = Math.floor(random(5, 9)); this.alpha = 1; this.level = gardenLevel; }
            update() { if (this.size < this.maxSize) this.size += 0.5 * config.speedMultiplier; else if (config.decayValue > 0) this.alpha -= config.decayValue * config.speedMultiplier; }
            draw(ctx) {
                ctx.save();
                if (this.level >= 10) { ctx.shadowBlur = 20; ctx.shadowColor = "white"; }
                for(let i=0; i<3; i++) {
                    ctx.fillStyle = this.colorBase + (this.alpha * (1 - i*0.2)) + ')'; ctx.beginPath();
                    for (let j = 0; j < this.petals; j++) {
                        const angle = (j / this.petals) * Math.PI * 2; const petalSize = (this.size - (i*5)); if (petalSize <= 0) continue;
                        const px = this.x + Math.cos(angle) * (petalSize * 0.5); const py = this.y + Math.sin(angle) * (petalSize * 0.5);
                        ctx.moveTo(this.x, this.y); if (this.level < 5) ctx.arc(px, py, petalSize * 0.4, 0, Math.PI*2); else ctx.ellipse(px, py, petalSize*0.4, petalSize*0.2, angle, 0, Math.PI*2);
                    }
                    ctx.fill();
                }
                ctx.restore();
            }
            isDead() { return this.alpha <= 0; }
        }

        class HeartCloud {
            constructor(x, y) {
                this.x = x; this.y = y; this.alpha = 1; this.hearts = [];
                const count = Math.floor(random(2, 9));
                const colors = ["‚ù§Ô∏è", "üß°", "üíõ", "üíö", "üíô", "üíú", "ü§é", "ü§ç"];
                const isHeartShape = Math.random() < 0.3;
                for(let i=0; i<count; i++) {
                    let ox, oy;
                    if(isHeartShape) {
                        const t = (i/count) * Math.PI * 2; ox = (16 * Math.pow(Math.sin(t), 3)) * 2; oy = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 2;
                    } else { ox = random(-40, 40); oy = random(-40, 40); }
                    this.hearts.push({ ox: ox, oy: oy, size: random(10, 40) + (gardenLevel * 1.5), char: colors[Math.floor(Math.random()*colors.length)] });
                }
                ZenAudio.playHarmonicCluster(count, ZenAudio.getFreq(y, height));
            }
            update() { this.y -= 0.5 * config.speedMultiplier; if (config.decayValue > 0) this.alpha -= config.decayValue * config.speedMultiplier; }
            draw(ctx) { ctx.save(); ctx.globalAlpha = Math.max(0, this.alpha); this.hearts.forEach(h => { ctx.font = `${h.size}px serif`; ctx.fillText(h.char, this.x + h.ox, this.y + h.oy); }); ctx.restore(); }
            isDead() { return this.alpha <= 0; }
        }

        class CometTrail {
            constructor(x, y) { this.x = x; this.y = y; this.size = random(3, 8) + (gardenLevel*0.5); this.alpha = 1; this.color = `hsl(${random(200, 260)}, 100%, 80%)`; }
            update() { this.size *= 0.95; this.alpha -= 0.02; }
            draw(ctx) { ctx.save(); ctx.globalAlpha = Math.max(0, this.alpha); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
            isDead() { return this.alpha <= 0; }
        }

        class Mandala {
            constructor(x, y, level) { this.x = x; this.y = y; this.r = 0; this.maxR = 300; this.alpha = 1; this.level = level; this.rot = 0; }
            update() { this.r += 1.5; this.alpha -= 0.005; this.rot += 0.02; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rot); ctx.globalAlpha = Math.max(0, this.alpha);
                ctx.strokeStyle = `hsla(${this.r % 360}, 70%, 70%, 0.8)`; ctx.lineWidth = 2;
                const layers = 3 + Math.floor(this.level/5);
                for(let l=1; l<=layers; l++) {
                    const petals = 6 * l; ctx.beginPath();
                    for(let i=0; i<petals; i++) {
                        const angle = (Math.PI*2/petals) * i; const dist = this.r * (l/layers);
                        const px = Math.cos(angle) * dist; const py = Math.sin(angle) * dist;
                        ctx.moveTo(px, py); ctx.arc(px, py, dist * 0.2, 0, Math.PI*2);
                    }
                    ctx.stroke();
                }
                ctx.restore();
            }
            isDead() { return this.alpha <= 0; }
        }

        class InputRing {
            constructor(x, y) { this.x = x; this.y = y; this.r = 10; this.alpha = 1; this.charged = false; }
            update(isHolding) {
                if(isHolding) { 
                    this.r += 2; 
                    if(this.r > 40 && !this.charged) { this.charged = true; this.alpha = 0.5; } // Visual pop
                } else { this.alpha -= 0.1; }
            }
            draw(ctx) {
                ctx.save(); ctx.strokeStyle = this.charged ? "white" : "rgba(255,255,255,0.5)"; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.stroke(); ctx.restore();
            }
            isDead() { return this.alpha <= 0; }
        }

        // --- Inputs ---
        let lastTap = 0, touchStart = 0, isDragging = false;
        let lastDragY = 0, tapTimer = null;
        let currentInputRing = null;
        
        function handleStart(x, y) { 
            ZenAudio.init(); touchStart = Date.now(); isDragging = false;
            document.getElementById('overlay').style.opacity = 0;
            lastDragY = y;
            currentInputRing = new InputRing(x, y);
            entities.push(currentInputRing);
        }
        
        function handleMove(x, y) {
            // Drag threshold
            if (Math.abs(x - currentInputRing.x) > 10 || Math.abs(y - currentInputRing.y) > 10) {
                isDragging = true;
            }
            if (isDragging) {
                if (Math.abs(y - lastDragY) > 15) { 
                    const freq = ZenAudio.getFreq(y, height); ZenAudio.playPluck(freq, 0.15); lastDragY = y;
                }
                entities.push(new CometTrail(x, y));
            }
        }

        function handleEnd(x, y) {
            const dur = Date.now() - touchStart; const freq = ZenAudio.getFreq(y, height);
            
            if (currentInputRing) currentInputRing.update(false); // Fade out ring

            // Check Drag Secrets
            if (isDragging) {
                checkDragUnlock(dur);
                return; // Dragging overrides taps
            }

            // Differentiate Tap vs Hold
            if (dur > 300) {
                // HOLD
                registerInput("H");
                entities.push(new Bloom(x, y, 150)); ZenAudio.playChime(freq * 0.5, 0.2);
            } else {
                // TAP (Check for Double Tap)
                const now = Date.now();
                if (now - lastTap < 300) {
                    // Double Tap Detected
                    clearTimeout(tapTimer);
                    entities.push(new HeartCloud(x, y));
                    entities.push(new Word(x, y-60));
                } else {
                    // Possible Single Tap (Wait)
                    tapTimer = setTimeout(() => {
                        registerInput("T");
                        entities.push(new Bloom(x, y)); entities.push(new Word(x, y-30)); ZenAudio.playPluck(freq, 0.3);
                    }, 300);
                }
                lastTap = now;
            }
        }

        canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        canvas.addEventListener('mouseup', e => handleEnd(e.clientX, e.clientY));
        canvas.addEventListener('touchstart', e => { e.preventDefault(); handleStart(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
        canvas.addEventListener('touchmove', e => { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
        canvas.addEventListener('touchend', e => { e.preventDefault(); if(e.changedTouches.length) handleEnd(e.changedTouches[0].clientX, e.changedTouches[0].clientY); else handleEnd(currentInputRing.x, currentInputRing.y); });

        // --- Background Storage ---
        const bgUpload = document.getElementById('bg-upload');
        function loadBgFromStorage() {
            const storedBg = localStorage.getItem('garden_bg');
            if (storedBg) { config.useGradient = false; const img = new Image(); img.onload = () => { config.bgImageObj = img; }; img.src = storedBg; }
        }
        loadBgFromStorage();
        bgUpload.addEventListener('change', e => {
            const file = e.target.files[0]; if (!file) return;
            const r = new FileReader();
            r.onload = evt => { try { localStorage.setItem('garden_bg', evt.target.result); config.useGradient = false; const img = new Image(); img.onload = () => { config.bgImageObj = img; }; img.src = evt.target.result; } catch(e) { alert("Image too large!"); } };
            r.readAsDataURL(file);
        });
        document.getElementById('reset-bg-btn').addEventListener('click', () => { localStorage.removeItem('garden_bg'); config.useGradient = true; config.bgImageObj = null; });

        // --- Settings & Secrets ---
        const panel = document.getElementById('settings-panel');
        const secretsPanel = document.getElementById('secrets-panel');
        document.getElementById('settings-trigger').addEventListener('click', () => { panel.classList.add('open'); secretsPanel.classList.remove('open'); });
        document.getElementById('secrets-trigger').addEventListener('click', () => { secretsPanel.classList.add('open'); panel.classList.remove('open'); updateSecretsUI(); });
        document.getElementById('close-settings').addEventListener('click', () => panel.classList.remove('open'));
        document.getElementById('close-secrets').addEventListener('click', () => secretsPanel.classList.remove('open'));
        
        document.getElementById('audio-toggle').addEventListener('change', e => ZenAudio.enabled = e.target.checked);
        document.getElementById('decay-slider').addEventListener('input', e => config.decayValue = decayRates[e.target.value]);
        document.getElementById('speed-slider').addEventListener('input', e => config.speedMultiplier = 0.2 + (e.target.value/100)*1.8);
        document.getElementById('record-btn').addEventListener('click', toggleRecording);
        document.getElementById('clear-btn').addEventListener('click', () => { entities = []; });
        document.getElementById('theme-btn').addEventListener('click', () => config.currentThemeIndex = (config.currentThemeIndex + 1) % themes.length);
        document.getElementById('save-btn').addEventListener('click', () => { const a = document.createElement('a'); a.download = 'garden.png'; a.href = canvas.toDataURL(); a.click(); });

        const cBox = document.getElementById('custom-words');
        cBox.value = localStorage.getItem('garden_words') || "";
        parseWords(cBox.value);
        cBox.addEventListener('blur', e => { localStorage.setItem('garden_words', e.target.value); parseWords(e.target.value); });
        
        function parseWords(val) {
            if (val.trim() === '6969') { config.customWords = [...new Set([...config.defaultWords, ...secretWords])]; }
            else { config.customWords = val.split(',').map(s => s.trim()).filter(s => s.length); }
        }

        function loop() {
            if (config.useGradient || !config.bgImageObj) {
                const t = themes[config.currentThemeIndex]; const g = ctx.createLinearGradient(0,0,0,height);
                g.addColorStop(0, t.bg[0]); g.addColorStop(1, t.bg[1]); ctx.fillStyle = g; ctx.fillRect(0,0,width,height);
            } else {
                const img = config.bgImageObj;
                const ratio = Math.max(width / img.width, height / img.height);
                const w = img.width * ratio; const h = img.height * ratio;
                ctx.drawImage(img, (width - w) / 2, (height - h) / 2, w, h);
            }

            for (let i = entities.length - 1; i >= 0; i--) {
                if (!(entities[i] instanceof Word)) { entities[i].update(isDragging); entities[i].draw(ctx); if (entities[i].isDead()) entities.splice(i, 1); }
            }
            for (let i = entities.length - 1; i >= 0; i--) {
                if (entities[i] instanceof Word) { entities[i].update(); entities[i].draw(ctx); if (entities[i].isDead()) entities.splice(i, 1); }
            }
            requestAnimationFrame(loop);
        }
        loop();
    </script>
</body>
</html>