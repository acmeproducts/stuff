<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbital8 Login - Cloud File Manager</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .header h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #2d3748;
        }
        
        .header-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .provider-selector {
            display: flex;
            background: #f7fafc;
            border-radius: 10px;
            padding: 4px;
            gap: 4px;
        }
        
        .provider-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .provider-btn:not(.active) {
            background: transparent;
            color: #64748b;
        }
        
        .provider-btn.active {
            background: white;
            color: #2d3748;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .auth-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
        }
        
        .auth-status.connected {
            background: #dcfce7;
            color: #16a34a;
        }
        
        .auth-status.disconnected {
            background: #fef2f2;
            color: #dc2626;
        }
        
        .connect-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .connect-btn.primary {
            background: #3b82f6;
            color: white;
        }
        
        .connect-btn.primary:hover {
            background: #2563eb;
        }
        
        .connect-btn.danger {
            background: #ef4444;
            color: white;
        }
        
        .connect-btn.danger:hover {
            background: #dc2626;
        }
        
        .main-content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .toolbar {
            padding: 20px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            min-width: 200px;
        }
        
        .breadcrumb-item {
            padding: 6px 12px;
            background: #f1f5f9;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .breadcrumb-item:hover {
            background: #e2e8f0;
        }
        
        .breadcrumb-item.current {
            background: #3b82f6;
            color: white;
        }
        
        .view-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .sort-dropdown {
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
            font-size: 14px;
            cursor: pointer;
        }
        
        .grid-container {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            min-height: 400px;
        }
        
        .file-item, .folder-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .file-item:hover, .folder-item:hover {
            border-color: #3b82f6;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
            transform: translateY(-2px);
        }
        
        .file-item.selected, .folder-item.selected {
            border-color: #3b82f6;
            background: #eff6ff;
        }
        
        .item-icon {
            font-size: 32px;
            margin-bottom: 10px;
            display: block;
        }
        
        .folder-item .item-icon {
            color: #f59e0b;
        }
        
        .file-item .item-icon {
            color: #6b7280;
        }
        
        .item-name {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 5px;
            word-break: break-word;
        }
        
        .item-meta {
            font-size: 12px;
            color: #6b7280;
        }
        
        .loading-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px;
            color: #6b7280;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #e2e8f0;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px;
            color: #6b7280;
            text-align: center;
        }
        
        .empty-icon {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 150px;
            display: none;
        }
        
        .context-menu-item {
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .context-menu-item:hover {
            background: #f8fafc;
        }
        
        .context-menu-item:first-child {
            border-radius: 8px 8px 0 0;
        }
        
        .context-menu-item:last-child {
            border-radius: 0 0 8px 8px;
        }
        
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1001;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }
        
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        
        .toast.success {
            border-left: 4px solid #10b981;
        }
        
        .toast.error {
            border-left: 4px solid #ef4444;
        }
        
        .hidden {
            display: none !important;
        }
        
        @media (max-width: 768px) {
            .header-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .toolbar {
                flex-direction: column;
                align-items: stretch;
            }
            
            .grid-container {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-cloud"></i> Orbital8 Login</h1>
            <div class="header-controls">
                <div class="provider-selector">
                    <button class="provider-btn active" data-provider="googledrive">
                        <i class="fab fa-google-drive"></i>
                        Google Drive
                    </button>
                    <button class="provider-btn" data-provider="onedrive">
                        <i class="fab fa-microsoft"></i>
                        OneDrive
                    </button>
                </div>
                
                <div class="auth-status disconnected" id="auth-status">
                    <i class="fas fa-circle"></i>
                    <span>Not Connected</span>
                </div>
                
                <!-- Client Secret Input (Prototype Only) -->
                <div class="client-secret-section" id="client-secret-section">
                    <input type="password" id="client-secret-input" placeholder="Client Secret (for prototype)" 
                           style="padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; width: 200px;">
                    <button id="save-secret-btn" style="padding: 8px 12px; background: #10b981; color: white; border: none; border-radius: 6px; font-size: 14px; margin-left: 8px;">Save</button>
                </div>
                
                <button class="connect-btn primary" id="connect-btn">
                    <i class="fas fa-link"></i>
                    Connect
                </button>
            </div>
        </div>
        
        <div class="main-content">
            <div class="toolbar">
                <div class="breadcrumb" id="breadcrumb">
                    <div class="breadcrumb-item current">
                        <i class="fas fa-home"></i> Root
                    </div>
                </div>
                
                <div class="view-controls">
                    <select class="sort-dropdown" id="sort-dropdown">
                        <option value="name-asc">Name ↑</option>
                        <option value="name-desc">Name ↓</option>
                        <option value="modified-desc">Modified ↓</option>
                        <option value="modified-asc">Modified ↑</option>
                        <option value="size-desc">Size ↓</option>
                        <option value="size-asc">Size ↑</option>
                    </select>
                </div>
            </div>
            
            <div class="grid-container" id="grid-container">
                <div class="loading-state" id="loading-state">
                    <div class="spinner"></div>
                    <div>Connect to a storage provider to get started</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="context-menu" id="context-menu">
        <div class="context-menu-item" data-action="copy">
            <i class="fas fa-copy"></i>
            Copy
        </div>
        <div class="context-menu-item" data-action="move">
            <i class="fas fa-arrows-alt"></i>
            Move
        </div>
        <div class="context-menu-item" data-action="rename">
            <i class="fas fa-edit"></i>
            Rename
        </div>
        <div class="context-menu-item" data-action="delete">
            <i class="fas fa-trash"></i>
            Delete
        </div>
    </div>
    
    <div class="toast" id="toast">
        <div class="toast-content"></div>
    </div>

    <script>
        // ===== Storage Provider Architecture =====
        
        class StorageProvider {
            constructor(name) {
                this.name = name;
                this.isAuthenticated = false;
                this.accessToken = null;
                this.refreshToken = null;
            }
            
            async authenticate() {
                throw new Error('authenticate() must be implemented by provider');
            }
            
            async disconnect() {
                this.isAuthenticated = false;
                this.accessToken = null;
                this.refreshToken = null;
                this.clearStoredTokens();
            }
            
            async getFolders(parentId = 'root') {
                throw new Error('getFolders() must be implemented by provider');
            }
            
            async getFiles(folderId = 'root') {
                throw new Error('getFiles() must be implemented by provider');
            }
            
            async moveFile(fileId, targetFolderId) {
                throw new Error('moveFile() must be implemented by provider');
            }
            
            async copyFile(fileId, targetFolderId) {
                throw new Error('copyFile() must be implemented by provider');
            }
            
            async deleteFile(fileId) {
                throw new Error('deleteFile() must be implemented by provider');
            }
            
            async renameFile(fileId, newName) {
                throw new Error('renameFile() must be implemented by provider');
            }
            
            storeTokens(accessToken, refreshToken = null) {
                localStorage.setItem(`${this.name}_access_token`, accessToken);
                if (refreshToken) {
                    localStorage.setItem(`${this.name}_refresh_token`, refreshToken);
                }
            }
            
            loadStoredTokens() {
                this.accessToken = localStorage.getItem(`${this.name}_access_token`);
                this.refreshToken = localStorage.getItem(`${this.name}_refresh_token`);
                this.isAuthenticated = !!this.accessToken;
                return this.isAuthenticated;
            }
            
            clearStoredTokens() {
                localStorage.removeItem(`${this.name}_access_token`);
                localStorage.removeItem(`${this.name}_refresh_token`);
            }
        }
        
        // ===== Google Drive Provider =====
        
        class GoogleDriveProvider extends StorageProvider {
            constructor() {
                super('googledrive');
                // UPDATE WITH NEW DESKTOP CLIENT ID
                this.clientId = 'YOUR_NEW_DESKTOP_CLIENT_ID_HERE.apps.googleusercontent.com';
                this.redirectUri = 'https://acmeproducts.github.io/stuff/orbital8-login.html';
                this.scope = 'https://www.googleapis.com/auth/drive';
                this.apiBase = 'https://www.googleapis.com/drive/v3';
                
                // PKCE properties
                this.codeVerifier = null;
                this.codeChallenge = null;
            }
            
            // PKCE helper methods
            generateCodeVerifier() {
                const array = new Uint8Array(32);
                crypto.getRandomValues(array);
                return btoa(String.fromCharCode.apply(null, array))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
            }
            
            async generateCodeChallenge(verifier) {
                const encoder = new TextEncoder();
                const data = encoder.encode(verifier);
                const digest = await crypto.subtle.digest('SHA-256', data);
                return btoa(String.fromCharCode.apply(null, new Uint8Array(digest)))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
            }
            
            async authenticate() {
                if (!this.clientSecret) {
                    throw new Error('Client secret is required for authentication');
                }
                
                return new Promise(async (resolve, reject) => {
                    const authUrl = this.buildAuthUrl();
                    console.log('Auth URL:', authUrl); // Debug logging
                    
                    const popup = window.open(authUrl, 'google-auth', 'width=500,height=600,scrollbars=yes,resizable=yes');
                    
                    const checkClosed = setInterval(() => {
                        if (popup.closed) {
                            clearInterval(checkClosed);
                            reject(new Error('Authentication cancelled'));
                        }
                    }, 1000);
                    
                    const messageHandler = async (event) => {
                        if (event.origin !== window.location.origin) return;
                        
                        if (event.data.type === 'GOOGLE_AUTH_SUCCESS') {
                            clearInterval(checkClosed);
                            window.removeEventListener('message', messageHandler);
                            popup.close();
                            
                            try {
                                const tokens = await this.exchangeCodeForTokens(event.data.code);
                                this.accessToken = tokens.access_token;
                                this.refreshToken = tokens.refresh_token;
                                this.isAuthenticated = true;
                                this.storeTokens(this.accessToken, this.refreshToken);
                                resolve(true);
                            } catch (error) {
                                reject(error);
                            }
                        } else if (event.data.type === 'GOOGLE_AUTH_ERROR') {
                            clearInterval(checkClosed);
                            window.removeEventListener('message', messageHandler);
                            popup.close();
                            reject(new Error(event.data.error));
                        }
                    };
                    
                    window.addEventListener('message', messageHandler);
                });
            }
            
            buildAuthUrl() {
                console.log('Building auth URL...');
                console.log('Redirect URI:', this.redirectUri);
                
                const params = new URLSearchParams({
                    client_id: this.clientId,
                    redirect_uri: this.redirectUri,
                    response_type: 'code',
                    scope: this.scope,
                    access_type: 'offline',
                    prompt: 'consent'
                });
                
                const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;
                console.log('Final auth URL:', authUrl);
                
                return authUrl;
            }
            
            async exchangeCodeForTokens(code) {
                console.log('Exchanging code for tokens...');
                console.log('Code:', code);
                console.log('Using client secret:', !!this.clientSecret);
                
                const tokenRequest = {
                    client_id: this.clientId,
                    client_secret: this.clientSecret,
                    code: code,
                    grant_type: 'authorization_code',
                    redirect_uri: this.redirectUri
                };
                
                console.log('Token request:', { ...tokenRequest, client_secret: '[HIDDEN]' });
                
                try {
                    const response = await fetch('https://oauth2.googleapis.com/token', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams(tokenRequest)
                    });
                    
                    console.log('Token response status:', response.status);
                    
                    const responseText = await response.text();
                    console.log('Token response body:', responseText);
                    
                    if (!response.ok) {
                        throw new Error(`Token exchange failed: ${response.status} - ${responseText}`);
                    }
                    
                    return JSON.parse(responseText);
                } catch (error) {
                    console.error('Token exchange error:', error);
                    throw error;
                }
            }
            
            async refreshAccessToken() {
                if (!this.refreshToken) {
                    throw new Error('No refresh token available');
                }
                
                if (!this.clientSecret) {
                    throw new Error('Client secret not available');
                }
                
                const response = await fetch('https://oauth2.googleapis.com/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        client_id: this.clientId,
                        client_secret: this.clientSecret,
                        refresh_token: this.refreshToken,
                        grant_type: 'refresh_token'
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to refresh access token');
                }
                
                const tokens = await response.json();
                this.accessToken = tokens.access_token;
                this.storeTokens(this.accessToken, this.refreshToken);
                
                return tokens.access_token;
            }
            
            async makeApiCall(endpoint, options = {}) {
                if (!this.accessToken) {
                    throw new Error('Not authenticated');
                }
                
                const url = `${this.apiBase}${endpoint}`;
                const headers = {
                    'Authorization': `Bearer ${this.accessToken}`,
                    'Content-Type': 'application/json',
                    ...options.headers
                };
                
                let response = await fetch(url, {
                    ...options,
                    headers
                });
                
                // Handle token refresh on 401
                if (response.status === 401 && this.refreshToken) {
                    try {
                        await this.refreshAccessToken();
                        headers['Authorization'] = `Bearer ${this.accessToken}`;
                        response = await fetch(url, {
                            ...options,
                            headers
                        });
                    } catch (refreshError) {
                        this.isAuthenticated = false;
                        this.clearStoredTokens();
                        throw new Error('Authentication expired. Please reconnect.');
                    }
                }
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API Error:', errorText);
                    throw new Error(`API call failed: ${response.statusText}`);
                }
                
                return await response.json();
            }
            
            async getFolders(parentId = 'root') {
                const query = `'${parentId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`;
                const response = await this.makeApiCall(`/files?q=${encodeURIComponent(query)}&fields=files(id,name,createdTime,modifiedTime)`);
                
                return response.files.map(folder => ({
                    id: folder.id,
                    name: folder.name,
                    type: 'folder',
                    createdTime: folder.createdTime,
                    modifiedTime: folder.modifiedTime
                }));
            }
            
            async getFiles(folderId = 'root') {
                const query = `'${folderId}' in parents and trashed=false`;
                const response = await this.makeApiCall(`/files?q=${encodeURIComponent(query)}&fields=files(id,name,mimeType,size,createdTime,modifiedTime,thumbnailLink)`);
                
                const folders = response.files
                    .filter(file => file.mimeType === 'application/vnd.google-apps.folder')
                    .map(folder => ({
                        id: folder.id,
                        name: folder.name,
                        type: 'folder',
                        createdTime: folder.createdTime,
                        modifiedTime: folder.modifiedTime
                    }));
                
                const files = response.files
                    .filter(file => file.mimeType !== 'application/vnd.google-apps.folder')
                    .map(file => ({
                        id: file.id,
                        name: file.name,
                        type: 'file',
                        mimeType: file.mimeType,
                        size: file.size ? parseInt(file.size) : 0,
                        createdTime: file.createdTime,
                        modifiedTime: file.modifiedTime,
                        thumbnailLink: file.thumbnailLink
                    }));
                
                return { folders, files };
            }
            
            async moveFile(fileId, targetFolderId) {
                // First get current parents
                const fileResponse = await this.makeApiCall(`/files/${fileId}?fields=parents`);
                const previousParents = fileResponse.parents ? fileResponse.parents.join(',') : '';
                
                // Move file
                await this.makeApiCall(`/files/${fileId}?addParents=${targetFolderId}&removeParents=${previousParents}`, {
                    method: 'PATCH'
                });
                
                return true;
            }
            
            async copyFile(fileId, targetFolderId) {
                await this.makeApiCall(`/files/${fileId}/copy`, {
                    method: 'POST',
                    body: JSON.stringify({
                        parents: [targetFolderId]
                    })
                });
                
                return true;
            }
            
            async deleteFile(fileId) {
                await this.makeApiCall(`/files/${fileId}`, {
                    method: 'DELETE'
                });
                
                return true;
            }
            
            async renameFile(fileId, newName) {
                await this.makeApiCall(`/files/${fileId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({
                        name: newName
                    })
                });
                
                return true;
            }
        }
        
        // ===== OneDrive Provider (Stub for future implementation) =====
        
        class OneDriveProvider extends StorageProvider {
            constructor() {
                super('onedrive');
                this.clientId = 'YOUR_ONEDRIVE_CLIENT_ID';
                this.scope = 'https://graph.microsoft.com/Files.ReadWrite.All';
            }
            
            async authenticate() {
                // TODO: Implement Microsoft OAuth flow
                showToast('OneDrive integration coming soon!', 'error');
                throw new Error('OneDrive provider not yet implemented');
            }
            
            async getFolders(parentId = 'root') {
                throw new Error('OneDrive provider not yet implemented');
            }
            
            async getFiles(folderId = 'root') {
                throw new Error('OneDrive provider not yet implemented');
            }
        }
        
        // ===== File Manager UI =====
        
        class FileManagerUI {
            constructor() {
                this.providers = {
                    googledrive: new GoogleDriveProvider(),
                    onedrive: new OneDriveProvider()
                };
                this.currentProvider = null;
                this.currentFolderId = 'root';
                this.breadcrumbPath = [{ id: 'root', name: 'Root' }];
                this.selectedItems = new Set();
                this.sortBy = 'name-asc';
                
                this.initializeUI();
                this.loadStoredAuth();
            }
            
            initializeUI() {
                // Provider switching
                document.querySelectorAll('.provider-btn').forEach(btn => {
                    btn.addEventListener('click', () => this.switchProvider(btn.dataset.provider));
                });
                
                // Client secret handling
                document.getElementById('save-secret-btn').addEventListener('click', () => {
                    const secret = document.getElementById('client-secret-input').value.trim();
                    if (secret) {
                        this.currentProvider.setClientSecret(secret);
                        this.updateSecretStatus();
                        showToast('Client secret saved!', 'success');
                        document.getElementById('client-secret-input').value = '';
                    }
                });
                
                // Connect/disconnect button
                document.getElementById('connect-btn').addEventListener('click', () => {
                    if (this.currentProvider?.isAuthenticated) {
                        this.disconnect();
                    } else {
                        this.connect();
                    }
                });
                
                // Sort dropdown
                document.getElementById('sort-dropdown').addEventListener('change', (e) => {
                    this.sortBy = e.target.value;
                    this.refreshCurrentView();
                });
                
                // Context menu
                document.addEventListener('click', () => this.hideContextMenu());
                document.getElementById('context-menu').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.handleContextMenuAction(e.target.closest('.context-menu-item')?.dataset.action);
                });
                
                // Grid container events
                const gridContainer = document.getElementById('grid-container');
                gridContainer.addEventListener('click', (e) => this.handleGridClick(e));
                gridContainer.addEventListener('contextmenu', (e) => this.handleContextMenu(e));
                
                // Set initial provider
                this.switchProvider('googledrive');
            }
            
            loadStoredAuth() {
                Object.values(this.providers).forEach(provider => {
                    if (provider.loadStoredTokens()) {
                        if (provider === this.currentProvider) {
                            this.updateAuthStatus();
                            this.loadFiles();
                        }
                    }
                });
                
                // Update secret status
                this.updateSecretStatus();
            }
            
            updateSecretStatus() {
                const secretSection = document.getElementById('client-secret-section');
                const connectBtn = document.getElementById('connect-btn');
                
                if (this.currentProvider?.hasClientSecret()) {
                    secretSection.style.opacity = '0.5';
                    connectBtn.disabled = false;
                } else {
                    secretSection.style.opacity = '1';
                    connectBtn.disabled = false; // Allow connection attempt to show better error
                }
            }
            
            switchProvider(providerName) {
                // Update UI
                document.querySelectorAll('.provider-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.provider === providerName);
                });
                
                // Switch provider
                this.currentProvider = this.providers[providerName];
                this.currentFolderId = 'root';
                this.breadcrumbPath = [{ id: 'root', name: 'Root' }];
                this.selectedItems.clear();
                
                this.updateAuthStatus();
                this.updateSecretStatus();
                this.updateBreadcrumb();
                
                if (this.currentProvider.isAuthenticated) {
                    this.loadFiles();
                } else {
                    this.showDisconnectedState();
                }
            }
            
            async connect() {
                if (!this.currentProvider) return;
                
                // Check if client secret is available for Google Drive
                if (this.currentProvider.name === 'googledrive' && !this.currentProvider.hasClientSecret()) {
                    showToast('Please enter and save your client secret first', 'error');
                    document.getElementById('client-secret-input').focus();
                    return;
                }
                
                try {
                    showToast('Connecting...', 'info');
                    await this.currentProvider.authenticate();
                    this.updateAuthStatus();
                    this.loadFiles();
                    showToast('Connected successfully!', 'success');
                } catch (error) {
                    console.error('Connection error details:', error);
                    showToast(`Connection failed: ${error.message}`, 'error');
                    
                    // Show more detailed error in console
                    if (error.stack) {
                        console.error('Error stack:', error.stack);
                    }
                }
            }
            
            async disconnect() {
                if (!this.currentProvider) return;
                
                await this.currentProvider.disconnect();
                this.updateAuthStatus();
                this.showDisconnectedState();
                showToast('Disconnected', 'success');
            }
            
            updateAuthStatus() {
                const statusEl = document.getElementById('auth-status');
                const connectBtn = document.getElementById('connect-btn');
                
                if (this.currentProvider?.isAuthenticated) {
                    statusEl.className = 'auth-status connected';
                    statusEl.innerHTML = '<i class="fas fa-circle"></i><span>Connected</span>';
                    connectBtn.innerHTML = '<i class="fas fa-unlink"></i>Disconnect';
                    connectBtn.className = 'connect-btn danger';
                } else {
                    statusEl.className = 'auth-status disconnected';
                    statusEl.innerHTML = '<i class="fas fa-circle"></i><span>Not Connected</span>';
                    connectBtn.innerHTML = '<i class="fas fa-link"></i>Connect';
                    connectBtn.className = 'connect-btn primary';
                }
            }
            
            showDisconnectedState() {
                const gridContainer = document.getElementById('grid-container');
                gridContainer.innerHTML = `
                    <div class="loading-state">
                        <i class="fas fa-cloud-upload-alt" style="font-size: 48px; margin-bottom: 15px; opacity: 0.5;"></i>
                        <div>Connect to ${this.currentProvider.name} to browse files</div>
                    </div>
                `;
            }
            
            async loadFiles(folderId = this.currentFolderId) {
                if (!this.currentProvider?.isAuthenticated) {
                    this.showDisconnectedState();
                    return;
                }
                
                const gridContainer = document.getElementById('grid-container');
                gridContainer.innerHTML = `
                    <div class="loading-state">
                        <div class="spinner"></div>
                        <div>Loading files...</div>
                    </div>
                `;
                
                try {
                    const { folders, files } = await this.currentProvider.getFiles(folderId);
                    this.currentFolderId = folderId;
                    this.renderFiles(folders, files);
                } catch (error) {
                    console.error('Load files error:', error);
                    gridContainer.innerHTML = `
                        <div class="empty-state">
                            <i class="fas fa-exclamation-triangle empty-icon"></i>
                            <div>Error loading files: ${error.message}</div>
                        </div>
                    `;
                    showToast(`Error: ${error.message}`, 'error');
                }
            }
            
            renderFiles(folders, files) {
                const gridContainer = document.getElementById('grid-container');
                
                if (folders.length === 0 && files.length === 0) {
                    gridContainer.innerHTML = `
                        <div class="empty-state">
                            <i class="fas fa-folder-open empty-icon"></i>
                            <div>This folder is empty</div>
                        </div>
                    `;
                    return;
                }
                
                // Sort items
                const sortedFolders = this.sortItems(folders);
                const sortedFiles = this.sortItems(files);
                
                gridContainer.innerHTML = '';
                
                // Render folders first
                sortedFolders.forEach(folder => {
                    const folderEl = this.createFolderElement(folder);
                    gridContainer.appendChild(folderEl);
                });
                
                // Then render files
                sortedFiles.forEach(file => {
                    const fileEl = this.createFileElement(file);
                    gridContainer.appendChild(fileEl);
                });
            }
            
            sortItems(items) {
                const [field, direction] = this.sortBy.split('-');
                
                return [...items].sort((a, b) => {
                    let aVal, bVal;
                    
                    switch (field) {
                        case 'name':
                            aVal = a.name.toLowerCase();
                            bVal = b.name.toLowerCase();
                            break;
                        case 'modified':
                            aVal = new Date(a.modifiedTime || a.createdTime);
                            bVal = new Date(b.modifiedTime || b.createdTime);
                            break;
                        case 'size':
                            aVal = a.size || 0;
                            bVal = b.size || 0;
                            break;
                        default:
                            return 0;
                    }
                    
                    if (direction === 'asc') {
                        return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
                    } else {
                        return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
                    }
                });
            }
            
            createFolderElement(folder) {
                const div = document.createElement('div');
                div.className = 'folder-item';
                div.dataset.id = folder.id;
                div.dataset.type = 'folder';
                
                const modifiedDate = folder.modifiedTime ? 
                    new Date(folder.modifiedTime).toLocaleDateString() : 
                    new Date(folder.createdTime).toLocaleDateString();
                
                div.innerHTML = `
                    <i class="fas fa-folder item-icon"></i>
                    <div class="item-name">${folder.name}</div>
                    <div class="item-meta">Modified: ${modifiedDate}</div>
                `;
                
                div.addEventListener('dblclick', () => {
                    this.navigateToFolder(folder.id, folder.name);
                });
                
                return div;
            }
            
            createFileElement(file) {
                const div = document.createElement('div');
                div.className = 'file-item';
                div.dataset.id = file.id;
                div.dataset.type = 'file';
                
                const icon = this.getFileIcon(file.mimeType);
                const size = file.size ? this.formatFileSize(file.size) : '';
                const modifiedDate = file.modifiedTime ? 
                    new Date(file.modifiedTime).toLocaleDateString() : 
                    new Date(file.createdTime).toLocaleDateString();
                
                div.innerHTML = `
                    <i class="${icon} item-icon"></i>
                    <div class="item-name">${file.name}</div>
                    <div class="item-meta">${size ? size + ' • ' : ''}${modifiedDate}</div>
                `;
                
                return div;
            }
            
            getFileIcon(mimeType) {
                if (!mimeType) return 'fas fa-file';
                
                if (mimeType.startsWith('image/')) return 'fas fa-file-image';
                if (mimeType.startsWith('video/')) return 'fas fa-file-video';
                if (mimeType.startsWith('audio/')) return 'fas fa-file-audio';
                if (mimeType.includes('pdf')) return 'fas fa-file-pdf';
                if (mimeType.includes('word')) return 'fas fa-file-word';
                if (mimeType.includes('excel') || mimeType.includes('spreadsheet')) return 'fas fa-file-excel';
                if (mimeType.includes('powerpoint') || mimeType.includes('presentation')) return 'fas fa-file-powerpoint';
                if (mimeType.includes('text')) return 'fas fa-file-alt';
                if (mimeType.includes('zip') || mimeType.includes('archive')) return 'fas fa-file-archive';
                
                return 'fas fa-file';
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
            }
            
            navigateToFolder(folderId, folderName) {
                this.breadcrumbPath.push({ id: folderId, name: folderName });
                this.updateBreadcrumb();
                this.loadFiles(folderId);
            }
            
            updateBreadcrumb() {
                const breadcrumbEl = document.getElementById('breadcrumb');
                breadcrumbEl.innerHTML = '';
                
                this.breadcrumbPath.forEach((item, index) => {
                    const div = document.createElement('div');
                    div.className = `breadcrumb-item ${index === this.breadcrumbPath.length - 1 ? 'current' : ''}`;
                    div.textContent = item.name;
                    
                    if (index < this.breadcrumbPath.length - 1) {
                        div.addEventListener('click', () => {
                            this.breadcrumbPath = this.breadcrumbPath.slice(0, index + 1);
                            this.updateBreadcrumb();
                            this.loadFiles(item.id);
                        });
                    }
                    
                    breadcrumbEl.appendChild(div);
                    
                    if (index < this.breadcrumbPath.length - 1) {
                        const separator = document.createElement('i');
                        separator.className = 'fas fa-chevron-right';
                        separator.style.color = '#94a3b8';
                        separator.style.fontSize = '12px';
                        breadcrumbEl.appendChild(separator);
                    }
                });
            }
            
            handleGridClick(e) {
                const item = e.target.closest('.file-item, .folder-item');
                if (!item) {
                    this.selectedItems.clear();
                    this.updateSelection();
                    return;
                }
                
                if (e.ctrlKey || e.metaKey) {
                    // Multi-select
                    if (this.selectedItems.has(item.dataset.id)) {
                        this.selectedItems.delete(item.dataset.id);
                        item.classList.remove('selected');
                    } else {
                        this.selectedItems.add(item.dataset.id);
                        item.classList.add('selected');
                    }
                } else {
                    // Single select
                    this.selectedItems.clear();
                    document.querySelectorAll('.file-item.selected, .folder-item.selected').forEach(el => {
                        el.classList.remove('selected');
                    });
                    
                    this.selectedItems.add(item.dataset.id);
                    item.classList.add('selected');
                }
                
                this.updateSelection();
            }
            
            handleContextMenu(e) {
                e.preventDefault();
                
                const item = e.target.closest('.file-item, .folder-item');
                if (!item) return;
                
                // Select item if not already selected
                if (!this.selectedItems.has(item.dataset.id)) {
                    this.selectedItems.clear();
                    document.querySelectorAll('.file-item.selected, .folder-item.selected').forEach(el => {
                        el.classList.remove('selected');
                    });
                    
                    this.selectedItems.add(item.dataset.id);
                    item.classList.add('selected');
                    this.updateSelection();
                }
                
                this.showContextMenu(e.clientX, e.clientY);
            }
            
            showContextMenu(x, y) {
                const contextMenu = document.getElementById('context-menu');
                contextMenu.style.display = 'block';
                contextMenu.style.left = `${x}px`;
                contextMenu.style.top = `${y}px`;
                
                // Adjust position if menu would go off screen
                const rect = contextMenu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    contextMenu.style.left = `${x - rect.width}px`;
                }
                if (rect.bottom > window.innerHeight) {
                    contextMenu.style.top = `${y - rect.height}px`;
                }
            }
            
            hideContextMenu() {
                document.getElementById('context-menu').style.display = 'none';
            }
            
            async handleContextMenuAction(action) {
                this.hideContextMenu();
                
                if (this.selectedItems.size === 0) return;
                
                const selectedIds = Array.from(this.selectedItems);
                
                try {
                    switch (action) {
                        case 'copy':
                            await this.copyItems(selectedIds);
                            break;
                        case 'move':
                            await this.moveItems(selectedIds);
                            break;
                        case 'rename':
                            if (selectedIds.length === 1) {
                                await this.renameItem(selectedIds[0]);
                            }
                            break;
                        case 'delete':
                            await this.deleteItems(selectedIds);
                            break;
                    }
                } catch (error) {
                    showToast(`Error: ${error.message}`, 'error');
                }
            }
            
            async copyItems(itemIds) {
                // For demonstration - would need folder picker dialog
                showToast('Copy operation would require folder picker dialog', 'info');
            }
            
            async moveItems(itemIds) {
                // For demonstration - would need folder picker dialog
                showToast('Move operation would require folder picker dialog', 'info');
            }
            
            async renameItem(itemId) {
                const newName = prompt('Enter new name:');
                if (!newName) return;
                
                await this.currentProvider.renameFile(itemId, newName);
                showToast('File renamed successfully', 'success');
                this.refreshCurrentView();
            }
            
            async deleteItems(itemIds) {
                const confirmMsg = itemIds.length === 1 ? 
                    'Delete this item?' : 
                    `Delete ${itemIds.length} items?`;
                
                if (!confirm(confirmMsg)) return;
                
                for (const itemId of itemIds) {
                    await this.currentProvider.deleteFile(itemId);
                }
                
                showToast(`${itemIds.length} item(s) deleted`, 'success');
                this.selectedItems.clear();
                this.refreshCurrentView();
            }
            
            updateSelection() {
                // Could update toolbar buttons based on selection
            }
            
            async refreshCurrentView() {
                await this.loadFiles(this.currentFolderId);
            }
        }
        
        // ===== Utility Functions =====
        
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const toastContent = toast.querySelector('.toast-content');
            
            toastContent.textContent = message;
            toast.className = `toast ${type}`;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 4000);
        }
        
        // ===== Handle OAuth Callback =====
        
        // This handles the OAuth callback when the popup redirects back
        if (window.location.search.includes('code=')) {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const error = urlParams.get('error');
            
            if (window.opener) {
                if (error) {
                    window.opener.postMessage({
                        type: 'GOOGLE_AUTH_ERROR',
                        error: error
                    }, window.location.origin);
                } else if (code) {
                    window.opener.postMessage({
                        type: 'GOOGLE_AUTH_SUCCESS',
                        code: code
                    }, window.location.origin);
                }
                window.close();
            }
        }
        
        // ===== Initialize Application =====
        
        let fileManager;
        
        document.addEventListener('DOMContentLoaded', () => {
            fileManager = new FileManagerUI();
        });
    </script>
</body>
</html>